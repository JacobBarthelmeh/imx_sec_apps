From 51bbfa769ebc8bc00e2a264500fd0983bb130f3b Mon Sep 17 00:00:00 2001
From: Marouene Boubakri <marouene.boubakri@nxp.com>
Date: Thu, 30 Jan 2020 16:50:29 +0100
Subject: [PATCH 01/22] optee-os-imx: enable caam black key, blob, mp and ocotp
 features

%% original patch: 0001-optee-os-imx-enable-caam-black-key-blob-mp-and-ocotp.patch
---
 core/arch/arm/plat-imx/crypto_conf.mk         |  16 +-
 core/arch/arm/plat-imx/imx_ocotp.c            |  10 +-
 core/arch/arm/plat-imx/pta/pta_bk_mx.c        | 315 +++++++++++++
 core/arch/arm/plat-imx/pta/pta_blob_mx.c      | 222 +++++++++
 core/arch/arm/plat-imx/pta/pta_ocotp_mx.c     | 147 ++++++
 core/arch/arm/plat-imx/pta/sub.mk             |   4 +
 core/arch/arm/plat-imx/registers/ocotp-regs.h |   7 +-
 core/arch/arm/plat-imx/sub.mk                 |   4 +-
 core/drivers/caam/acipher/caam_prime.c        | 428 ++++++++++++++----
 core/drivers/caam/acipher/caam_rsa.c          |  60 ++-
 core/drivers/caam/caam_bk.c                   | 391 ++++++++++++++++
 core/drivers/caam/caam_blob.c                 | 236 +++++++++-
 core/drivers/caam/caam_ctrl.c                 |  12 +
 core/drivers/caam/caam_mp.c                   |   2 +-
 core/drivers/caam/hal/common/hal_ctrl.c       | 160 ++++++-
 core/drivers/caam/hal/imx_6_7/hal_ctrl.c      | 138 ------
 .../caam/hal/imx_8m/registers/ctrl_regs.h     |   9 +
 core/drivers/caam/include/caam_bk.h           |  25 +
 core/drivers/caam/include/caam_blob.h         |   9 -
 core/drivers/caam/include/caam_io.h           |  55 +++
 core/drivers/caam/include/desc_defines.h      |  27 +-
 core/drivers/caam/include/desc_helper.h       |  34 +-
 core/drivers/caam/sub.mk                      |   1 +
 core/lib/libimxcrypt/crypto_api/bk/bk.c       | 208 +++++++++
 core/lib/libimxcrypt/crypto_api/bk/sub.mk     |   1 +
 core/lib/libimxcrypt/crypto_api/blob/blob.c   | 183 ++++++++
 core/lib/libimxcrypt/crypto_api/blob/sub.mk   |   1 +
 .../crypto_api/include/crypto_extension.h     |  99 +++-
 .../crypto_api/include/libimxcrypt.h          |  60 ++-
 .../crypto_api/include/libimxcrypt_acipher.h  |   4 +
 .../crypto_api/include/libimxcrypt_bk.h       |  48 ++
 .../crypto_api/include/libimxcrypt_blob.h     |  34 ++
 core/lib/libimxcrypt/crypto_api/sub.mk        |   2 +
 lib/libmbedtls/include/mbedtls_config_uta.h   |   2 +
 lib/libutee/include/pta_bk.h                  |  39 ++
 lib/libutee/include/pta_blob.h                |  49 ++
 lib/libutee/include/pta_ocotp.h               |  27 ++
 37 files changed, 2806 insertions(+), 263 deletions(-)
 create mode 100644 core/arch/arm/plat-imx/pta/pta_bk_mx.c
 create mode 100644 core/arch/arm/plat-imx/pta/pta_blob_mx.c
 create mode 100644 core/arch/arm/plat-imx/pta/pta_ocotp_mx.c
 create mode 100644 core/arch/arm/plat-imx/pta/sub.mk
 create mode 100644 core/drivers/caam/caam_bk.c
 create mode 100644 core/drivers/caam/include/caam_bk.h
 create mode 100644 core/drivers/caam/include/caam_io.h
 create mode 100644 core/lib/libimxcrypt/crypto_api/bk/bk.c
 create mode 100644 core/lib/libimxcrypt/crypto_api/bk/sub.mk
 create mode 100644 core/lib/libimxcrypt/crypto_api/blob/blob.c
 create mode 100644 core/lib/libimxcrypt/crypto_api/blob/sub.mk
 create mode 100644 core/lib/libimxcrypt/crypto_api/include/libimxcrypt_bk.h
 create mode 100644 core/lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h
 create mode 100644 lib/libutee/include/pta_bk.h
 create mode 100644 lib/libutee/include/pta_blob.h
 create mode 100644 lib/libutee/include/pta_ocotp.h

diff --git a/core/arch/arm/plat-imx/crypto_conf.mk b/core/arch/arm/plat-imx/crypto_conf.mk
index e8b5aba3..fa423944 100644
--- a/core/arch/arm/plat-imx/crypto_conf.mk
+++ b/core/arch/arm/plat-imx/crypto_conf.mk
@@ -36,6 +36,10 @@ $(call force, CFG_CRYPTO_GCM_HW,n)
 $(call force, CFG_CRYPTO_PKCS_HW,n)
 
 $(call force, CFG_CRYPTO_BLOB_HW,y)
+$(call force, CFG_BLOB_PTA,y)
+$(call force, CFG_OCOTP_PTA,y)
+$(call force, CFG_CRYPTO_BK_HW,y)
+$(call force, CFG_BK_PTA,y)
 
 ifeq ($(filter y, $(CFG_MX6UL)$(CFG_MX7)$(CFG_MX8MM)$(CFG_MX8M)),y)
 # Definition of the Asymmetric Cipher supported by HW
@@ -47,6 +51,14 @@ endif
 
 $(call force, CFG_CRYPTO_CMAC_HW,y)
 
+#
+# Force CFG_IMX_MP to n for platform not supported it
+#
+ifneq ($(filter y, $(CFG_MX6UL)$(CFG_MX7)$(CFG_MX7ULP)$(CFG_MX8M)$(CFG_MX8MM)),y)
+$(call force, CFG_IMX_MP,n)
+else
+CFG_IMX_MP = y
+endif
 #
 # Enable Manufacturing Protection if the platform support it
 # CFG_CRYPTO_MP_HW enables the manufacturing protection functionnalities
@@ -54,7 +66,7 @@ $(call force, CFG_CRYPTO_CMAC_HW,y)
 # CFG_MANUFACT_PROTEC_PTA enables the MP PTA
 # CFG_MBEDTLS_MP enables the setting of the public key type
 #
-ifeq ($(filter y, $(CFG_MX6UL)$(CFG_MX7)), y)
+ifeq ($(CFG_IMX_MP),y)
 CFG_CRYPTO_MP_HW ?= y
 _CFG_CRYPTO_WITH_MP ?= y
 CFG_MANUFACT_PROTEC_PTA ?= y
@@ -88,4 +100,6 @@ $(call force, CFG_CRYPTO_AUTHENC_HW, $(call cryp-one-hw-enabled, CCM GCM))
 $(call force, CFG_CRYPTO_PK_HW, $(call cryp-one-hw-enabled, RSA ECC DH DSA))
 
 $(call force, _CFG_CRYPTO_WITH_HUK, $(call cryp-one-hw-enabled, BLOB))
+$(call force, _CFG_CRYPTO_WITH_BLOB, $(call cryp-one-hw-enabled, BLOB))
+$(call force, _CFG_CRYPTO_WITH_BK, $(call cryp-one-hw-enabled, BK))
 endif
diff --git a/core/arch/arm/plat-imx/imx_ocotp.c b/core/arch/arm/plat-imx/imx_ocotp.c
index 68d47283..70c1763c 100644
--- a/core/arch/arm/plat-imx/imx_ocotp.c
+++ b/core/arch/arm/plat-imx/imx_ocotp.c
@@ -16,7 +16,7 @@
 /* Platform includes */
 #include <imx.h>
 
-static uint32_t die_id;
+static uint64_t die_id;
 
 /**
  * @brief   Read device Die Id
@@ -34,12 +34,16 @@ int tee_otp_get_die_id(uint8_t *buffer, size_t len)
 		va = core_mmu_get_va(OCOTP_BASE, MEM_AREA_IO_SEC);
 
 		/* Read Fuse shadow register containing the chip DIE ID */
-		die_id = read32(va + OCOTP_DIE_ID);
+		die_id = read32(va + OCOTP_UID_HIGH);
+
+		die_id <<= 32;
+		die_id |=  read32(va + OCOTP_UID_LOW);
+
 #ifdef CFG_MX7ULP
 		/* Read and add part of the Wafer and Lot Number */
 		die_id |= (read32(va + OCOTP_WAFER_NO) << 16);
 #endif
-		IMSG("Device Die ID = 0x%"PRIx32"", die_id);
+		IMSG("Device Die ID = 0x%"PRIx64"", die_id);
 		if (die_id == 0) {
 			if (imx_is_device_closed()) {
 				IMSG("Bad Device ID - Stop");
diff --git a/core/arch/arm/plat-imx/pta/pta_bk_mx.c b/core/arch/arm/plat-imx/pta/pta_bk_mx.c
new file mode 100644
index 00000000..c0591353
--- /dev/null
+++ b/core/arch/arm/plat-imx/pta/pta_bk_mx.c
@@ -0,0 +1,315 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    pta_bk_mx.c
+ *
+ * @brief   Pseudo Trusted Application.\n
+ *			Key Encapsulation functionality
+ */
+
+/* Standard includes */
+#include <stdlib.h>
+#include <string.h>
+
+/* Library kernel includes */
+#include <kernel/pseudo_ta.h>
+
+/* Library libutee includes */
+#include <pta_bk.h>
+
+/* Library tee includes */
+#include <tee_api_types.h>
+
+/* Library crypto includes */
+#include <crypto_extension.h>
+#include <libimxcrypt_bk.h>
+
+/* Library crypto includes */
+#include <crypto/crypto.h>
+
+/* Global includes */
+#include <tee_api_defines.h>
+
+/** @brief    PTA name */
+#define BK_PTA_NAME "bk.pta"
+
+struct attr_packed {
+	uint32_t id;
+	uint32_t a;
+	uint32_t b;
+};
+
+static TEE_Result imxcrypt_buf_from_attr(struct imxcrypt_buf *buf,
+const TEE_Attribute *attrs, uint32_t attr_count)
+{
+	size_t i;
+
+	for (i = 0; i < attr_count; i++) {
+		/* We need only mem refs*/
+		if (attrs[i].attributeID & TEE_ATTR_BIT_VALUE)
+			return TEE_ERROR_BAD_PARAMETERS;
+
+		buf[i].data = attrs[i].content.ref.buffer;
+		buf[i].length = attrs[i].content.ref.length;
+	}
+	return TEE_SUCCESS;
+}
+
+static TEE_Result unpack_attrs(const uint8_t *buf, size_t blen,
+			       TEE_Attribute **attrs, uint32_t *attr_count)
+{
+	TEE_Result res = TEE_SUCCESS;
+	TEE_Attribute *a = NULL;
+	const struct attr_packed *ap = NULL;
+	size_t num_attrs = 0;
+	const size_t num_attrs_size = sizeof(uint32_t);
+
+	if (blen == 0)
+		goto out;
+
+	if (((uintptr_t)buf & 0x3) != 0 || blen < num_attrs_size)
+		return TEE_ERROR_BAD_PARAMETERS;
+	num_attrs = *(uint32_t *) (void *)buf;
+	if ((blen - num_attrs_size) < (num_attrs * sizeof(*ap)))
+		return TEE_ERROR_BAD_PARAMETERS;
+	ap = (const struct attr_packed *)(const void *)(buf + num_attrs_size);
+
+	if (num_attrs > 0) {
+		size_t n;
+
+		a = malloc(num_attrs * sizeof(TEE_Attribute));
+		if (!a)
+			return TEE_ERROR_OUT_OF_MEMORY;
+		for (n = 0; n < num_attrs; n++) {
+			uintptr_t p;
+
+			a[n].attributeID = ap[n].id;
+#define TEE_ATTR_BIT_VALUE		  (1 << 29)
+			if (ap[n].id & TEE_ATTR_BIT_VALUE) {
+				a[n].content.value.a = ap[n].a;
+				a[n].content.value.b = ap[n].b;
+				continue;
+			}
+
+			a[n].content.ref.length = ap[n].b;
+			p = (uintptr_t)ap[n].a;
+			if (p) {
+				if ((p + a[n].content.ref.length) > blen) {
+					res = TEE_ERROR_BAD_PARAMETERS;
+					goto out;
+				}
+				p += (uintptr_t)buf;
+			}
+			a[n].content.ref.buffer = (void *)p;
+		}
+	}
+
+	res = TEE_SUCCESS;
+out:
+	if (res == TEE_SUCCESS) {
+		*attrs = a;
+		*attr_count = num_attrs;
+	} else {
+		free(a);
+	}
+	return res;
+}
+
+
+/**
+ * @brief   Call the Cryptographic Extension API to encapsulate
+ *          a plain key into a black key.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = Cryptographic Algorithm Id
+ *     params[0].value.b = Black key type (enum PTA_BK_TYPE)
+ *     params[1].memref  = Key to encapsulate
+ *     params[2].memref  = Output black key
+ *
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+static TEE_Result encapsulate(uint32_t param_types,
+		TEE_Param params[TEE_NUM_PARAMS])
+{
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint32_t exp_param_types;
+	struct imxcrypt_buf pk = {0};
+	struct imxcrypt_buf bk = {0};
+
+	exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+			TEE_PARAM_TYPE_MEMREF_INPUT,
+			TEE_PARAM_TYPE_MEMREF_OUTPUT,
+			TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	/* Convert the plain key to imxcrypt_buf object */
+	pk.data = params[1].memref.buffer;
+	pk.length = params[1].memref.size;
+
+	/* Convert the black key to imxcrypt_buf object */
+	bk.data = params[2].memref.buffer;
+	bk.length = params[2].memref.size;
+
+	res = bk_encapsulate(params[0].value.a, params[0].value.b, &pk, &bk);
+
+	if (res == TEE_SUCCESS)
+		params[2].memref.size = bk.length;
+
+	return res;
+}
+
+/**
+ * @brief   Call the Cryptographic Extension API to sign
+ *          data using a black key.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = Cryptographic Algorithm
+ *     params[0].value.b = Black key type (enum PTA_BK_TYPE)
+ *     params[1].memref  = Black key bytes
+ *     params[2].memref  = Input data
+ *     params[3].memref  = Output data
+ *
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+static TEE_Result sign(uint32_t param_types,
+		TEE_Param params[TEE_NUM_PARAMS])
+{
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint32_t exp_param_types;
+
+	struct imxcrypt_buf src = {0};
+	struct imxcrypt_buf dst = {0};
+	struct imxcrypt_buf *key = NULL;
+	TEE_Attribute *key_attrs = NULL;
+	uint32_t key_attr_cnt = 0;
+
+	exp_param_types = TEE_PARAM_TYPES(
+		TEE_PARAM_TYPE_VALUE_INPUT,
+		TEE_PARAM_TYPE_MEMREF_INPUT,
+		TEE_PARAM_TYPE_MEMREF_INPUT,
+		TEE_PARAM_TYPE_MEMREF_INOUT);
+
+	if (param_types != exp_param_types)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	res = unpack_attrs(params[1].memref.buffer, params[1].memref.size,
+			   &key_attrs, &key_attr_cnt);
+
+	if (res != TEE_SUCCESS)
+		return res;
+
+	key = malloc(key_attr_cnt * sizeof(struct imxcrypt_buf));
+	if (!key) {
+		res = TEE_ERROR_OUT_OF_MEMORY;
+		goto out;
+	}
+	res = imxcrypt_buf_from_attr(key, key_attrs, key_attr_cnt);
+
+	if (res != TEE_SUCCESS)
+		goto out;
+
+	/* Convert the data buffer to imxcrypt_buf object */
+	src.data = params[2].memref.buffer;
+	src.length = params[2].memref.size;
+
+	/* Convert the signature buffer to imxcrypt_buf object */
+	dst.data = params[3].memref.buffer;
+	dst.length = params[3].memref.size;
+
+	res = bk_sign(params[0].value.a, params[0].value.b,
+		key, key_attr_cnt, &src, &dst);
+
+	if (res == TEE_SUCCESS)
+		params[3].memref.size = dst.length;
+out:
+	free(key);
+	free(key_attrs);
+	return res;
+}
+
+/**
+ * @brief   Called when a pseudo TA is invoked.
+ *
+ * @param[in]  sess_ctx       Session Identifier
+ * @param[in]  cmd_id         Command ID
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+static TEE_Result invokeCommandEntryPoint(void *sess_ctx __unused,
+		uint32_t cmd_id, uint32_t param_types,
+		TEE_Param params[TEE_NUM_PARAMS])
+{
+	switch (cmd_id) {
+	case PTA_BK_CMD_ENCAPS:
+		return encapsulate(param_types, params);
+	case PTA_BK_CMD_SIGN:
+		return sign(param_types, params);
+	default:
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+}
+
+/**
+ * @brief   Open Session function verifying that only a TA opened
+ *          the current PTA
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ * @param[in]  sess_ctx       Session Identifier
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_ACCESS_DENIED     PTA access is denied
+ */
+static TEE_Result open_session(uint32_t param_types __unused,
+		TEE_Param pParams[TEE_NUM_PARAMS] __unused,
+		void **sess_ctx)
+{
+	struct tee_ta_session *sess;
+
+	/* Check if the session is opened by a TA */
+	sess = tee_ta_get_calling_session();
+	if (!sess)
+		return TEE_ERROR_ACCESS_DENIED;
+
+	*sess_ctx = (void *)(vaddr_t)sess->ctx->ops->get_instance_id(sess->ctx);
+
+	return TEE_SUCCESS;
+}
+
+pseudo_ta_register(
+		.uuid = PTA_BK_PTA_UUID,
+		.name = BK_PTA_NAME,
+		.flags = PTA_DEFAULT_FLAGS,
+		.open_session_entry_point = open_session,
+		.invoke_command_entry_point = invokeCommandEntryPoint);
+
diff --git a/core/arch/arm/plat-imx/pta/pta_blob_mx.c b/core/arch/arm/plat-imx/pta/pta_blob_mx.c
new file mode 100644
index 00000000..707eb595
--- /dev/null
+++ b/core/arch/arm/plat-imx/pta/pta_blob_mx.c
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    pta_blob_mx.c
+ *
+ * @brief   Pseudo Trusted Application.\n
+ *			Blob Encapsulation/Decapsulation functionality
+ */
+
+/* Standard includes */
+#include <stdlib.h>
+#include <string.h>
+
+/* Library kernel includes */
+#include <kernel/pseudo_ta.h>
+
+/* Library libutee includes */
+#include <pta_blob.h>
+
+/* Library tee includes */
+#include <tee_api_types.h>
+
+/* Library crypto includes */
+#include <crypto_extension.h>
+#include <libimxcrypt_blob.h>
+
+/* Library crypto includes */
+#include <crypto/crypto.h>
+
+/* Global includes */
+#include <tee_api_defines.h>
+
+/** @brief    PTA name */
+#define BLOB_PTA_NAME "blob.pta"
+
+/**
+ * @brief   Call the Crytographic Extension API to encapsulate
+ *          the given input data in the requested blob type.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = blob Type (enum PTA_BLOB_TYPE)
+ *     params[1].memref  = Key derivation of 128 bits length
+ *     params[2].memref  = Data to encapsulate
+ *
+ *    Output:
+ *     params[3].memref  = Blob resulting
+ *                         (size >= data length + 48 bytes)
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+static TEE_Result encapsulate(uint32_t param_types,
+		TEE_Param params[TEE_NUM_PARAMS])
+{
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint32_t exp_param_types;
+	struct imxcrypt_buf payload;
+	struct imxcrypt_buf blob;
+
+	exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+					TEE_PARAM_TYPE_MEMREF_INPUT,
+					TEE_PARAM_TYPE_MEMREF_INPUT,
+					TEE_PARAM_TYPE_MEMREF_OUTPUT);
+
+	if (param_types != exp_param_types)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	/* Check the Key derivation */
+	if (params[1].memref.size != BLOB_KEY_MODIFIER_SIZE)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	/* Convert the payload to imxcrypt_buf object */
+	payload.data   = params[2].memref.buffer;
+	payload.length = params[2].memref.size;
+
+	/* Convert the blob to imxcrypt_buf object */
+	blob.data   = params[3].memref.buffer;
+	blob.length = params[3].memref.size;
+
+	res = blob_encapsulate(params[0].value.a,
+			params[1].memref.buffer,
+			&payload, &blob);
+
+	if (res == TEE_SUCCESS)
+		params[3].memref.size = blob.length;
+
+	return res;
+}
+
+/**
+ * @brief   Call the Crytographic Extension API to decapsulate
+ *          the given input blob in the requested blob type.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = blob Type (enum PTA_BLOB_TYPE)
+ *     params[1].memref  = Key derivation of 128 bits length
+ *     params[2].memref  = Blob to decapsulate
+ *
+ *    Output:
+ *     params[3].memref  = Data resulting
+ *                         (size >= blob length - 48 bytes)
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+static TEE_Result decapsulate(uint32_t param_types,
+		TEE_Param params[TEE_NUM_PARAMS])
+{
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint32_t exp_param_types;
+	struct imxcrypt_buf payload;
+	struct imxcrypt_buf blob;
+
+	exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+					TEE_PARAM_TYPE_MEMREF_INPUT,
+					TEE_PARAM_TYPE_MEMREF_INPUT,
+					TEE_PARAM_TYPE_MEMREF_OUTPUT);
+
+	if (param_types != exp_param_types)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	/* Check the Key derivation */
+	if (params[1].memref.size != BLOB_KEY_MODIFIER_SIZE)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	/* Convert the payload to imxcrypt_buf object */
+	payload.data   = params[3].memref.buffer;
+	payload.length = params[3].memref.size;
+
+	/* Convert the blob to imxcrypt_buf object */
+	blob.data   = params[2].memref.buffer;
+	blob.length = params[2].memref.size;
+
+	res = blob_decapsulate(params[0].value.a,
+			params[1].memref.buffer,
+			&payload, &blob);
+
+	if (res == TEE_SUCCESS)
+		params[3].memref.size = payload.length;
+
+	return res;
+}
+
+/**
+ * @brief   Called when a pseudo TA is invoked.
+ *
+ * @param[in]  sess_ctx       Session Identifier
+ * @param[in]  cmd_id         Command ID
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+static TEE_Result invokeCommandEntryPoint(void *sess_ctx __unused,
+		uint32_t cmd_id, uint32_t param_types,
+		TEE_Param params[TEE_NUM_PARAMS])
+{
+	switch (cmd_id) {
+	case PTA_BLOB_CMD_ENCAPS:
+		return encapsulate(param_types, params);
+	case PTA_BLOB_CMD_DECAPS:
+		return decapsulate(param_types, params);
+	default:
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+}
+
+/**
+ * @brief   Open Session function verifying that only a TA opened
+ *          the current PTA
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ * @param[in]  sess_ctx       Session Identifier
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_ACCESS_DENIED     PTA access is denied
+ */
+static TEE_Result open_session(uint32_t param_types __unused,
+			TEE_Param pParams[TEE_NUM_PARAMS] __unused,
+			void **sess_ctx)
+{
+	struct tee_ta_session *sess;
+
+	/* Check if the session is opened by a TA */
+	sess = tee_ta_get_calling_session();
+	if (!sess)
+		return TEE_ERROR_ACCESS_DENIED;
+
+	*sess_ctx = (void *)(vaddr_t)sess->ctx->ops->get_instance_id(sess->ctx);
+
+	return TEE_SUCCESS;
+}
+
+pseudo_ta_register(
+		.uuid = PTA_BLOB_PTA_UUID,
+		.name = BLOB_PTA_NAME,
+		.flags = PTA_DEFAULT_FLAGS,
+		.open_session_entry_point = open_session,
+		.invoke_command_entry_point = invokeCommandEntryPoint);
diff --git a/core/arch/arm/plat-imx/pta/pta_ocotp_mx.c b/core/arch/arm/plat-imx/pta/pta_ocotp_mx.c
new file mode 100644
index 00000000..e6ca0c06
--- /dev/null
+++ b/core/arch/arm/plat-imx/pta/pta_ocotp_mx.c
@@ -0,0 +1,147 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    pta_ocotp_mx.c
+ *
+ * @brief   Pseudo Trusted Application.\n
+ *			OCOTP functionality
+ */
+
+/* Standard includes */
+#include <stdlib.h>
+#include <string.h>
+
+/* Library kernel includes */
+#include <kernel/pseudo_ta.h>
+#include <kernel/tee_common_otp.h>
+
+/* Library libutee includes */
+#include <pta_ocotp.h>
+
+/* Library tee includes */
+#include <tee_api_types.h>
+
+/* Global includes */
+#include <tee_api_defines.h>
+
+/** @brief    PTA name */
+#define OCOTP_PTA_NAME "ocotp.pta"
+
+/**
+ * @brief   Call the Cryptographic Extension API to encapsulate
+ *          a plain key into a black key.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = Cryptographic Algorithm Id
+ *     params[0].value.b = Black key type (enum PTA_BK_TYPE)
+ *     params[1].memref  = Key to encapsulate
+ *     params[2].memref  = Output black key
+ *
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+static TEE_Result chip_uid(uint32_t param_types,
+		TEE_Param params[TEE_NUM_PARAMS])
+{
+
+	uint32_t exp_param_types;
+	uint64_t die_id = 0, i, u;
+	uint8_t pdie_id[sizeof(uint64_t)] = {0};
+	uint8_t *odie_id = NULL;
+
+	exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_OUTPUT,
+			TEE_PARAM_TYPE_NONE,
+			TEE_PARAM_TYPE_NONE,
+			TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	/* Get Chip Id */
+	if (tee_otp_get_die_id((uint8_t *)&die_id, sizeof(die_id)))
+		return TEE_ERROR_GENERIC;
+
+	for (i = 0; i < sizeof(uint64_t); i++) {
+		u = die_id;
+		u = u >> (8 * i);
+		pdie_id[i] = (uint8_t)(u & 0xff);
+	}
+	/* Chip Uid is 8 bytes long, pad it to requested Chip id length */
+	odie_id = params[0].memref.buffer;
+
+	for (i = 0; i < params[0].memref.size; i++)
+		odie_id[i % sizeof(uint64_t)] = pdie_id[i];
+
+	return TEE_SUCCESS;
+}
+
+/**
+ * @brief   Called when a pseudo TA is invoked.
+ *
+ * @param[in]  sess_ctx       Session Identifier
+ * @param[in]  cmd_id         Command ID
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+static TEE_Result invokeCommandEntryPoint(void *sess_ctx __unused,
+		uint32_t cmd_id, uint32_t param_types,
+		TEE_Param params[TEE_NUM_PARAMS])
+{
+	switch (cmd_id) {
+	case PTA_OCOTP_CMD_CHIP_UID:
+		return chip_uid(param_types, params);
+	default:
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+}
+
+/**
+ * @brief   Open Session function verifying that only a TA opened
+ *          the current PTA
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ * @param[in]  sess_ctx       Session Identifier
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_ACCESS_DENIED     PTA access is denied
+ */
+static TEE_Result open_session(uint32_t param_types __unused,
+		TEE_Param pParams[TEE_NUM_PARAMS] __unused,
+		void **sess_ctx)
+{
+	struct tee_ta_session *sess;
+
+	/* Check if the session is opened by a TA */
+	sess = tee_ta_get_calling_session();
+	if (!sess)
+		return TEE_ERROR_ACCESS_DENIED;
+
+	*sess_ctx = (void *)(vaddr_t)sess->ctx->ops->get_instance_id(sess->ctx);
+
+	return TEE_SUCCESS;
+}
+
+pseudo_ta_register(
+		.uuid = PTA_OCOTP_PTA_UUID,
+		.name = OCOTP_PTA_NAME,
+		.flags = PTA_DEFAULT_FLAGS,
+		.open_session_entry_point = open_session,
+		.invoke_command_entry_point = invokeCommandEntryPoint);
diff --git a/core/arch/arm/plat-imx/pta/sub.mk b/core/arch/arm/plat-imx/pta/sub.mk
new file mode 100644
index 00000000..fc415a2d
--- /dev/null
+++ b/core/arch/arm/plat-imx/pta/sub.mk
@@ -0,0 +1,4 @@
+srcs-$(CFG_MANUFACT_PROTEC_PTA) += pta_manufact_protec_mx.c
+srcs-$(CFG_BLOB_PTA) += pta_blob_mx.c
+srcs-$(CFG_BK_PTA) += pta_bk_mx.c
+srcs-$(CFG_OCOTP_PTA) += pta_ocotp_mx.c
\ No newline at end of file
diff --git a/core/arch/arm/plat-imx/registers/ocotp-regs.h b/core/arch/arm/plat-imx/registers/ocotp-regs.h
index f2e03f46..a260c93a 100644
--- a/core/arch/arm/plat-imx/registers/ocotp-regs.h
+++ b/core/arch/arm/plat-imx/registers/ocotp-regs.h
@@ -7,10 +7,11 @@
 #define __OCOTP_REGS_H__
 
 #ifdef CFG_MX7ULP
-#define OCOTP_WAFER_NO	0x04D0
-#define OCOTP_DIE_ID	0x04E0
+#define OCOTP_WAFER_NO	0x4D0
+#define OCOTP_UID_HIGH	0x4E0
 #else
-#define OCOTP_DIE_ID	0x0420
+#define OCOTP_UID_HIGH  0x420
+#define OCOTP_UID_LOW	0x410
 #endif
 
 #endif /* __OCOTP_REGS_H__ */
diff --git a/core/arch/arm/plat-imx/sub.mk b/core/arch/arm/plat-imx/sub.mk
index 86528907..ad1a9356 100644
--- a/core/arch/arm/plat-imx/sub.mk
+++ b/core/arch/arm/plat-imx/sub.mk
@@ -29,9 +29,11 @@ srcs-$(CFG_DT) += imx_dt.c
 srcs-$(CFG_CSU) += imx_csu.c
 srcs-$(CFG_SCU) += imx_scu.c
 srcs-$(CFG_IMX_OCRAM) += imx_ocram.c
-srcs-$(CFG_MANUFACT_PROTEC_PTA) += pta/pta_manufact_protec_mx.c
 srcs-$(CFG_XRDC) += xrdc.c
 subdirs-$(CFG_PSCI_ARM32) += pm
 
 # Build the busfreq module
 subdirs-$(CFG_BUSFREQ) += busfreq
+
+# Build the imx-PTA
+subdirs-y += pta
diff --git a/core/drivers/caam/acipher/caam_prime.c b/core/drivers/caam/acipher/caam_prime.c
index 92d2bdd5..7ff658eb 100644
--- a/core/drivers/caam/acipher/caam_prime.c
+++ b/core/drivers/caam/acipher/caam_prime.c
@@ -63,15 +63,40 @@
  *          operation sqrt(2) * (2 ^ ((nlen / 2) - 1))
  *          Used at step 4.4
  */
-static const char sqrt_value[] =
-	"b504f333f9de6484597d89b3754abe9f1d6f60ba893ba84ced17ac8583339915"
-	"4afc83043ab8a2c3a8b1fe6fdc83db390f74a85e439c7b4a780487363dfa2768"
-	"d2202e8742af1f4e53059c6011bc337bcab1bc911688458a460abc722f7c4e33"
-	"c6d5a8a38bb7e9dccb2a634331f3c84df52f120f836e582eeaa4a0899040ca4a"
-	"81394ab6d8fd0efdf4d3a02cebc93e0c4264dabcd528b651b8cf341b6f8236c7"
-	"0104dc01fe32352f332a5e9f7bda1ebff6a1be3fca221307dea06241f7aa81c2"
-	"c1fcbddea2f7dc3318838a2eaff5f3b2d24f4a763facb882fdfe170fd3b1f780"
-	"f9acce41797f2805c246785e929570235fcf8f7bca3ea33b4d7c60a5e633e3e1";
+static const uint8_t sqrt_value[] = {
+			0xb5, 0x04, 0xf3, 0x33, 0xf9, 0xde, 0x64, 0x84,
+			0x59, 0x7d, 0x89, 0xb3, 0x75, 0x4a, 0xbe, 0x9f,
+			0x1d, 0x6f, 0x60, 0xba, 0x89, 0x3b, 0xa8, 0x4c,
+			0xed, 0x17, 0xac, 0x85, 0x83, 0x33, 0x99, 0x15,
+			0x4a, 0xfc, 0x83, 0x04, 0x3a, 0xb8, 0xa2, 0xc3,
+			0xa8, 0xb1, 0xfe, 0x6f, 0xdc, 0x83, 0xdb, 0x39,
+			0x0f, 0x74, 0xa8, 0x5e, 0x43, 0x9c, 0x7b, 0x4a,
+			0x78, 0x04, 0x87, 0x36, 0x3d, 0xfa, 0x27, 0x68,
+			0xd2, 0x20, 0x2e, 0x87, 0x42, 0xaf, 0x1f, 0x4e,
+			0x53, 0x05, 0x9c, 0x60, 0x11, 0xbc, 0x33, 0x7b,
+			0xca, 0xb1, 0xbc, 0x91, 0x16, 0x88, 0x45, 0x8a,
+			0x46, 0x0a, 0xbc, 0x72, 0x2f, 0x7c, 0x4e, 0x33,
+			0xc6, 0xd5, 0xa8, 0xa3, 0x8b, 0xb7, 0xe9, 0xdc,
+			0xcb, 0x2a, 0x63, 0x43, 0x31, 0xf3, 0xc8, 0x4d,
+			0xf5, 0x2f, 0x12, 0x0f, 0x83, 0x6e, 0x58, 0x2e,
+			0xea, 0xa4, 0xa0, 0x89, 0x90, 0x40, 0xca, 0x4a,
+			0x81, 0x39, 0x4a, 0xb6, 0xd8, 0xfd, 0x0e, 0xfd,
+			0xf4, 0xd3, 0xa0, 0x2c, 0xeb, 0xc9, 0x3e, 0x0c,
+			0x42, 0x64, 0xda, 0xbc, 0xd5, 0x28, 0xb6, 0x51,
+			0xb8, 0xcf, 0x34, 0x1b, 0x6f, 0x82, 0x36, 0xc7,
+			0x01, 0x04, 0xdc, 0x01, 0xfe, 0x32, 0x35, 0x2f,
+			0x33, 0x2a, 0x5e, 0x9f, 0x7b, 0xda, 0x1e, 0xbf,
+			0xf6, 0xa1, 0xbe, 0x3f, 0xca, 0x22, 0x13, 0x07,
+			0xde, 0xa0, 0x62, 0x41, 0xf7, 0xaa, 0x81, 0xc2,
+			0xc1, 0xfc, 0xbd, 0xde, 0xa2, 0xf7, 0xdc, 0x33,
+			0x18, 0x83, 0x8a, 0x2e, 0xaf, 0xf5, 0xf3, 0xb2,
+			0xd2, 0x4f, 0x4a, 0x76, 0x3f, 0xac, 0xb8, 0x82,
+			0xfd, 0xfe, 0x17, 0x0f, 0xd3, 0xb1, 0xf7, 0x80,
+			0xf9, 0xac, 0xce, 0x41, 0x79, 0x7f, 0x28, 0x05,
+			0xc2, 0x46, 0x78, 0x5e, 0x92, 0x95, 0x70, 0x23,
+			0x5f, 0xcf, 0x8f, 0x7b, 0xca, 0x3e, 0xa3, 0x3b,
+			0x4d, 0x7c, 0x60, 0xa5, 0xe6, 0x33, 0xe3, 0xe1
+		};
 
 /**
  * @brief   Speedups for prime searching
@@ -100,86 +125,334 @@ static const char sqrt_value[] =
  * stats for percentage of candidates that might be weeded out?  If not many,
  * then there is an extra computation.
  */
-static const char * const smallprimes[] = {
+struct smallprime {
+	const size_t length;
+	const uint8_t *data;
+};
+static const struct smallprime smallprimes[] = {
 	/*     sizes     | #primes | highest prime | %weeded */
 	/*  bits / bytes |         |                         */
 	/*    64 / 8     |   15    |          53   |    72   */
-	"e221f97c30e94e1d",
+	{
+		.data = (uint8_t []) { 
+			0xe2, 0x21, 0xf9, 0x7c, 0x30, 0xe9, 0x4e, 0x1d
+		},
+		.length = 8
+	},
 	/*   128 / 16    |   25    |          101  |    76   */
-	"5797d47c51681549d734e4fc4c3eaf7f",
+	{
+		.data = (uint8_t []) { 
+			0x57, 0x97, 0xd4, 0x7c, 0x51, 0x68, 0x15, 0x49,
+			0xd7, 0x34, 0xe4, 0xfc, 0x4c, 0x3e, 0xaf, 0x7f
+		},
+		.length = 16
+	},
 	/*   256 / 32    |   43    |          193  |    79   */
-	"dbf05b6f5654b3c0f5243551439586889f155887819aed2ac05b93352be98677",
+	{
+		.data = (uint8_t []) { 
+			0xdb, 0xf0, 0x5b, 0x6f, 0x56, 0x54, 0xb3, 0xc0,
+			0xf5, 0x24, 0x35, 0x51, 0x43, 0x95, 0x86, 0x88,
+			0x9f, 0x15, 0x58, 0x87, 0x81, 0x9a, 0xed, 0x2a,
+			0xc0, 0x5b, 0x93, 0x35, 0x2b, 0xe9, 0x86, 0x77
+		},
+		.length = 32
+	},
 	/*   384 / 48    |   59    |          281  |    80   */
-	"501201cc51a492a544d3900ad4f8b32a203c858406a4457cab0b4f805ab18ac6"
-	"eb9572ac6e9394fa522bffb6f44af2f3",
+	{
+		.data = (uint8_t []) { 
+			0x50, 0x12, 0x01, 0xcc, 0x51, 0xa4, 0x92, 0xa5,
+			0x44, 0xd3, 0x90, 0x0a, 0xd4, 0xf8, 0xb3, 0x2a,
+			0x20, 0x3c, 0x85, 0x84, 0x06, 0xa4, 0x45, 0x7c,
+			0xab, 0x0b, 0x4f, 0x80, 0x5a, 0xb1, 0x8a, 0xc6,
+			0xeb, 0x95, 0x72, 0xac, 0x6e, 0x93, 0x94, 0xfa,
+			0x52, 0x2b, 0xff, 0xb6, 0xf4, 0x4a, 0xf2, 0xf3
+		},
+		.length = 48
+	},
 	/*   512 / 64    |   74    |          379  |    81   */
-	"106aa9fb7646fa6eb0813c28c5d5f09f077ec3ba238bfb99c1b631a203e81187"
-	"233db117cbc384056ef04659a4a11de49f7ecb29bada8f980decece92e30c48f",
+	{
+		.data = (uint8_t []) { 
+			0x10, 0x6a, 0xa9, 0xfb, 0x76, 0x46, 0xfa, 0x6e,
+			0xb0, 0x81, 0x3c, 0x28, 0xc5, 0xd5, 0xf0, 0x9f,
+			0x07, 0x7e, 0xc3, 0xba, 0x23, 0x8b, 0xfb, 0x99,
+			0xc1, 0xb6, 0x31, 0xa2, 0x03, 0xe8, 0x11, 0x87,
+			0x23, 0x3d, 0xb1, 0x17, 0xcb, 0xc3, 0x84, 0x05,
+			0x6e, 0xf0, 0x46, 0x59, 0xa4, 0xa1, 0x1d, 0xe4,
+			0x9f, 0x7e, 0xcb, 0x29, 0xba, 0xda, 0x8f, 0x98,
+			0x0d, 0xec, 0xec, 0xe9, 0x2e, 0x30, 0xc4, 0x8f
+		},
+		.length = 64
+	},
 	/*   576 / 72    |   81    |          421  |    82   */
-	"0185dbeb2b8b11d37633e9dc1eec541565c6ce8431d227ee28f0328a60c90118"
-	"ae031cc5a781c824d1f16d25f4f0cccff35e974579072ec8caf1ac8eefd5566f"
-	"a15fb94fe34f5d37",
+	{
+		.data = (uint8_t []) { 
+			0x01, 0x85, 0xdb, 0xeb, 0x2b, 0x8b, 0x11, 0xd3,
+			0x76, 0x33, 0xe9, 0xdc, 0x1e, 0xec, 0x54, 0x15,
+			0x65, 0xc6, 0xce, 0x84, 0x31, 0xd2, 0x27, 0xee,
+			0x28, 0xf0, 0x32, 0x8a, 0x60, 0xc9, 0x01, 0x18,
+			0xae, 0x03, 0x1c, 0xc5, 0xa7, 0x81, 0xc8, 0x24,
+			0xd1, 0xf1, 0x6d, 0x25, 0xf4, 0xf0, 0xcc, 0xcf,
+			0xf3, 0x5e, 0x97, 0x45, 0x79, 0x07, 0x2e, 0xc8,
+			0xca, 0xf1, 0xac, 0x8e, 0xef, 0xd5, 0x56, 0x6f,
+			0xa1, 0x5f, 0xb9, 0x4f, 0xe3, 0x4f, 0x5d, 0x37
+		},
+		.length = 72
+	},
 	/*   768 / 96    |  103    |          569  |    82   */
-	"25eac89f8d4da338337b49850d2d14892663177b4010af3dd23eeb0b228f3832"
-	"ffcee2e5cbd1acc98f47f251873380ae10f0ffdd8e602ffa210f41f669a1570a"
-	"93c158c1a9a8227ff81a90c5630e9c44845c755c7df35a7d430c679a11575655",
+	{
+		.data = (uint8_t []) { 
+			0x25, 0xea, 0xc8, 0x9f, 0x8d, 0x4d, 0xa3, 0x38,
+			0x33, 0x7b, 0x49, 0x85, 0x0d, 0x2d, 0x14, 0x89,
+			0x26, 0x63, 0x17, 0x7b, 0x40, 0x10, 0xaf, 0x3d,
+			0xd2, 0x3e, 0xeb, 0x0b, 0x22, 0x8f, 0x38, 0x32,
+			0xff, 0xce, 0xe2, 0xe5, 0xcb, 0xd1, 0xac, 0xc9,
+			0x8f, 0x47, 0xf2, 0x51, 0x87, 0x33, 0x80, 0xae,
+			0x10, 0xf0, 0xff, 0xdd, 0x8e, 0x60, 0x2f, 0xfa,
+			0x21, 0x0f, 0x41, 0xf6, 0x69, 0xa1, 0x57, 0x0a,
+			0x93, 0xc1, 0x58, 0xc1, 0xa9, 0xa8, 0x22, 0x7f,
+			0xf8, 0x1a, 0x90, 0xc5, 0x63, 0x0e, 0x9c, 0x44,
+			0x84, 0x5c, 0x75, 0x5c, 0x7d, 0xf3, 0x5a, 0x7d,
+			0x43, 0x0c, 0x67, 0x9a, 0x11, 0x57, 0x56, 0x55,
+		},
+		.length = 96
+	},
 	/*  1024 / 128   |  130    |          739  |    83   */
-	"02c85ff870f24be80f62b1ba6c20bd72b837efdf121206d87db56b7d69fa4c02"
-	"1c107c3ca206fe8fa7080ef576effc82f9b10f5750656b7794b16afd70996e91"
-	"aef6e0ad15e91b071ac9b24d98b233ad86ee055518e58e56638ef18bac5c74cb"
-	"35bbb6e5dae2783dd1c0ce7dec4fc70e5186d411df36368f061aa36011f30179",
+	{
+		.data = (uint8_t []) {
+			0x02, 0xc8, 0x5f, 0xf8, 0x70, 0xf2, 0x4b, 0xe8,
+			0x0f, 0x62, 0xb1, 0xba, 0x6c, 0x20, 0xbd, 0x72,
+			0xb8, 0x37, 0xef, 0xdf, 0x12, 0x12, 0x06, 0xd8,
+			0x7d, 0xb5, 0x6b, 0x7d, 0x69, 0xfa, 0x4c, 0x02,
+			0x1c, 0x10, 0x7c, 0x3c, 0xa2, 0x06, 0xfe, 0x8f,
+			0xa7, 0x08, 0x0e, 0xf5, 0x76, 0xef, 0xfc, 0x82,
+			0xf9, 0xb1, 0x0f, 0x57, 0x50, 0x65, 0x6b, 0x77,
+			0x94, 0xb1, 0x6a, 0xfd, 0x70, 0x99, 0x6e, 0x91,
+			0xae, 0xf6, 0xe0, 0xad, 0x15, 0xe9, 0x1b, 0x07,
+			0x1a, 0xc9, 0xb2, 0x4d, 0x98, 0xb2, 0x33, 0xad,
+			0x86, 0xee, 0x05, 0x55, 0x18, 0xe5, 0x8e, 0x56,
+			0x63, 0x8e, 0xf1, 0x8b, 0xac, 0x5c, 0x74, 0xcb,
+			0x35, 0xbb, 0xb6, 0xe5, 0xda, 0xe2, 0x78, 0x3d,
+			0xd1, 0xc0, 0xce, 0x7d, 0xec, 0x4f, 0xc7, 0x0e,
+			0x51, 0x86, 0xd4, 0x11, 0xdf, 0x36, 0x36, 0x8f,
+			0x06, 0x1a, 0xa3, 0x60, 0x11, 0xf3, 0x01, 0x79,
+		},
+		.length = 128
+	},
 	/*  1088 / 184   |  136    |          787  |    83   */
-	"16af5c18a2bef8eff2278332182d0fbf0038cc205148b83d06e3d7d932828b18"
-	"e11e094028c7eaeda3395017e07d8ae9b594060451d05f93084cb481663c94c6"
-	"ff980ddeccdb42ad37097f41a7837fc95afe3f18ad76f23483ae942e0f0c0bc6"
-	"e40016123189872be58f6dfc239ca28fb0cfbf964c8f27ce05d6c77a01f9d332"
-	"36c9d442ad69ed33",
+	{
+		.data = (uint8_t []) { 
+			0x16, 0xaf, 0x5c, 0x18, 0xa2, 0xbe, 0xf8, 0xef,
+			0xf2, 0x27, 0x83, 0x32, 0x18, 0x2d, 0x0f, 0xbf,
+			0x00, 0x38, 0xcc, 0x20, 0x51, 0x48, 0xb8, 0x3d,
+			0x06, 0xe3, 0xd7, 0xd9, 0x32, 0x82, 0x8b, 0x18,
+			0xe1, 0x1e, 0x09, 0x40, 0x28, 0xc7, 0xea, 0xed,
+			0xa3, 0x39, 0x50, 0x17, 0xe0, 0x7d, 0x8a, 0xe9,
+			0xb5, 0x94, 0x06, 0x04, 0x51, 0xd0, 0x5f, 0x93,
+			0x08, 0x4c, 0xb4, 0x81, 0x66, 0x3c, 0x94, 0xc6,
+			0xff, 0x98, 0x0d, 0xde, 0xcc, 0xdb, 0x42, 0xad,
+			0x37, 0x09, 0x7f, 0x41, 0xa7, 0x83, 0x7f, 0xc9,
+			0x5a, 0xfe, 0x3f, 0x18, 0xad, 0x76, 0xf2, 0x34,
+			0x83, 0xae, 0x94, 0x2e, 0x0f, 0x0c, 0x0b, 0xc6,
+			0xe4, 0x00, 0x16, 0x12, 0x31, 0x89, 0x87, 0x2b,
+			0xe5, 0x8f, 0x6d, 0xfc, 0x23, 0x9c, 0xa2, 0x8f,
+			0xb0, 0xcf, 0xbf, 0x96, 0x4c, 0x8f, 0x27, 0xce,
+			0x05, 0xd6, 0xc7, 0x7a, 0x01, 0xf9, 0xd3, 0x32,
+			0x36, 0xc9, 0xd4, 0x42, 0xad, 0x69, 0xed, 0x33
+		},
+		.length = 184
+	},
 	/*  1536 / 192   |  182    |         1093  |    84   */
-	"021bf9497091b8c368cc7c8e00c1990c6027481b79215ac8a7517749a2151377"
-	"9a993d2958fcb49a7368029268527994c6cc1928add4129596765f4cc3141a04"
-	"4eb1d6157888166757d8618781813062032267987df0d4719cd38f1b7085fca5"
-	"334be3a6003a3ce7e19aba553e80cc5ae4060eff6e1806661da5eeb7d142d3b2"
-	"e40739f1443dee3a198637f03c062845eaff3ff27ea38d9344d8a90222472df0"
-	"7dfb5c9c8ada77cd0d5b94eff021e02e307d08010312d57cb5d975764697842d",
+	{
+		.data = (uint8_t []) {
+			0x02, 0x1b, 0xf9, 0x49, 0x70, 0x91, 0xb8, 0xc3,
+			0x68, 0xcc, 0x7c, 0x8e, 0x00, 0xc1, 0x99, 0x0c,
+			0x60, 0x27, 0x48, 0x1b, 0x79, 0x21, 0x5a, 0xc8,
+			0xa7, 0x51, 0x77, 0x49, 0xa2, 0x15, 0x13, 0x77,
+			0x9a, 0x99, 0x3d, 0x29, 0x58, 0xfc, 0xb4, 0x9a,
+			0x73, 0x68, 0x02, 0x92, 0x68, 0x52, 0x79, 0x94,
+			0xc6, 0xcc, 0x19, 0x28, 0xad, 0xd4, 0x12, 0x95,
+			0x96, 0x76, 0x5f, 0x4c, 0xc3, 0x14, 0x1a, 0x04,
+			0x4e, 0xb1, 0xd6, 0x15, 0x78, 0x88, 0x16, 0x67,
+			0x57, 0xd8, 0x61, 0x87, 0x81, 0x81, 0x30, 0x62,
+			0x03, 0x22, 0x67, 0x98, 0x7d, 0xf0, 0xd4, 0x71,
+			0x9c, 0xd3, 0x8f, 0x1b, 0x70, 0x85, 0xfc, 0xa5,
+			0x33, 0x4b, 0xe3, 0xa6, 0x00, 0x3a, 0x3c, 0xe7,
+			0xe1, 0x9a, 0xba, 0x55, 0x3e, 0x80, 0xcc, 0x5a,
+			0xe4, 0x06, 0x0e, 0xff, 0x6e, 0x18, 0x06, 0x66,
+			0x1d, 0xa5, 0xee, 0xb7, 0xd1, 0x42, 0xd3, 0xb2,
+			0xe4, 0x07, 0x39, 0xf1, 0x44, 0x3d, 0xee, 0x3a,
+			0x19, 0x86, 0x37, 0xf0, 0x3c, 0x06, 0x28, 0x45,
+			0xea, 0xff, 0x3f, 0xf2, 0x7e, 0xa3, 0x8d, 0x93,
+			0x44, 0xd8, 0xa9, 0x02, 0x22, 0x47, 0x2d, 0xf0,
+			0x7d, 0xfb, 0x5c, 0x9c, 0x8a, 0xda, 0x77, 0xcd,
+			0x0d, 0x5b, 0x94, 0xef, 0xf0, 0x21, 0xe0, 0x2e,
+			0x30, 0x7d, 0x08, 0x01, 0x03, 0x12, 0xd5, 0x7c,
+			0xb5, 0xd9, 0x75, 0x76, 0x46, 0x97, 0x84, 0x2d
+		},
+		.length = 192
+	},
 	/*  2048 / 256   |  232    |         1471  |    85   */
-	"2465a7bd85011e1c9e0527929fff268c82ef7efa416863baa5acdb0971dba0cc"
-	"ac3ee4999345029f2cf810b99e406aac5fce5dd69d1c717daea5d18ab913f456"
-	"505679bc91c57d46d9888857862b36e2ede2e473c1f0ab359da25271affe15ff"
-	"240e299d0b04f4cd0e4d7c0e47b1a7ba007de89aae848fd5bdcd7f9815564eb0"
-	"60ae14f19cb50c291f0bbd8ed1c4c7f8fc5fba51662001939b532d92dac844a8"
-	"431d400c832d039f5f900b278a75219c2986140c79045d7759540854c31504dc"
-	"56f1df5eebe7bee447658b917bf696d6927f2e2428fbeb340e515cb9835d6387"
-	"1be8bbe09cf13445799f2e67788151571a93b4c1eee55d1b9072e0b2f5c4607f",
+	{
+		.data = (uint8_t []) { 
+			0x24, 0x65, 0xa7, 0xbd, 0x85, 0x01, 0x1e, 0x1c,
+			0x9e, 0x05, 0x27, 0x92, 0x9f, 0xff, 0x26, 0x8c,
+			0x82, 0xef, 0x7e, 0xfa, 0x41, 0x68, 0x63, 0xba,
+			0xa5, 0xac, 0xdb, 0x09, 0x71, 0xdb, 0xa0, 0xcc,
+			0xac, 0x3e, 0xe4, 0x99, 0x93, 0x45, 0x02, 0x9f,
+			0x2c, 0xf8, 0x10, 0xb9, 0x9e, 0x40, 0x6a, 0xac,
+			0x5f, 0xce, 0x5d, 0xd6, 0x9d, 0x1c, 0x71, 0x7d,
+			0xae, 0xa5, 0xd1, 0x8a, 0xb9, 0x13, 0xf4, 0x56,
+			0x50, 0x56, 0x79, 0xbc, 0x91, 0xc5, 0x7d, 0x46,
+			0xd9, 0x88, 0x88, 0x57, 0x86, 0x2b, 0x36, 0xe2,
+			0xed, 0xe2, 0xe4, 0x73, 0xc1, 0xf0, 0xab, 0x35,
+			0x9d, 0xa2, 0x52, 0x71, 0xaf, 0xfe, 0x15, 0xff,
+			0x24, 0x0e, 0x29, 0x9d, 0x0b, 0x04, 0xf4, 0xcd,
+			0x0e, 0x4d, 0x7c, 0x0e, 0x47, 0xb1, 0xa7, 0xba,
+			0x00, 0x7d, 0xe8, 0x9a, 0xae, 0x84, 0x8f, 0xd5,
+			0xbd, 0xcd, 0x7f, 0x98, 0x15, 0x56, 0x4e, 0xb0,
+			0x60, 0xae, 0x14, 0xf1, 0x9c, 0xb5, 0x0c, 0x29,
+			0x1f, 0x0b, 0xbd, 0x8e, 0xd1, 0xc4, 0xc7, 0xf8,
+			0xfc, 0x5f, 0xba, 0x51, 0x66, 0x20, 0x01, 0x93,
+			0x9b, 0x53, 0x2d, 0x92, 0xda, 0xc8, 0x44, 0xa8,
+			0x43, 0x1d, 0x40, 0x0c, 0x83, 0x2d, 0x03, 0x9f,
+			0x5f, 0x90, 0x0b, 0x27, 0x8a, 0x75, 0x21, 0x9c,
+			0x29, 0x86, 0x14, 0x0c, 0x79, 0x04, 0x5d, 0x77,
+			0x59, 0x54, 0x08, 0x54, 0xc3, 0x15, 0x04, 0xdc,
+			0x56, 0xf1, 0xdf, 0x5e, 0xeb, 0xe7, 0xbe, 0xe4,
+			0x47, 0x65, 0x8b, 0x91, 0x7b, 0xf6, 0x96, 0xd6,
+			0x92, 0x7f, 0x2e, 0x24, 0x28, 0xfb, 0xeb, 0x34,
+			0x0e, 0x51, 0x5c, 0xb9, 0x83, 0x5d, 0x63, 0x87,
+			0x1b, 0xe8, 0xbb, 0xe0, 0x9c, 0xf1, 0x34, 0x45,
+			0x79, 0x9f, 0x2e, 0x67, 0x78, 0x81, 0x51, 0x57,
+			0x1a, 0x93, 0xb4, 0xc1, 0xee, 0xe5, 0x5d, 0x1b,
+			0x90, 0x72, 0xe0, 0xb2, 0xf5, 0xc4, 0x60, 0x7f
+		},
+		.length = 256
+	},
 	/*  3072 / 384   | 326     |          2179  |    85   */
-	"004dc20e27315123fdabcd18ca812ee0ee44492387389ed6c91697958965edc5"
-	"3d8913a8e6ec7f836a8bd6037e57ed0c6930ef26490dc35d05d098a466adf817"
-	"9f829969d139558f16e98b3f76fc9062c15725ce0988faedca966a6b925f9b9c"
-	"670343ea7e842065bd26f2bf29904fa7f49f334928963373ba089596513daca7"
-	"3928cf305adf8c246e1d99a242d9235623c49af2914506c911215e1e49af8480"
-	"3ed9a2ca0551721fe6319bf238c08aae6fd5015403d9e55509ee31c96012f908"
-	"35185f31cbd2e489833c1d5462fa80535904867b2c945e9a0c2f7aa36e0ac0eb"
-	"9bb4c11bf580cf0d6d2a49ed1a2d74cae0f4c3adff61d648ca6a120858f4abb3"
-	"b31207cf9b7c2fda74f7722b149917875aac9d6153c97113fcd374af93dd3fa2"
-	"1a7de51f1a70c631ba6c92261e89541aa47141f44e075a1c522ae58160dac870"
-	"dfbd8606e4eca0892ae51c8734f5b7712bcd3de3325ec25f07d4ef943394d5e7"
-	"b3841005a3bd1a3e4d27061d54d2445824f85117d0f6971284a8c97a4250b99b",
+	{
+		.data = (uint8_t []) {
+			0x00, 0x4d, 0xc2, 0x0e, 0x27, 0x31, 0x51, 0x23,
+			0xfd, 0xab, 0xcd, 0x18, 0xca, 0x81, 0x2e, 0xe0,
+			0xee, 0x44, 0x49, 0x23, 0x87, 0x38, 0x9e, 0xd6,
+			0xc9, 0x16, 0x97, 0x95, 0x89, 0x65, 0xed, 0xc5,
+			0x3d, 0x89, 0x13, 0xa8, 0xe6, 0xec, 0x7f, 0x83,
+			0x6a, 0x8b, 0xd6, 0x03, 0x7e, 0x57, 0xed, 0x0c,
+			0x69, 0x30, 0xef, 0x26, 0x49, 0x0d, 0xc3, 0x5d,
+			0x05, 0xd0, 0x98, 0xa4, 0x66, 0xad, 0xf8, 0x17,
+			0x9f, 0x82, 0x99, 0x69, 0xd1, 0x39, 0x55, 0x8f,
+			0x16, 0xe9, 0x8b, 0x3f, 0x76, 0xfc, 0x90, 0x62,
+			0xc1, 0x57, 0x25, 0xce, 0x09, 0x88, 0xfa, 0xed,
+			0xca, 0x96, 0x6a, 0x6b, 0x92, 0x5f, 0x9b, 0x9c,
+			0x67, 0x03, 0x43, 0xea, 0x7e, 0x84, 0x20, 0x65,
+			0xbd, 0x26, 0xf2, 0xbf, 0x29, 0x90, 0x4f, 0xa7,
+			0xf4, 0x9f, 0x33, 0x49, 0x28, 0x96, 0x33, 0x73,
+			0xba, 0x08, 0x95, 0x96, 0x51, 0x3d, 0xac, 0xa7,
+			0x39, 0x28, 0xcf, 0x30, 0x5a, 0xdf, 0x8c, 0x24,
+			0x6e, 0x1d, 0x99, 0xa2, 0x42, 0xd9, 0x23, 0x56,
+			0x23, 0xc4, 0x9a, 0xf2, 0x91, 0x45, 0x06, 0xc9,
+			0x11, 0x21, 0x5e, 0x1e, 0x49, 0xaf, 0x84, 0x80,
+			0x3e, 0xd9, 0xa2, 0xca, 0x05, 0x51, 0x72, 0x1f,
+			0xe6, 0x31, 0x9b, 0xf2, 0x38, 0xc0, 0x8a, 0xae,
+			0x6f, 0xd5, 0x01, 0x54, 0x03, 0xd9, 0xe5, 0x55,
+			0x09, 0xee, 0x31, 0xc9, 0x60, 0x12, 0xf9, 0x08,
+			0x35, 0x18, 0x5f, 0x31, 0xcb, 0xd2, 0xe4, 0x89,
+			0x83, 0x3c, 0x1d, 0x54, 0x62, 0xfa, 0x80, 0x53,
+			0x59, 0x04, 0x86, 0x7b, 0x2c, 0x94, 0x5e, 0x9a,
+			0x0c, 0x2f, 0x7a, 0xa3, 0x6e, 0x0a, 0xc0, 0xeb,
+			0x9b, 0xb4, 0xc1, 0x1b, 0xf5, 0x80, 0xcf, 0x0d,
+			0x6d, 0x2a, 0x49, 0xed, 0x1a, 0x2d, 0x74, 0xca,
+			0xe0, 0xf4, 0xc3, 0xad, 0xff, 0x61, 0xd6, 0x48,
+			0xca, 0x6a, 0x12, 0x08, 0x58, 0xf4, 0xab, 0xb3,
+			0xb3, 0x12, 0x07, 0xcf, 0x9b, 0x7c, 0x2f, 0xda,
+			0x74, 0xf7, 0x72, 0x2b, 0x14, 0x99, 0x17, 0x87,
+			0x5a, 0xac, 0x9d, 0x61, 0x53, 0xc9, 0x71, 0x13,
+			0xfc, 0xd3, 0x74, 0xaf, 0x93, 0xdd, 0x3f, 0xa2,
+			0x1a, 0x7d, 0xe5, 0x1f, 0x1a, 0x70, 0xc6, 0x31,
+			0xba, 0x6c, 0x92, 0x26, 0x1e, 0x89, 0x54, 0x1a,
+			0xa4, 0x71, 0x41, 0xf4, 0x4e, 0x07, 0x5a, 0x1c,
+			0x52, 0x2a, 0xe5, 0x81, 0x60, 0xda, 0xc8, 0x70,
+			0xdf, 0xbd, 0x86, 0x06, 0xe4, 0xec, 0xa0, 0x89,
+			0x2a, 0xe5, 0x1c, 0x87, 0x34, 0xf5, 0xb7, 0x71,
+			0x2b, 0xcd, 0x3d, 0xe3, 0x32, 0x5e, 0xc2, 0x5f,
+			0x07, 0xd4, 0xef, 0x94, 0x33, 0x94, 0xd5, 0xe7,
+			0xb3, 0x84, 0x10, 0x05, 0xa3, 0xbd, 0x1a, 0x3e,
+			0x4d, 0x27, 0x06, 0x1d, 0x54, 0xd2, 0x44, 0x58,
+			0x24, 0xf8, 0x51, 0x17, 0xd0, 0xf6, 0x97, 0x12,
+			0x84, 0xa8, 0xc9, 0x7a, 0x42, 0x50, 0xb9, 0x9b
+		},
+		.length = 384
+	},
 	/*  4096 / 512   | 417     |          2887  |    86   */
-	"096207fccb19d6758e374bee6c3709af0a54a982bf9014e450b7481813b7305b"
-	"4c25f0e2ea6e2b56f91e5992142d216eaeb2ece005fa0d18efeb78efc341f31f"
-	"783ee44ac5ef5dfe355791282106156c64d167a5421cfec33cbbd388380be854"
-	"149fb65c08e79cd04ec48b45628ee67f5c6fb01818fa1ff732240c0bb1c7fec1"
-	"4c48234c6fc3e075764f63c0268361831d8960f24b237e96c2caba4c1a2123ff"
-	"33a49bca3949e8abadde06dac5703d16db7677df2b0ce2c78485ebd5e69bd80a"
-	"1848a9fe289ca2ba664a687b3f0540156e67ae6769c09e11ce567357f5a576a4"
-	"8eedd96335e62877c73a65408b71484ed0f11d20d51e8e5467a1e4c09bf729ba"
-	"169fcfdba8b55c4c5b682faa28719b9f49bf362d9f03ee6bde7901e940e249b4"
-	"1c93b9ab054abcab109af12aa6535ed8f623abfd312aaa084a748f865383bce3"
-	"15dc0d45cb89508deca93bda22f0e77a4feaa2a790e00e5ada9bbb9ae7d5fb63"
-	"54a252da7dc26e6ac2d7a642eabf4812e64ae195bf29cc9ee02584b774dcb112"
-	"9157bf52438fb7b7cd6a7824a7418bcc6583058ec2f06928e442623798b503f6"
-	"751dcee2c01f39acb0fb478f6e8b16a30fe8219b8e6704c726b603e10009f677"
-	"76465141570d4b4c2a30db84026f934b81f0d5e985c975d6a9075a41d417c6d9"
-	"93cb4973cbe512a67db31f6aec8cc3e9e5ebdc1eb7b474545152a156d5ac587d"
+	{
+		.data = (uint8_t []) { 
+			0x09, 0x62, 0x07, 0xfc, 0xcb, 0x19, 0xd6, 0x75,
+			0x8e, 0x37, 0x4b, 0xee, 0x6c, 0x37, 0x09, 0xaf,
+			0x0a, 0x54, 0xa9, 0x82, 0xbf, 0x90, 0x14, 0xe4,
+			0x50, 0xb7, 0x48, 0x18, 0x13, 0xb7, 0x30, 0x5b,
+			0x4c, 0x25, 0xf0, 0xe2, 0xea, 0x6e, 0x2b, 0x56,
+			0xf9, 0x1e, 0x59, 0x92, 0x14, 0x2d, 0x21, 0x6e,
+			0xae, 0xb2, 0xec, 0xe0, 0x05, 0xfa, 0x0d, 0x18,
+			0xef, 0xeb, 0x78, 0xef, 0xc3, 0x41, 0xf3, 0x1f,
+			0x78, 0x3e, 0xe4, 0x4a, 0xc5, 0xef, 0x5d, 0xfe,
+			0x35, 0x57, 0x91, 0x28, 0x21, 0x06, 0x15, 0x6c,
+			0x64, 0xd1, 0x67, 0xa5, 0x42, 0x1c, 0xfe, 0xc3,
+			0x3c, 0xbb, 0xd3, 0x88, 0x38, 0x0b, 0xe8, 0x54,
+			0x14, 0x9f, 0xb6, 0x5c, 0x08, 0xe7, 0x9c, 0xd0,
+			0x4e, 0xc4, 0x8b, 0x45, 0x62, 0x8e, 0xe6, 0x7f,
+			0x5c, 0x6f, 0xb0, 0x18, 0x18, 0xfa, 0x1f, 0xf7,
+			0x32, 0x24, 0x0c, 0x0b, 0xb1, 0xc7, 0xfe, 0xc1,
+			0x4c, 0x48, 0x23, 0x4c, 0x6f, 0xc3, 0xe0, 0x75,
+			0x76, 0x4f, 0x63, 0xc0, 0x26, 0x83, 0x61, 0x83,
+			0x1d, 0x89, 0x60, 0xf2, 0x4b, 0x23, 0x7e, 0x96,
+			0xc2, 0xca, 0xba, 0x4c, 0x1a, 0x21, 0x23, 0xff,
+			0x33, 0xa4, 0x9b, 0xca, 0x39, 0x49, 0xe8, 0xab,
+			0xad, 0xde, 0x06, 0xda, 0xc5, 0x70, 0x3d, 0x16,
+			0xdb, 0x76, 0x77, 0xdf, 0x2b, 0x0c, 0xe2, 0xc7,
+			0x84, 0x85, 0xeb, 0xd5, 0xe6, 0x9b, 0xd8, 0x0a,
+			0x18, 0x48, 0xa9, 0xfe, 0x28, 0x9c, 0xa2, 0xba,
+			0x66, 0x4a, 0x68, 0x7b, 0x3f, 0x05, 0x40, 0x15,
+			0x6e, 0x67, 0xae, 0x67, 0x69, 0xc0, 0x9e, 0x11,
+			0xce, 0x56, 0x73, 0x57, 0xf5, 0xa5, 0x76, 0xa4,
+			0x8e, 0xed, 0xd9, 0x63, 0x35, 0xe6, 0x28, 0x77,
+			0xc7, 0x3a, 0x65, 0x40, 0x8b, 0x71, 0x48, 0x4e,
+			0xd0, 0xf1, 0x1d, 0x20, 0xd5, 0x1e, 0x8e, 0x54,
+			0x67, 0xa1, 0xe4, 0xc0, 0x9b, 0xf7, 0x29, 0xba,
+			0x16, 0x9f, 0xcf, 0xdb, 0xa8, 0xb5, 0x5c, 0x4c,
+			0x5b, 0x68, 0x2f, 0xaa, 0x28, 0x71, 0x9b, 0x9f,
+			0x49, 0xbf, 0x36, 0x2d, 0x9f, 0x03, 0xee, 0x6b,
+			0xde, 0x79, 0x01, 0xe9, 0x40, 0xe2, 0x49, 0xb4,
+			0x1c, 0x93, 0xb9, 0xab, 0x05, 0x4a, 0xbc, 0xab,
+			0x10, 0x9a, 0xf1, 0x2a, 0xa6, 0x53, 0x5e, 0xd8,
+			0xf6, 0x23, 0xab, 0xfd, 0x31, 0x2a, 0xaa, 0x08,
+			0x4a, 0x74, 0x8f, 0x86, 0x53, 0x83, 0xbc, 0xe3,
+			0x15, 0xdc, 0x0d, 0x45, 0xcb, 0x89, 0x50, 0x8d,
+			0xec, 0xa9, 0x3b, 0xda, 0x22, 0xf0, 0xe7, 0x7a,
+			0x4f, 0xea, 0xa2, 0xa7, 0x90, 0xe0, 0x0e, 0x5a,
+			0xda, 0x9b, 0xbb, 0x9a, 0xe7, 0xd5, 0xfb, 0x63,
+			0x54, 0xa2, 0x52, 0xda, 0x7d, 0xc2, 0x6e, 0x6a,
+			0xc2, 0xd7, 0xa6, 0x42, 0xea, 0xbf, 0x48, 0x12,
+			0xe6, 0x4a, 0xe1, 0x95, 0xbf, 0x29, 0xcc, 0x9e,
+			0xe0, 0x25, 0x84, 0xb7, 0x74, 0xdc, 0xb1, 0x12,
+			0x91, 0x57, 0xbf, 0x52, 0x43, 0x8f, 0xb7, 0xb7,
+			0xcd, 0x6a, 0x78, 0x24, 0xa7, 0x41, 0x8b, 0xcc,
+			0x65, 0x83, 0x05, 0x8e, 0xc2, 0xf0, 0x69, 0x28,
+			0xe4, 0x42, 0x62, 0x37, 0x98, 0xb5, 0x03, 0xf6,
+			0x75, 0x1d, 0xce, 0xe2, 0xc0, 0x1f, 0x39, 0xac,
+			0xb0, 0xfb, 0x47, 0x8f, 0x6e, 0x8b, 0x16, 0xa3,
+			0x0f, 0xe8, 0x21, 0x9b, 0x8e, 0x67, 0x04, 0xc7,
+			0x26, 0xb6, 0x03, 0xe1, 0x00, 0x09, 0xf6, 0x77,
+			0x76, 0x46, 0x51, 0x41, 0x57, 0x0d, 0x4b, 0x4c,
+			0x2a, 0x30, 0xdb, 0x84, 0x02, 0x6f, 0x93, 0x4b,
+			0x81, 0xf0, 0xd5, 0xe9, 0x85, 0xc9, 0x75, 0xd6,
+			0xa9, 0x07, 0x5a, 0x41, 0xd4, 0x17, 0xc6, 0xd9,
+			0x93, 0xcb, 0x49, 0x73, 0xcb, 0xe5, 0x12, 0xa6,
+			0x7d, 0xb3, 0x1f, 0x6a, 0xec, 0x8c, 0xc3, 0xe9,
+			0xe5, 0xeb, 0xdc, 0x1e, 0xb7, 0xb4, 0x74, 0x54,
+			0x51, 0x52, 0xa1, 0x56, 0xd5, 0xac, 0x58, 0x7d
+		},
+		.length = 512
+	}
 };
 
 /**
@@ -196,12 +469,12 @@ static void search_smallprime(size_t size, struct caambuf *prime)
 	size_t psize;
 
 	for (idx = 0; idx < nbElem; idx++) {
-		psize = strlen(smallprimes[idx]);
+		psize = smallprimes[idx].length;
 
 		if (psize == size) {
 			/* Found a predefined prime */
 			PRIME_TRACE("Found prime idx %d", idx);
-			prime->data   = (uint8_t *)&smallprimes[idx];
+			prime->data   = (uint8_t *)smallprimes[idx].data;
 			prime->length = psize;
 			prime->paddr  = virt_to_phys(prime->data);
 			break;
@@ -295,7 +568,8 @@ static enum CAAM_Status do_desc_setup(descPointer_t desc,
 
 	PRIME_DUMPDESC(desc);
 
-	cache_operation(TEE_CACHECLEAN, (void *)sqrt_value, data->p->length);
+	cache_operation(TEE_CACHECLEAN, (void *)sqrt_value,
+		ARRAY_SIZE(sqrt_value));
 
 	return CAAM_NO_ERROR;
 }
diff --git a/core/drivers/caam/acipher/caam_rsa.c b/core/drivers/caam/acipher/caam_rsa.c
index 204ae6ef..bf856337 100644
--- a/core/drivers/caam/acipher/caam_rsa.c
+++ b/core/drivers/caam/acipher/caam_rsa.c
@@ -33,7 +33,6 @@
 /*
  * Debug Macros
  */
-//#define RSA_DEBUG
 #ifdef RSA_DEBUG
 //#define DUMP_DESC
 //#define DUMP_BUF
@@ -75,7 +74,7 @@
  *           Format #2: (p, q, d)
  *           Format #3: (p, q, dp, dq, qp)
  */
-#define RSA_PRIVATE_KEY_FORMAT  3
+#define RSA_PRIVATE_KEY_FORMAT  1
 
 static TEE_Result do_caam_encrypt(struct imxcrypt_rsa_ed *rsa_data,
 				descEntry_t operation);
@@ -191,9 +190,12 @@ exit_conv:
  * @retval  CAAM_OUT_MEMORY  Allocation error
  */
 static enum CAAM_Status do_keypair_conv(struct caam_rsa_keypair *outkey,
-		const struct rsa_keypair *inkey)
+		const struct rsakey *key)
 {
 	enum CAAM_Status retstatus;
+	struct rsa_keypair *inkey;
+	uint8_t *ptr_d;
+	size_t size_d, idx_d;
 
 #if (RSA_PRIVATE_KEY_FORMAT > 1)
 	size_t size_p, size_q;
@@ -202,6 +204,8 @@ static enum CAAM_Status do_keypair_conv(struct caam_rsa_keypair *outkey,
 #endif
 #endif
 
+	inkey = key->key;
+
 	RSA_TRACE("RSA Convert Keypair size N=%d",
 		crypto_bignum_num_bytes(inkey->n));
 
@@ -214,12 +218,32 @@ static enum CAAM_Status do_keypair_conv(struct caam_rsa_keypair *outkey,
 	crypto_bignum_bn2bin(inkey->n, outkey->n.data);
 	cache_operation(TEE_CACHECLEAN, outkey->n.data, outkey->n.length);
 
-	retstatus = caam_alloc_align_buf(&outkey->d,
-					crypto_bignum_num_bytes(inkey->d));
+/*
+ * crypto_bignum_bn2bin drops leading zeros
+ * crypto_bignum_num_bytes starts counting from the first bit set
+ * CCM black key may have 0 as nonce value so prepends them
+ */
+	size_d = crypto_bignum_num_bytes(inkey->d);
+
+#ifdef _CFG_CRYPTO_WITH_BK
+	if ((key->is_black == true) && (key->bk_type == BK_CCM))
+		size_d = CCM_BLACK_KEY_SIZE(crypto_bignum_num_bytes(inkey->n));
+#endif
+	retstatus = caam_alloc_align_buf(&outkey->d, size_d);
 	if (retstatus != CAAM_NO_ERROR)
 		goto exit_conv;
 
-	crypto_bignum_bn2bin(inkey->d, outkey->d.data);
+	ptr_d = outkey->d.data;
+	idx_d = 0;
+
+#ifdef _CFG_CRYPTO_WITH_BK
+	if ((key->is_black == true) && (key->bk_type == BK_CCM)) {
+		memset(ptr_d, 0, size_d);
+		idx_d = size_d - crypto_bignum_num_bytes(inkey->d);
+	}
+#endif
+	crypto_bignum_bn2bin(inkey->d, ptr_d + idx_d);
+	RSA_DUMPBUF("D", outkey->d.data, outkey->d.length);
 	cache_operation(TEE_CACHECLEAN, outkey->d.data, outkey->d.length);
 
 	outkey->format = 1;
@@ -359,7 +383,8 @@ static TEE_Result do_allocate_keypair(struct rsa_keypair *key,
 		goto err_alloc_keypair;
 
 	/* Allocate the Private Exponent [d = 1/e mod LCM(p-1, q-1)] */
-	key->d = crypto_bignum_allocate(size_bits);
+	/* Allocate 12 more bytes to fit CCM black key */
+	key->d = crypto_bignum_allocate(size_bits + 96);
 	if (!key->d)
 		goto err_alloc_keypair;
 
@@ -1341,7 +1366,7 @@ static TEE_Result do_caam_decrypt(struct imxcrypt_rsa_ed *rsa_data,
 	 * Convert TEE rsa key type to CAAM rsa key type
 	 * Push key value to memory
 	 */
-	retstatus = do_keypair_conv(&key, rsa_data->key.key);
+	retstatus = do_keypair_conv(&key, &rsa_data->key);
 	if (retstatus != CAAM_NO_ERROR) {
 		ret = TEE_ERROR_OUT_OF_MEMORY;
 		goto exit_decrypt;
@@ -1421,7 +1446,12 @@ static TEE_Result do_caam_decrypt(struct imxcrypt_rsa_ed *rsa_data,
 		ret = TEE_ERROR_GENERIC;
 		goto exit_decrypt;
 	}
-
+#ifdef _CFG_CRYPTO_WITH_BK
+	/* Set the original (plain) key size from modulus size */
+	if ((rsa_data->key.is_black == true) &&
+		(rsa_data->key.bk_type == BK_CCM))
+		key.d.length = key.n.length;
+#endif
 	/* Build the descriptor function of the Private Key format */
 	switch (key.format) {
 	case 1:
@@ -1472,7 +1502,17 @@ static TEE_Result do_caam_decrypt(struct imxcrypt_rsa_ed *rsa_data,
 	}
 
 	/* Set the Decryption operation type */
-	desc[desclen++] = operation | PROT_RSA_DEC_KEYFORM(key.format);
+	desc[desclen] = operation | PROT_RSA_DEC_KEYFORM(key.format);
+
+#ifdef _CFG_CRYPTO_WITH_BK
+	if (rsa_data->key.is_black == true) {
+		desc[desclen] |= PROT_RSA_KEY_TYPE(ENC);
+		if (rsa_data->key.bk_type == BK_CCM)
+			desc[desclen] |= PROT_RSA_KEY_TYPE(EKT);
+	}
+#endif
+
+	desclen++;
 
 	if (operation == RSA_DECRYPT(PKCS_V1_5)) {
 		/* Get the PPKCS1 v1.5 Message length generated */
diff --git a/core/drivers/caam/caam_bk.c b/core/drivers/caam/caam_bk.c
new file mode 100644
index 00000000..6668aaa3
--- /dev/null
+++ b/core/drivers/caam/caam_bk.c
@@ -0,0 +1,391 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    caam_bk.c
+ *
+ * @brief   CAAM Black key manager.\n
+ *          Implementation of Black key functions
+ */
+/* Standard includes */
+#include <string.h>
+
+/* Global includes */
+#include <tee_api_defines.h>
+
+/* Global includes */
+#include <mm/core_memprot.h>
+#include <tee/cache.h>
+#include <utee_defines.h>
+
+/* Library crypto includes */
+#include <crypto/crypto.h>
+
+/* Platform includes */
+#include <imx.h>
+
+/* Library i.MX includes */
+#include <libimxcrypt.h>
+#include <libimxcrypt_bk.h>
+#include <libimxcrypt_acipher.h>
+
+/* Local includes */
+#include "common.h"
+#include "caam_bk.h"
+#include "caam_jr.h"
+
+/* Utils includes */
+#include "utils_mem.h"
+
+/*
+ * Debug Macros
+ */
+#ifdef BK_DEBUG
+#define BK_TRACE		DRV_TRACE
+#else
+#define BK_TRACE(...)
+#endif
+
+#ifdef DUMP_DESC
+#define BK_DUMPDESC(desc)	{BK_TRACE("BK Descriptor"); \
+							DRV_DUMPDESC(desc); }
+#else
+#define BK_DUMPDESC(desc)
+#endif
+
+#ifdef DUMP_BUF
+#define BK_DUMPBUF	DRV_DUMPBUF
+#else
+#define BK_DUMPBUF(...)
+#endif
+
+#define BK_OPERATE_DESC_ENTRIES	5
+
+/**
+ * @brief
+ * Build RSA private key encapsulation job descriptor.
+ *
+ * Load key to class 1 key register.
+ * The PKHA E Size Register is automatically written by the KEY Command.
+ * Write back out via FIFO store.
+ *
+ * @param[in/out] desc Pointer to job descriptor buffer
+ * @param[in] type     Encapsulation type
+ * @param[in] pk_ptr   Physical address of plain key
+ * @param[in] pk_size  Plain key size
+ * @param[in] bk_ptr   Physical address of black key
+ *
+ * @retval desclen     Length of the constructed job descriptor
+ */
+static uint8_t build_rsa_encap_jobdesc(descPointer_t desc, enum bk_type type,
+		paddr_t pk_ptr, size_t pk_size, paddr_t bk_ptr)
+{
+
+	uint8_t desclen = 1;
+
+	desc[desclen++] = (CMD_KEY_TYPE | CMD_CLASS(CLASS_1) | KEY_DEST(PKHA_E)
+			| KEY_LENGTH(pk_size));
+	desc[desclen++] = pk_ptr;
+
+	/* ...and write back out via FIFO store */
+	desc[desclen] = (type == BK_CCM) ?
+	FIFO_STORE_OUTPUT(PKHA_E_AES_CCM_JKEK) :
+	FIFO_STORE_OUTPUT(PKHA_E_AES_ECB_JKEK);
+	desc[desclen++] |= CMD_FIFO_STORE_TYPE | CMD_CLASS(CLASS_1)
+			| FIFO_STORE_LENGTH(pk_size);
+	desc[desclen++] = bk_ptr;
+
+	/* finish off the job header */
+	desc[0] = DESC_HEADER_IDX(desclen, 0);
+
+	return desclen;
+}
+
+/**
+ * @brief   CAAM driver does not implement free_keypair function.
+ *			Manually free key.
+ *
+ * @param[in]  key    key-pair structure to free
+ *
+ */
+static void free_rsa_key(struct rsa_keypair *key)
+{
+	if (key) {
+		crypto_bignum_free(key->e);
+		crypto_bignum_free(key->d);
+		crypto_bignum_free(key->n);
+		crypto_bignum_free(key->p);
+		crypto_bignum_free(key->q);
+		crypto_bignum_free(key->dp);
+		crypto_bignum_free(key->dq);
+		crypto_bignum_free(key->qp);
+		free(key);
+	}
+}
+
+/**
+ * @brief
+ * Encapsulates input plain key to black a key.
+ *
+ * When using AES-ECB encryption, data is a multiple of 16 bytes long.
+ * If the Private exponent is a multiple of 128-bit, then the AES-ECB
+ * encrypted key would fit in the same buffer as the original plain key.
+ * So if the plain key is not a multiple of 16 bytes long,
+ * then it is padded before being encrypted.
+ * A CCM-encrypted black key is always at least 12 bytes longer
+ * than the encapsulated key.
+ *
+ * @param[in/out] bk_key    Black key data to encapsulate
+ *
+ * @retval TEE_SUCCESS               Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY   Not enough memory
+ * @retval TEE_ERROR_BAD_PARAMETERS  Bad parameters
+ * @retval TEE_ERROR_GENERIC         Any other error
+ */
+static TEE_Result do_encapsulate(struct imxcrypt_bk_key *bk_key)
+{
+	TEE_Result ret = TEE_ERROR_GENERIC;
+	size_t bk_size, pk_size;
+	enum CAAM_Status retstatus = CAAM_FAILURE;
+	paddr_t paddr_input = 0;
+
+	struct jr_jobctx jobctx = { 0 };
+	descPointer_t desc = 0;
+	int retS = 0;
+
+	struct caambuf out_buf = { 0 };
+
+	/* Check input parameters */
+	if (!bk_key) {
+		BK_TRACE("Input is NULL");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	if (bk_key->type >= BK_MAX_TYPE) {
+		BK_TRACE("Invalid black key type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Allocate the job used to prepare the operation */
+	desc = caam_alloc_desc(BK_OPERATE_DESC_ENTRIES);
+	if (!desc) {
+		BK_TRACE("Could not allocate memory for descriptor");
+		return TEE_ERROR_OUT_OF_MEMORY;
+	}
+
+	/* Key size */
+	pk_size = bk_key->pk.length;
+
+	/* Compute output black key size */
+	if (bk_key->type == BK_CCM)
+		bk_size = CCM_BLACK_KEY_SIZE(pk_size);
+	else
+		bk_size = ECB_BLACK_KEY_SIZE(pk_size);
+
+	paddr_input = virt_to_phys(bk_key->pk.data);
+	if (!paddr_input) {
+		BK_TRACE("Error getting physical address of plain key");
+		goto exit_operate;
+	}
+
+	retS = caam_realloc_align(bk_key->bk.data, &out_buf, bk_size);
+	if (retS == (-1)) {
+		BK_TRACE("Signature reallocation error");
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_operate;
+	}
+
+	BK_DUMPBUF("Input",
+			bk_key->pk.data, bk_key->pk.length);
+
+	switch (bk_key->alg) {
+
+	case CRYPTO_RSA:
+		build_rsa_encap_jobdesc(desc, bk_key->type,
+			paddr_input, pk_size, out_buf.paddr);
+		break;
+	default:
+		BK_TRACE("Algo not supported CAAM BK");
+		ret = TEE_ERROR_NOT_SUPPORTED;
+		goto exit_operate;
+	}
+
+	jobctx.desc = desc;
+	BK_DUMPDESC(desc);
+
+	cache_operation(TEE_CACHECLEAN, bk_key->pk.data, pk_size);
+	cache_operation(TEE_CACHEFLUSH, out_buf.data, out_buf.length);
+
+	/* Enqueue the job descriptor */
+	retstatus = caam_jr_enqueue(&jobctx, NULL);
+
+	if (retstatus == CAAM_NO_ERROR) {
+		cache_operation(TEE_CACHEINVALIDATE, out_buf.data,
+			out_buf.length);
+		BK_TRACE("Done CAAM BK");
+		BK_DUMPBUF("Output", out_buf.data, bk_size);
+		/*
+		 * Copy the result data in the correct output
+		 * buffer function of the operation direction
+		 */
+		memcpy(bk_key->bk.data, out_buf.data, bk_size);
+		ret = TEE_SUCCESS;
+		bk_key->bk.length = bk_size;
+	} else {
+		BK_TRACE("CAAM Status 0x%08"PRIx32"", jobctx.status);
+		ret = TEE_ERROR_GENERIC;
+		goto exit_operate;
+	}
+
+exit_operate:
+	if (retS == 1)
+		caam_free_buf(&out_buf);
+
+	caam_free_desc(&desc);
+	return ret;
+}
+
+/**
+ * @brief
+ * RSA Sign data using a black key.
+ *
+ * @param[in/out] bk_data    Data to decrypt using black key
+ *
+ * @retval TEE_SUCCESS               Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY   Not enough memory
+ * @retval TEE_ERROR_BAD_PARAMETERS  Bad parameters
+ * @retval TEE_ERROR_GENERIC         Any other error
+ */
+static TEE_Result do_rsa_sign(struct imxcrypt_bk_data *bk_data)
+{
+
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	struct imxcrypt_rsa *rsa = NULL;
+	struct rsa_keypair *key = NULL;
+	struct imxcrypt_rsa_ed rsa_data = {0};
+
+	/* Check if RSA is available */
+	rsa = imxcrypt_getmod(CRYPTO_RSA);
+	if (!rsa) {
+		BK_TRACE("CAAM RSA not implemented or not enabled");
+		res = TEE_ERROR_NOT_IMPLEMENTED;
+		goto out;
+	}
+
+	/* Check input key */
+	if (bk_data->key_sz < 2) {
+		BK_TRACE("Invalid RSA key");
+		res = TEE_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	/* Allocate Key */
+	key = malloc(sizeof(struct rsa_keypair));
+	if (!key) {
+		BK_TRACE("Error allocating RSA keypair");
+		res = TEE_ERROR_OUT_OF_MEMORY;
+		goto out;
+	}
+
+	/* Allocate RSA Key pair */
+	res = rsa->alloc_keypair(key, bk_data->key[1].length * 8);
+	if (res != TEE_SUCCESS) {
+		BK_TRACE("Error allocating RSA keypair");
+		res = TEE_ERROR_OUT_OF_MEMORY;
+		goto out;
+	}
+
+	/* Set private exponent */
+	if (crypto_bignum_bin2bn(bk_data->key[0].data,
+		bk_data->key[0].length, key->d) != TEE_SUCCESS) {
+		BK_TRACE("Error setting private exponent");
+		res = TEE_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	/* Set public modulus */
+	if (crypto_bignum_bin2bn(bk_data->key[1].data,
+		bk_data->key[1].length, key->n) != TEE_SUCCESS) {
+		BK_TRACE("Error setting public modulus");
+		res = TEE_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	/* Setup RSA parameters */
+	rsa_data.key.key = key;
+	rsa_data.key.isprivate = true;
+	rsa_data.key.n_size = bk_data->key[1].length;
+	rsa_data.key.is_black = true;
+	rsa_data.key.bk_type = bk_data->type;
+	rsa_data.rsa_id = RSA_SIGN;
+	rsa_data.message.data = bk_data->dst.data;
+	rsa_data.message.length = bk_data->dst.length;
+	rsa_data.cipher.data = bk_data->src.data;
+	rsa_data.cipher.length = bk_data->src.length;
+
+	/* RSA private decrypt (sign) */
+	res = rsa->decrypt(&rsa_data);
+	if (res != TEE_SUCCESS) {
+		BK_TRACE("Error signing using CAAM black key");
+		res = TEE_ERROR_GENERIC;
+		goto out;
+	}
+
+	/* Update the out signature size */
+	bk_data->dst.length = rsa_data.cipher.length;
+
+out:
+	free_rsa_key(key);
+	return res;
+}
+
+/**
+ * @brief
+ * Sign data using a black key.
+ *
+ * @param[in/out] bk_data    Data to decrypt using black key
+ *
+ * @retval TEE_SUCCESS               Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY   Not enough memory
+ * @retval TEE_ERROR_BAD_PARAMETERS  Bad parameters
+ * @retval TEE_ERROR_GENERIC         Any other error
+ */
+static TEE_Result do_sign(struct imxcrypt_bk_data *bk_data)
+{
+
+	/* Check if the algorithm with black key is supported */
+	if (bk_data->alg == CRYPTO_RSA)
+		return do_rsa_sign(bk_data);
+
+	BK_TRACE("Algorithm with black key not supported ");
+	return TEE_ERROR_NOT_IMPLEMENTED;
+
+}
+/**
+ * @brief   Registration of the Black key Driver
+ */
+struct imxcrypt_bk driver_bk = {
+	.encapsulate = &do_encapsulate,
+	.sign = &do_sign
+};
+
+/**
+ * @brief   Initialize the Black key module
+ *
+ * @param[in] ctrl_addr   Controller base address
+ *
+ * @retval  CAAM_NO_ERROR    Success
+ * @retval  CAAM_FAILURE     An error occurred
+ */
+enum CAAM_Status caam_bk_init(vaddr_t ctrl_addr __unused)
+{
+	enum CAAM_Status retstatus = CAAM_FAILURE;
+
+	/* Register the BK Driver */
+	if (imxcrypt_register(CRYPTO_BK, &driver_bk) == 0)
+		retstatus = CAAM_NO_ERROR;
+
+	return retstatus;
+}
+
diff --git a/core/drivers/caam/caam_blob.c b/core/drivers/caam/caam_blob.c
index 2b993071..e8450fdd 100644
--- a/core/drivers/caam/caam_blob.c
+++ b/core/drivers/caam/caam_blob.c
@@ -21,6 +21,7 @@
 /* Library i.MX includes */
 #include <libimxcrypt.h>
 #include <libimxcrypt_huk.h>
+#include <libimxcrypt_blob.h>
 
 /* Local includes */
 #include "common.h"
@@ -33,10 +34,9 @@
 /*
  * Debug Macros
  */
-//#define BLOB_DEBUG
 #ifdef BLOB_DEBUG
-#define DUMP_DESC
-#define DUMP_BUF
+//#define DUMP_DESC
+//#define DUMP_BUF
 #define BLOB_TRACE		DRV_TRACE
 #else
 #define BLOB_TRACE(...)
@@ -167,6 +167,230 @@ struct imxcrypt_huk driver_huk = {
 	.generate_huk = &caam_master_key_verif,
 };
 
+/**
+ * @brief
+ *   - Encapsulates input data to RED or BLACK blob.\n
+ *   - Decapsulates the input blob to provide the encapsulated data.\n
+ *   \n
+ *   If resulting blob is black, the data must be black as well.\n
+ *   If resulting blob is red, the data are plain text.\n
+ *   \n
+ *   Output data length is:\n
+ *      - encapsulation = inLen + BLOB_BPAD_SIZE\n
+ *      - decapsulation = inLen - BLOB_BPAD_SIZE\n
+ *   \n
+ * @param[in/out] blob_data    Blob data to encapsulate/decapsulate
+ *
+ * @retval TEE_SUCCESS               Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY   Not enough memory
+ * @retval TEE_ERROR_BAD_PARAMETERS  Bad parameters
+ * @retval TEE_ERROR_GENERIC         Any other error
+ */
+static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
+{
+#define BLOB_OPERATE_DESC_ENTRIES	9
+
+	TEE_Result ret = TEE_ERROR_GENERIC;
+	enum CAAM_Status retstatus = CAAM_FAILURE;
+
+	struct jr_jobctx jobctx = {0};
+	descPointer_t desc = NULL;
+
+	paddr_t paddr_input = 0;
+	paddr_t paddr_key = 0;
+
+	struct caambuf out_buf = {0};
+	size_t insize, rinsize;
+	size_t outsize, routsize;
+
+	uint32_t opflag   = 0;
+	int retS = 0;
+	uint8_t desclen = 1;
+
+	BLOB_TRACE("Blob %s - Type %d - Payload %d bytes - Blob %d bytes",
+			(blob_data->encaps) ? "Encaps" : "Decaps",
+			blob_data->type,
+			blob_data->payload.length,
+			blob_data->blob.length);
+
+	paddr_key = virt_to_phys(blob_data->key.data);
+	if (!paddr_key)
+		goto exit_operate;
+
+	if (blob_data->encaps) {
+		retS = caam_realloc_align(blob_data->blob.data, &out_buf,
+				blob_data->blob.length);
+		if (retS == (-1)) {
+			BLOB_TRACE("Signature reallocation error");
+			ret = TEE_ERROR_OUT_OF_MEMORY;
+			goto exit_operate;
+		}
+
+		insize  = blob_data->payload.length;
+		outsize = blob_data->blob.length;
+
+		paddr_input = virt_to_phys(blob_data->payload.data);
+		if (!paddr_input)
+			goto exit_operate;
+
+		BLOB_DUMPBUF("Input",
+			blob_data->payload.data, blob_data->payload.length);
+	} else {
+		retS = caam_realloc_align(blob_data->payload.data, &out_buf,
+		blob_data->payload.length);
+		if (retS == (-1)) {
+			BLOB_TRACE("Signature reallocation error");
+			ret = TEE_ERROR_OUT_OF_MEMORY;
+			goto exit_operate;
+		}
+		insize  = blob_data->blob.length;
+		outsize = blob_data->payload.length;
+
+		paddr_input = virt_to_phys(blob_data->blob.data);
+		if (!paddr_input)
+			goto exit_operate;
+
+		BLOB_DUMPBUF("Input",
+			blob_data->blob.data, blob_data->blob.length);
+	}
+
+	rinsize  = insize;
+	routsize = outsize;
+
+	switch (blob_data->type) {
+	case BLACK_CCM:
+		opflag = PROT_BLOB_TYPE(BLACK_KEY) | PROT_BLOB_INFO(CCM);
+		/*
+		 * Round up the size of buffer to clean/flush real buffer
+		 * which contains more data
+		 */
+		if (blob_data->encaps)
+			rinsize = BLACK_KEY_CCM_SIZE(insize);
+		else
+			routsize = ROUNDUP(BLACK_KEY_CCM_SIZE(outsize), 16);
+		break;
+
+	case BLACK_ECB:
+		opflag = PROT_BLOB_TYPE(BLACK_KEY) | PROT_BLOB_INFO(ECB);
+		/*
+		 * Round up the size of buffer to clean/flush real buffer
+		 * which contains more data
+		 */
+		if (blob_data->encaps)
+			rinsize = BLACK_KEY_CCM_SIZE(insize);
+		else
+			routsize = ROUNDUP(BLACK_KEY_ECB_SIZE(outsize), 16);
+		break;
+
+	case RED:
+		break;
+
+	default:
+		ret = TEE_ERROR_BAD_PARAMETERS;
+		goto exit_operate;
+	}
+
+	/* Allocate the descriptor */
+	desc = caam_alloc_desc(BLOB_OPERATE_DESC_ENTRIES);
+	if (!desc) {
+		BLOB_TRACE("CAAM Context Descriptor Allocation error");
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_operate;
+	}
+
+	/*
+	 * Create the Blob encapsulation/decapsulation descriptor
+	 */
+	/* Load the key modifier */
+	desc[desclen++] = LD_NOIMM(CLASS_2, REG_KEY, blob_data->key.length);
+	desc[desclen++] = paddr_key;
+
+	/* Define the Input data sequence */
+	desc[desclen++] = SEQ_IN_PTR(insize);
+	desc[desclen++] = paddr_input;
+
+	/* Define the Output data sequence */
+	desc[desclen++] = SEQ_OUT_PTR(outsize);
+	desc[desclen++] = out_buf.paddr;
+
+	if (blob_data->encaps) {
+		/* Define the encapsulation operation */
+		desc[desclen++] = BLOB_ENCAPS | opflag;
+	} else {
+		/* Define the decapsulation operation */
+		desc[desclen++] = BLOB_DECAPS | opflag;
+	}
+
+	/* Set the descriptor Header with length and index */
+	desc[0] = DESC_HEADER(desclen);
+
+	BLOB_DUMPDESC(desc);
+
+	cache_operation(TEE_CACHECLEAN, blob_data->key.data,
+		blob_data->key.length);
+
+	if (blob_data->encaps)
+		cache_operation(TEE_CACHECLEAN, blob_data->payload.data,
+			rinsize);
+	else
+		cache_operation(TEE_CACHECLEAN, blob_data->blob.data,
+			rinsize);
+
+	if (out_buf.nocache == 0)
+		cache_operation(TEE_CACHEFLUSH, out_buf.data, out_buf.length);
+
+	jobctx.desc = desc;
+	retstatus = caam_jr_enqueue(&jobctx, NULL);
+
+	if (retstatus == CAAM_NO_ERROR) {
+		BLOB_TRACE("Done CAAM BLOB %s",
+				blob_data->encaps ? "Encaps" : "Decaps");
+
+		if (out_buf.nocache == 0)
+			cache_operation(TEE_CACHEINVALIDATE, out_buf.data,
+				out_buf.length);
+
+		BLOB_DUMPBUF("Output", out_buf.data, routsize);
+
+		if (retS == 1) {
+			/*
+			 * Copy the result data in the correct output
+			 * buffer function of the operation direction
+			 */
+			if (blob_data->encaps)
+				memcpy(blob_data->blob.data,
+					out_buf.data, routsize);
+			else
+				memcpy(blob_data->payload.data,
+					out_buf.data, routsize);
+
+			ret = TEE_SUCCESS;
+		}
+
+		if (blob_data->encaps)
+			blob_data->blob.length = routsize;
+		else
+			blob_data->payload.length = routsize;
+	} else {
+		BLOB_TRACE("CAAM Status 0x%08"PRIx32"", jobctx.status);
+		ret = TEE_ERROR_GENERIC;
+	}
+
+exit_operate:
+	if (retS == 1)
+		caam_free_buf(&out_buf);
+
+	caam_free_desc(&desc);
+	return ret;
+}
+
+/**
+ * @brief   Registration of the Blob Driver
+ */
+struct imxcrypt_blob driver_blob = {
+	.operate = &do_operate,
+};
+
 /**
  * @brief   Initialize the Blob module
  *
@@ -180,8 +404,10 @@ enum CAAM_Status caam_blob_init(vaddr_t ctrl_addr __unused)
 	enum CAAM_Status retstatus = CAAM_FAILURE;
 
 	/* Register the HUK Driver */
-	if (imxcrypt_register(CRYPTO_HUK, &driver_huk) == 0)
-		retstatus = CAAM_NO_ERROR;
+	if (imxcrypt_register(CRYPTO_HUK, &driver_huk) == 0) {
+		if (imxcrypt_register(CRYPTO_BLOB, &driver_blob) == 0)
+			retstatus = CAAM_NO_ERROR;
+	}
 
 	return retstatus;
 }
diff --git a/core/drivers/caam/caam_ctrl.c b/core/drivers/caam/caam_ctrl.c
index e94c0aa7..dd822d8a 100644
--- a/core/drivers/caam/caam_ctrl.c
+++ b/core/drivers/caam/caam_ctrl.c
@@ -36,6 +36,9 @@
 #ifdef CFG_CRYPTO_BLOB_HW
 #include "caam_blob.h"
 #endif
+#ifdef CFG_CRYPTO_BK_HW
+#include "caam_bk.h"
+#endif
 
 /* Utils includes */
 #include "utils_mem.h"
@@ -168,6 +171,15 @@ static TEE_Result crypto_driver_init(void)
 	}
 #endif
 
+#ifdef CFG_CRYPTO_BK_HW
+	/* Initialize the Black key Module */
+	retstatus = caam_bk_init(jr_cfg.base);
+	if (retstatus != CAAM_NO_ERROR) {
+		retresult = TEE_ERROR_GENERIC;
+		goto exit_init;
+	}
+#endif
+
 	/* Everything is OK, register the Power Management handler */
 	caam_pwr_init();
 
diff --git a/core/drivers/caam/caam_mp.c b/core/drivers/caam/caam_mp.c
index b83a4249..de335710 100644
--- a/core/drivers/caam/caam_mp.c
+++ b/core/drivers/caam/caam_mp.c
@@ -418,7 +418,7 @@ enum CAAM_Status caam_mp_init(vaddr_t ctrl_addr)
 	if (!hal_ctrl_is_mpcurve(ctrl_addr)) {
 		MP_TRACE("MP Private key has not been generated .\n");
 		retstatus = do_mppriv_gen((const uint8_t *)passphrase,
-                            strlen(passphrase),
+					strlen(passphrase),
 			SHIFT_U32((PDB_MP_CSEL_P256 & 0xFF), 17));
 		if (retstatus != CAAM_NO_ERROR) {
 			MP_TRACE("do_mppriv_gen failed!");
diff --git a/core/drivers/caam/hal/common/hal_ctrl.c b/core/drivers/caam/hal/common/hal_ctrl.c
index 322d9a52..20baad4a 100644
--- a/core/drivers/caam/hal/common/hal_ctrl.c
+++ b/core/drivers/caam/hal/common/hal_ctrl.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: BSD-2-Clause
 /**
- * @copyright 2018 NXP
+ * @copyright 2018-2019 NXP
  *
  * @file    hal_ctrl.c
  *
@@ -8,8 +8,8 @@
  *          Implementation of primitives to access HW
  */
 
-/* Global includes */
-#include <io.h>
+/* Local includes */
+#include "caam_io.h"
 
 #ifdef CFG_CRYPTO_HASH_HW
 /* Library i.MX includes */
@@ -19,9 +19,16 @@
 /* Hal includes */
 #include "hal_ctrl.h"
 
+/* Register includes */
+#include "ctrl_regs.h"
+
 /* Register includes */
 #include "version_regs.h"
 
+#include <trace.h>
+
+#define CHECK_MPPRIVK
+
 /**
  * @brief   Returns the number of Job Ring supported
  *
@@ -33,7 +40,7 @@ uint8_t hal_ctrl_jrnum(vaddr_t baseaddr)
 {
 	uint32_t val;
 
-	val = read32(baseaddr + CHANUM_MS);
+	val = get32(baseaddr + CHANUM_MS);
 
 	return GET_CHANUM_MS_JRNUM(val);
 }
@@ -52,11 +59,11 @@ int hal_ctrl_hash_limit(vaddr_t baseaddr)
 	uint32_t val;
 
 	/* Read the number of instance */
-	val = read32(baseaddr + CHANUM_LS);
+	val = get32(baseaddr + CHANUM_LS);
 
 	if (GET_CHANUM_LS_MDNUM(val)) {
 		/* Hashing is supported */
-		val = read32(baseaddr + CHAVID_LS);
+		val = get32(baseaddr + CHAVID_LS);
 		val &= BM_CHAVID_LS_MDVID;
 		if (val == CHAVID_LS_MDVID_LP256)
 			return HASH_SHA256;
@@ -81,7 +88,7 @@ bool hal_ctrl_splitkey(vaddr_t baseaddr)
 	uint32_t val;
 
 	/* Read the number of instance */
-	val = read32(baseaddr + CAAMVID_MS);
+	val = get32(baseaddr + CAAMVID_MS);
 
 	if (GET_CAAMVID_MS_MAJ_REV(val) < 3) {
 		return false;
@@ -104,9 +111,146 @@ uint8_t hal_ctrl_caam_era(vaddr_t baseaddr)
 	uint32_t val;
 
 	/* Read the number of instance */
-	val = read32(baseaddr + CCBVID);
+	val = get32(baseaddr + CCBVID);
 
 	return GET_CCBVID_CAAM_ERA(val);
 }
 #endif
 
+#ifdef CFG_CRYPTO_MP_HW
+
+/**
+ * @brief   Get the size in bytes of the MPMR\n
+ *          knowing that MPMR reigster is 8 bits.
+ *
+ * @retval MPMR_NB_REG   Size in bytes of the MPMR
+ */
+size_t hal_ctrl_get_mpmr_size(void)
+{
+	return MPMR_NB_REG;
+}
+
+/**
+ * @brief   Get the SCFGR content and check the MPCURVE fields
+ *
+ * @param[in] ctrl_addr  Controller base address
+ *
+ * @retval true       Success
+ * @retval false      Failure
+ */
+bool hal_ctrl_is_mpcurve(vaddr_t ctrl_addr __maybe_unused)
+{
+#ifdef CHECK_MPPRIVK
+	uint32_t val_scfgr;
+
+	/* get the SCFGR content */
+	val_scfgr = get32(ctrl_addr + SCFGR);
+	DMSG("val_scfgr = 0x%x", val_scfgr);
+
+	/**
+	 * check if the MPCURVE field value is 0
+	 * which means that the MP Private key has not been generated
+	 */
+	if (val_scfgr & BM_SCFGR_MPCURVE)
+		return true;
+
+#endif
+
+	/*
+	 * always return false to generate private key
+	 * even if the MPCURVE field is not clear
+	 */
+	return false;
+}
+
+/**
+ * @brief   Get the MPMR content
+ *
+ * @param[in] ctrl_addr  Controller base address
+ * @param[out] val_scfgr Value of the MPMR
+ */
+void hal_ctrl_get_mpmr(vaddr_t ctrl_addr, uint8_t *val_scfgr)
+{
+	int i;
+	uint32_t val;
+	/*
+     * get the SCFGR content
+     * Note that the MPMR endianess is reverted between write and read
+     */
+	for (i = 0; i < MPMR_NB_REG; i += 4) {
+		val = get32(ctrl_addr + MPMR + i);
+		val_scfgr[i]     = (uint8_t)((val >> 24) & 0xFF);
+		val_scfgr[i + 1] = (uint8_t)((val >> 16) & 0xFF);
+		val_scfgr[i + 2] = (uint8_t)((val >> 8) & 0xFF);
+		val_scfgr[i + 3] = (uint8_t)(val & 0xFF);
+	}
+
+}
+
+/**
+ * @brief   Fill the MPMR content then lock the register
+ *
+ * @param[in] ctrl_addr  Controller base address
+ * @param[in] msg_mpmr   Buffer with the message and length
+ *                       to fill the MPMR content
+ */
+void hal_ctrl_fill_mpmr(vaddr_t ctrl_addr, struct imxcrypt_buf *msg_mpmr)
+{
+	int i;
+	vaddr_t reg = ctrl_addr + MPMR;
+	bool is_filled = false;
+	uint32_t val = 0;
+	uint16_t min, remain;
+
+	/* check if the MPMR is filled */
+	if (get32(ctrl_addr + SCFGR) & BM_SCFGR_MPMRL)
+		is_filled = true;
+
+	DMSG("is_filled = %s", is_filled?"true":"false");
+
+	/* if the MPMR is not filled */
+	if (!is_filled) {
+		/*
+		 * find the min between the message length
+		 * and the MPMR_NB_REG
+		 */
+		min = MIN(msg_mpmr->length, (uint8_t)MPMR_NB_REG);
+		remain = min % 4;
+
+		/* fill the MPMR with the first entiere 32 bits value */
+		for (i = 0; i < (min-remain); i += 4, reg += 4) {
+			val = (msg_mpmr->data[i] |
+					(msg_mpmr->data[i + 1] << 8) |
+					(msg_mpmr->data[i + 2] << 16) |
+					(msg_mpmr->data[i + 3] << 24));
+			write32(val, reg);
+		}
+
+		if (remain) {
+			val = 0;
+			/*
+			 * fill the MPMR with the 8 bits values
+			 * until the end of the message length
+			 */
+			for (i = 0; i < remain; i++)
+				val |= (msg_mpmr->data[i] << (i*8));
+			write32(val, reg);
+			reg += 4;
+		}
+		/* fill the remain of the MPMR with 0 */
+		remain = MPMR_NB_REG - ROUNDUP(msg_mpmr->length, 4);
+		for (i = 0; i < (remain / 4); i++, reg += 4)
+			write32(0x0, reg);
+
+		/*
+		 * locks the MPMR for writing
+		 * remains locked until the next power-on session
+		 * set the MPMRL bit of SCFRG to 1
+		 */
+		write32((get32(ctrl_addr + SCFGR) | BM_SCFGR_MPMRL),
+			ctrl_addr + SCFGR);
+
+		DMSG("val_scfgr = 0x%x", get32(ctrl_addr + SCFGR));
+	}
+}
+#endif // CFG_CRYPTO_MP_HW
\ No newline at end of file
diff --git a/core/drivers/caam/hal/imx_6_7/hal_ctrl.c b/core/drivers/caam/hal/imx_6_7/hal_ctrl.c
index ae7fdbbd..9457ad3e 100644
--- a/core/drivers/caam/hal/imx_6_7/hal_ctrl.c
+++ b/core/drivers/caam/hal/imx_6_7/hal_ctrl.c
@@ -61,141 +61,3 @@ void hal_ctrl_init(vaddr_t baseaddr)
 
 	caam_pwr_add_backup(baseaddr, ctrl_backup, ARRAY_SIZE(ctrl_backup));
 }
-
-#ifdef CFG_CRYPTO_MP_HW
-
-/**
- * @brief   Get the size in bytes of the MPMR\n
- *          knowing that MPMR reigster is 8 bits.
- *
- * @retval MPMR_NB_REG   Size in bytes of the MPMR
- */
-size_t hal_ctrl_get_mpmr_size(void)
-{
-	return MPMR_NB_REG;
-}
-
-/**
- * @brief   Get the SCFGR content and check the MPCURVE fields
- *
- * @param[in] ctrl_addr  Controller base address
- *
- * @retval true       Success
- * @retval false      Failure
- */
-bool hal_ctrl_is_mpcurve(vaddr_t ctrl_addr __maybe_unused)
-{
-#ifdef CHECK_MPPRIVK
-	uint32_t val_scfgr;
-
-	/* get the SCFGR content */
-	val_scfgr = read32(ctrl_addr + SCFGR);
-	DMSG("val_scfgr = 0x%x", val_scfgr);
-
-	/**
-	 * check if the MPCURVE field value is 0
-	 * which means that the MP Private key has not been generated
-	 */
-	if (val_scfgr & BM_SCFGR_MPCURVE)
-		return true;
-
-#endif
-
-	/*
-	 * always return false to generate private key
-	 * even if the MPCURVE field is not clear
-	 */
-	return false;
-}
-
-/**
- * @brief   Get the MPMR content
- *
- * @param[in] ctrl_addr  Controller base address
- * @param[out] val_scfgr Value of the MPMR
- */
-void hal_ctrl_get_mpmr(vaddr_t ctrl_addr, uint8_t *val_scfgr)
-{
-	int i;
-	uint32_t val;
-	/*
-     * get the SCFGR content
-     * Note that the MPMR endianess is reverted between write and read
-     */
-	for (i = 0; i < MPMR_NB_REG; i += 4) {
-		val = read32(ctrl_addr + MPMR + i);
-		val_scfgr[i]     = (uint8_t)((val >> 24) & 0xFF);
-		val_scfgr[i + 1] = (uint8_t)((val >> 16) & 0xFF);
-		val_scfgr[i + 2] = (uint8_t)((val >> 8) & 0xFF);
-		val_scfgr[i + 3] = (uint8_t)(val & 0xFF);
-	}
-
-}
-
-/**
- * @brief   Fill the MPMR content then lock the register
- *
- * @param[in] ctrl_addr  Controller base address
- * @param[in] msg_mpmr   Buffer with the message and length
- *                       to fill the MPMR content
- */
-void hal_ctrl_fill_mpmr(vaddr_t ctrl_addr, struct imxcrypt_buf *msg_mpmr)
-{
-	int i;
-	vaddr_t reg = ctrl_addr + MPMR;
-	bool is_filled = false;
-	uint32_t val = 0;
-	uint16_t min, remain;
-
-	/* check if the MPMR is filled */
-	if (read32(ctrl_addr + SCFGR) & BM_SCFGR_MPMRL)
-		is_filled = true;
-
-	DMSG("is_filled = %s", is_filled?"true":"false");
-
-	/* if the MPMR is not filled */
-	if (!is_filled) {
-		/*
-		 * find the min between the message length
-		 * and the MPMR_NB_REG
-		 */
-		min = MIN(msg_mpmr->length, (uint8_t)MPMR_NB_REG);
-		remain = min % 4;
-
-		/* fill the MPMR with the first entiere 32 bits value */
-		for (i = 0; i < (min-remain); i += 4, reg += 4) {
-			val = (msg_mpmr->data[i] |
-					(msg_mpmr->data[i + 1] << 8) |
-					(msg_mpmr->data[i + 2] << 16) |
-					(msg_mpmr->data[i + 3] << 24));
-			write32(val, reg);
-		}
-
-		if (remain) {
-			val = 0;
-			/*
-			 * fill the MPMR with the 8 bits values
-			 * until the end of the message length
-			 */
-			for (i = 0; i < remain; i++)
-				val |= (msg_mpmr->data[i] << (i*8));
-			write32(val, reg);
-			reg += 4;
-		}
-		/* fill the remain of the MPMR with 0 */
-		remain = MPMR_NB_REG - ROUNDUP(msg_mpmr->length, 4);
-		for (i = 0; i < (remain / 4); i++, reg += 4)
-			write32(0x0, reg);
-
-		/*
-		 * locks the MPMR for writing
-		 * remains locked until the next power-on session
-		 * set the MPMRL bit of SCFRG to 1
-		 */
-		write32((read32(ctrl_addr + SCFGR) | BM_SCFGR_MPMRL),
-			ctrl_addr + SCFGR);
-
-		DMSG("val_scfgr = 0x%x", read32(ctrl_addr + SCFGR));
-	}
-}
-#endif // CFG_CRYPTO_MP_HW
diff --git a/core/drivers/caam/hal/imx_8m/registers/ctrl_regs.h b/core/drivers/caam/hal/imx_8m/registers/ctrl_regs.h
index e22cd053..e373494d 100644
--- a/core/drivers/caam/hal/imx_8m/registers/ctrl_regs.h
+++ b/core/drivers/caam/hal/imx_8m/registers/ctrl_regs.h
@@ -31,5 +31,14 @@
 #define JRxDID_MS_PRIM_TZ			BIT32(4)
 #define JRxDID_MS_PRIM_DID(val)		SHIFT_U32((val & 0xF), 0)
 
+/* Security Configuration */
+#define SCFGR					0x000C
+#define BM_SCFGR_MPCURVE		SHIFT_U32(0xF, 28)
+#define BM_SCFGR_MPMRL          BIT32(26)
+
+/* Manufacturing Protection Message */
+#define MPMR					0x0380
+#define MPMR_NB_REG             0x20
+
 #endif /* __CTRL_REGS_H__ */
 
diff --git a/core/drivers/caam/include/caam_bk.h b/core/drivers/caam/include/caam_bk.h
new file mode 100644
index 00000000..bd627faa
--- /dev/null
+++ b/core/drivers/caam/include/caam_bk.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    caam_bk.h
+ *
+ * @brief   CAAM Black key header
+ */
+#ifndef __CAAM_BK_H__
+#define __CAAM_BK_H__
+
+/* Global includes */
+#include <tee_api_types.h>
+
+/**
+ * @brief   Initialize the Black key module
+ *
+ * @param[in] ctrl_addr   Controller base address
+ *
+ * @retval  CAAM_NO_ERROR    Success
+ * @retval  CAAM_FAILURE     An error occurred
+ */
+enum CAAM_Status caam_bk_init(vaddr_t ctrl_addr);
+
+#endif /* __CAAM_BK_H__ */
diff --git a/core/drivers/caam/include/caam_blob.h b/core/drivers/caam/include/caam_blob.h
index aa2bb048..defa22ff 100644
--- a/core/drivers/caam/include/caam_blob.h
+++ b/core/drivers/caam/include/caam_blob.h
@@ -12,15 +12,6 @@
 /* Global includes */
 #include <tee_api_types.h>
 
-/**
- * @brief   Blob Key Modifier size in bytes
- */
-#define BLOB_KEY_MODIFIER_SIZE	16
-/**
- * @brief   Blob Key (BKEK) size in bytes
- */
-#define BLOB_BKEK_SIZE			32
-
 /**
  * @brief   Initialize the Blob module
  *
diff --git a/core/drivers/caam/include/caam_io.h b/core/drivers/caam/include/caam_io.h
new file mode 100644
index 00000000..3520e317
--- /dev/null
+++ b/core/drivers/caam/include/caam_io.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    caam_io.h
+ *
+ * @brief   CAAM driver caam_io.h include file.\n
+ *          Macros for reading/writing CAAM registers
+ *          taking care of endianness.
+ */
+
+#ifndef __CAAM_IO_H__
+#define __CAAM_IO_H__
+
+#include <io.h>
+
+#define put_le64(a, v)		(*(volatile uint64_t *)(a) = (v))
+
+#define setbits_le32(a, v)      write32((vaddr_t)(a), read32((vaddr_t)(a)) | (v))
+#define clrbits_le32(a, c)      write32((vaddr_t)(a), read32((vaddr_t)(a)) & ~(c))
+#define clrsetbits_le32(a, c, s)        write32((vaddr_t)(a), (read32((vaddr_t)(a)) & ~(c)) | (s))
+
+#define setbits_be32(a, v)      put_be32((void *)(a), get_be32((void *)(a)) | (v))
+#define clrbits_be32(a, c)      put_be32((void *)(a), get_be32((void *)(a)) & ~(c))
+#define clrsetbits_be32(a, c, s)        put_be32((void *)(a), (get_be32((void *)(a)) & ~(c)) | (s))
+
+#ifdef CFG_NXP_SEC_BE
+#define get32(a)		get_be32((void *)(a))
+#define put32(a, v)		put_be32((void *)(a), v)
+#define get64(a)	(                                       \
+		((uint64_t)get32(a) << 32) |        \
+		(get32((uintptr_t)(a) + 4)))
+#define put64(a, v)	put_be64((void *)(a), v)
+#define mask32(a, v, mask) (		\
+	put32(a, (get32(a) & ~mask) | (v & mask)))
+#else
+#define get32(a)		read32((vaddr_t)(a))
+#define put32(a, v)		write32(v, (vaddr_t)(a))
+#define get64(a)	(                                       \
+		((uint64_t)get32((uintptr_t)(a) + 4) << 32) |    \
+		(get32(a)))
+#define put64(a, v)	put_le64(a, v)
+#define mask32(a, v, mask) (		\
+	put32(a, (get32(a) & ~mask) | (v & mask)))
+#endif
+
+#ifdef	CFG_PHYS_64BIT
+#define sec_read_addr(a)	get64(a)
+#define sec_write_addr(a, v)    put64(a, v)
+#else
+#define sec_read_addr(a)	get32(a)
+#define sec_write_addr(a, v)    put32(a, v)
+#endif
+
+#endif /* __CAAM_IO_H__ */
\ No newline at end of file
diff --git a/core/drivers/caam/include/desc_defines.h b/core/drivers/caam/include/desc_defines.h
index bd090a40..a9b5d68d 100644
--- a/core/drivers/caam/include/desc_defines.h
+++ b/core/drivers/caam/include/desc_defines.h
@@ -324,6 +324,13 @@
 #define PROT_RSA_KEY_ALL		0
 #define PROT_RSA_KEY_N_D		2
 
+/* RSA black key */
+#define PROT_RSA_KEY_TYPE(type) SHIFT_U32(PROT_RSA_KEY_##type, 8)
+#define PROT_RSA_KEY_RED		0
+#define PROT_RSA_KEY_ENC		1
+#define PROT_RSA_KEY_TK_ENC	    5
+#define PROT_RSA_KEY_EKT		3
+
 /*
  * ECC Protocol Information
  */
@@ -337,6 +344,16 @@
  * BLOB Protocol Information
  */
 #define PROT_BLOB_FMT_MSTR		BIT32(1)
+#define PROT_BLOB_FMT_MSTR			BIT32(1)
+#define PROT_BLOB_TYPE(type)		SHIFT_U32(1, PROT_BLOB_TYPE_##type)
+#define PROT_BLOB_TYPE_BLACK_KEY	2
+#define PROT_BLOB_EKT				8
+#define PROT_BLOB_INFO(aes)			SHIFT_U32(PROT_BLOB_AES_##aes, \
+					PROT_BLOB_EKT)
+#define PROT_BLOB_AES_CCM			1
+#define PROT_BLOB_AES_ECB			0
+#define PROT_BLOB_FORMAT(format)	SHIFT_U32(0, PROT_BLOB_FORMAT_##format)
+#define PROT_BLOB_FORMAT_NORMAL		0
 
 /*
  * Algorithm Identifier
@@ -518,13 +535,13 @@
 #define MATHI_IMM_VALUE(val)	SHIFT_U32((val & 0xFF), 4)
 
 /*
- * Sequence Output
+ * Sequence Input/Output
  */
+#define CMD_SEQ_IN_TYPE			CMD_TYPE(0x1E)
 #define CMD_SEQ_OUT_TYPE		CMD_TYPE(0x1F)
 
 /* Length */
-#define SEQ_OUT_LENGTH(len)		SHIFT_U32((len & 0xFFFF), 0)
-
+#define SEQ_LENGTH(len)			SHIFT_U32((len & 0xFFFF), 0)
 /*
  * PKHA Operation
  */
@@ -630,6 +647,10 @@
 /* ECC Domain Selection */
 #define PDB_ECC_ECDSEL(curve)		SHIFT_U32((curve & 0x3F), 7)
 
+/* Black key padding */
+#define BLACK_KEY_NONCE_SIZE		6
+#define BLACK_KEY_ICV_SIZE			6
+
 /*
  * ECC Predefined Domain
  */
diff --git a/core/drivers/caam/include/desc_helper.h b/core/drivers/caam/include/desc_helper.h
index 71f2371c..2406400b 100644
--- a/core/drivers/caam/include/desc_helper.h
+++ b/core/drivers/caam/include/desc_helper.h
@@ -475,11 +475,43 @@ static inline void dump_desc(void *desc)
 			(CMD_OP_TYPE | OP_TYPE(ENCAPS) | PROTID(BLOB) | \
 			PROT_BLOB_FMT_MSTR)
 
+/**
+ * @brief   Blob encapsulation
+ */
+#define BLOB_ENCAPS \
+			(CMD_OP_TYPE | OP_TYPE(ENCAPS) | PROTID(BLOB) | \
+			PROT_BLOB_FORMAT(NORMAL))
+
+/**
+ * @brief   Blob decapsulation
+ */
+#define BLOB_DECAPS \
+			(CMD_OP_TYPE | OP_TYPE(DECAPS) | PROTID(BLOB) | \
+			PROT_BLOB_FORMAT(NORMAL))
+
+/**
+ * @brief Black key CCM size
+ */
+#define BLACK_KEY_CCM_SIZE(size) \
+			(ROUNDUP(size, 8) + BLACK_KEY_NONCE_SIZE + \
+			BLACK_KEY_ICV_SIZE)
+/**
+ * @brief Black key ECB size
+ */
+#define BLACK_KEY_ECB_SIZE(size) \
+			ROUNDUP(size, 16)
+
+/**
+ * @brief   Sequence Inout Pointer of length \a len
+ */
+#define SEQ_IN_PTR(len) \
+			(CMD_SEQ_IN_TYPE | SEQ_LENGTH(len))
+
 /**
  * @brief   Sequence Output Pointer of length \a len
  */
 #define SEQ_OUT_PTR(len) \
-			(CMD_SEQ_OUT_TYPE | SEQ_OUT_LENGTH(len))
+			(CMD_SEQ_OUT_TYPE | SEQ_LENGTH(len))
 
 #endif /* __DESC_HELPER_H__ */
 
diff --git a/core/drivers/caam/sub.mk b/core/drivers/caam/sub.mk
index 78c357d9..d94ffcee 100644
--- a/core/drivers/caam/sub.mk
+++ b/core/drivers/caam/sub.mk
@@ -11,6 +11,7 @@ srcs-y += caam_rng.c
 srcs-$(CFG_CRYPTO_HASH_HW)      += caam_hash.c
 srcs-$(CFG_CRYPTO_MP_HW)        += caam_mp.c
 srcs-$(CFG_CRYPTO_BLOB_HW)      += caam_blob.c
+srcs-$(CFG_CRYPTO_BK_HW)        += caam_bk.c
 subdirs-$(CFG_CRYPTO_CIPHER_HW) += cipher
 subdirs-$(CFG_CRYPTO_PK_HW)     += acipher
 
diff --git a/core/lib/libimxcrypt/crypto_api/bk/bk.c b/core/lib/libimxcrypt/crypto_api/bk/bk.c
new file mode 100644
index 00000000..3fac9058
--- /dev/null
+++ b/core/lib/libimxcrypt/crypto_api/bk/bk.c
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    bk.c
+ *
+ * @brief   Cryptographic library using the i.MX CAAM driver.\n
+ *          Black key crypto_* interface implementation.
+ */
+
+/* Global includes */
+#include <crypto/crypto.h>
+#include <trace.h>
+
+/* Library i.MX includes */
+#include <crypto_extension.h>
+#include <libimxcrypt_bk.h>
+
+#ifdef LIB_DEBUG
+#define LIB_TRACE	DMSG
+#else
+#define LIB_TRACE(...)
+#endif
+
+/**
+ * @brief Encapsulates a plain key.
+ *
+ * @param[in] alg    CAAM cryptographic algorithm id
+ * @param[in] type   Encapsulation type
+ * @param[in] pk     Plain key to encapsulate
+ * @param[in] bk     Output black key
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+TEE_Result bk_encapsulate(enum imxcrypt_algo_id alg, enum bk_type type,
+		const struct imxcrypt_buf *pk, struct imxcrypt_buf *bk)
+{
+	TEE_Result ret;
+	struct imxcrypt_bk_key bk_key = { 0 };
+	struct imxcrypt_bk *bkdrv = NULL;
+
+	bkdrv = imxcrypt_getmod(CRYPTO_BK);
+	if (!bkdrv) {
+		LIB_TRACE("Black key is not supported");
+		return TEE_ERROR_NOT_IMPLEMENTED;
+	}
+
+	/* Check input parameters */
+	if ((!pk) || (!bk)) {
+		LIB_TRACE("One of the input data is not defined");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check plain key data is defined */
+	if (!pk->data) {
+		LIB_TRACE("Plain key buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check black key data is defined and big enough */
+	if (!bk->data) {
+		LIB_TRACE("BK buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check BK Type */
+	if (type >= BK_MAX_TYPE) {
+		LIB_TRACE("BK type is not correct");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check Algorithm Id */
+	if (alg >= CRYPTO_MAX_ALGO) {
+		LIB_TRACE("BK type is not correct");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check black key buffer size if type = ECB */
+	if ((type == BK_ECB) && (bk->length < ECB_BLACK_KEY_SIZE(pk->length))) {
+		LIB_TRACE("BK length too short");
+		return TEE_ERROR_SHORT_BUFFER;
+	}
+
+	/* Check black key buffer size if type = CCM */
+	if ((type == BK_CCM) && (bk->length < CCM_BLACK_KEY_SIZE(pk->length))) {
+		LIB_TRACE("BK length too short");
+		return TEE_ERROR_SHORT_BUFFER;
+	}
+
+	/* Fill black key data structure */
+	bk_key.type = type;
+	bk_key.alg = alg;
+	bk_key.pk.data = pk->data;
+	bk_key.pk.length = pk->length;
+	bk_key.bk.data = bk->data;
+	bk_key.bk.length = bk->length;
+
+	/* Operate */
+	ret = bkdrv->encapsulate(&bk_key);
+
+	/* Return the size of the encapsulated key */
+	bk->length = bk_key.bk.length;
+
+	return ret;
+}
+
+/**
+ * @brief Sign data using a black key.
+ *
+ * @param[in] alg       CAAM cryptographic algorithm id
+ * @param[in] type      Encapsulation type
+ * @param[in] key       Key array
+ * @param[in] key_sz    Black keys array size
+ * @param[in] src       Source data
+ * @param[in/out] dst   Destination data
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+TEE_Result bk_sign(enum imxcrypt_algo_id alg, enum bk_type type,
+		const struct imxcrypt_buf key[], size_t key_sz,
+		const struct imxcrypt_buf *src, struct imxcrypt_buf *dst)
+{
+
+	TEE_Result ret;
+	struct imxcrypt_bk_data bk_data = { 0 };
+	struct imxcrypt_bk *bkdrv = NULL;
+	size_t ki;
+
+	bkdrv = imxcrypt_getmod(CRYPTO_BK);
+	if (!bkdrv) {
+		LIB_TRACE("Black key is not supported");
+		return TEE_ERROR_NOT_IMPLEMENTED;
+	}
+
+	/* Check input parameters */
+	if ((!key) || (!src) || (!dst)) {
+		LIB_TRACE("One of the input data is not defined");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check keys count */
+	if ((key_sz >= BK_MAX_KEYS) || key_sz < 1) {
+		LIB_TRACE("Key counts incorrect");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check if at least one key data is defined */
+	if (!(key[0].data)) {
+		LIB_TRACE("Black key buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check Input data is defined and big enough */
+	if (!src->data) {
+		LIB_TRACE("BK buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check Output data is defined and big enough */
+	if (!dst->data) {
+		LIB_TRACE("BK buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check BK Type */
+	if (type >= BK_MAX_TYPE) {
+		LIB_TRACE("BK type is not correct");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check Algorithm Id */
+	if (alg >= CRYPTO_MAX_ALGO) {
+		LIB_TRACE("BK type is not correct");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Fill in data structure */
+	bk_data.type = type;
+	bk_data.alg = alg;
+	bk_data.src.data = src->data;
+	bk_data.src.length = src->length;
+	bk_data.dst.data = dst->data;
+	bk_data.dst.length = dst->length;
+
+	for (ki = 0; ki < key_sz; ki++) {
+		bk_data.key[ki].data = key[ki].data;
+		bk_data.key[ki].length = key[ki].length;
+	}
+
+	bk_data.key_sz = key_sz;
+
+	ret = bkdrv->sign(&bk_data);
+
+	/* Return the size of dest data */
+	dst->length = bk_data.dst.length;
+
+	return ret;
+}
diff --git a/core/lib/libimxcrypt/crypto_api/bk/sub.mk b/core/lib/libimxcrypt/crypto_api/bk/sub.mk
new file mode 100644
index 00000000..71037c32
--- /dev/null
+++ b/core/lib/libimxcrypt/crypto_api/bk/sub.mk
@@ -0,0 +1 @@
+srcs-y += bk.c
\ No newline at end of file
diff --git a/core/lib/libimxcrypt/crypto_api/blob/blob.c b/core/lib/libimxcrypt/crypto_api/blob/blob.c
new file mode 100644
index 00000000..a3fb6898
--- /dev/null
+++ b/core/lib/libimxcrypt/crypto_api/blob/blob.c
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    blob.c
+ *
+ * @brief   Cryptographic library using the i.MX CAAM driver.\n
+ *          Blob crypto_* interface implementation.
+ */
+
+/* Global includes */
+#include <crypto/crypto.h>
+#include <trace.h>
+
+/* Library i.MX includes */
+#include <crypto_extension.h>
+#include <libimxcrypt_blob.h>
+
+//#define LIB_DEBUG
+#ifdef LIB_DEBUG
+#define LIB_TRACE	DMSG
+#else
+#define LIB_TRACE(...)
+#endif
+
+/**
+ * @brief Encapsulates input data.
+ *  Resulting blob is the input length + 48 bytes
+ *
+ * @param[in] type       Type of blob
+ * @param[in] key        Key derivation (must be 128 bits length)
+ * @param[in] payload    Data to encapsulate
+ *
+ * @param[in/out] blob   Resulting blob. The maximum length of the blob
+ *                       buffer in bytes must be given as input
+ *                       (blob length >= payload length + 48 bytes)
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+TEE_Result blob_encapsulate(enum blob_type type,
+		const uint8_t *key,
+		const struct imxcrypt_buf *payload,
+		struct imxcrypt_buf *blob)
+{
+	TEE_Result ret;
+	struct imxcrypt_blob_data blob_data = {0};
+	struct imxcrypt_blob *blobdrv = NULL;
+
+	blobdrv = imxcrypt_getmod(CRYPTO_BLOB);
+	if (!blobdrv) {
+		LIB_TRACE("Blob is not supported");
+		return TEE_ERROR_NOT_IMPLEMENTED;
+	}
+
+	/* Check input parameters */
+	if ((!key) || (!payload) || (!blob)) {
+		LIB_TRACE("One of the input data is not defined");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check payload data is defined */
+	if (!payload->data) {
+		LIB_TRACE("Payload buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check blob data is defined and big enough */
+	if (!blob->data) {
+		LIB_TRACE("Blob buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	if ((blob->length - BLOB_BPAD_SIZE) < payload->length) {
+		LIB_TRACE("Blob length too short");
+		return TEE_ERROR_SHORT_BUFFER;
+	}
+
+	/* Check Blob Type */
+	if (type > BLOB_MAX_TYPE) {
+		LIB_TRACE("Blob type is not correct");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	blob_data.type           = type;
+	blob_data.encaps         = true;
+	blob_data.key.data       = (uint8_t *)key;
+	blob_data.key.length     = BLOB_KEY_MODIFIER_SIZE;
+	blob_data.payload.data   = payload->data;
+	blob_data.payload.length = payload->length;
+	blob_data.blob.data      = blob->data;
+	blob_data.blob.length    = blob->length;
+
+	ret = blobdrv->operate(&blob_data);
+	/* Return the size of the encapsulated blob */
+	blob->length = blob_data.blob.length;
+
+	return ret;
+}
+
+/**
+ * @brief Decapsulates input blob.
+ *  Resulting data is the blob length - 48 bytes
+ *
+ * @param[in] type         Type of blob
+ * @param[in] key          Key derivation (must be 128 bits length)
+ * @param[in] blob         Resulting blob.
+ *
+ * @param[in/out] payload  Data to decapsulate. The maximum length of the
+ *                         buffer in bytes must be given as input
+ *                         (payload length >= blob length - 48 bytes)
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+TEE_Result blob_decapsulate(enum blob_type type,
+		const uint8_t *key,
+		struct imxcrypt_buf *payload,
+		const struct imxcrypt_buf *blob)
+{
+	TEE_Result ret;
+
+	struct imxcrypt_blob_data blob_data = {0};
+	struct imxcrypt_blob *blobdrv = NULL;
+
+	blobdrv = imxcrypt_getmod(CRYPTO_BLOB);
+	if (!blobdrv) {
+		LIB_TRACE("Blob is not supported");
+		return TEE_ERROR_NOT_IMPLEMENTED;
+	}
+
+	/* Check input parameters */
+	if ((!key) || (!payload) || (!blob)) {
+		LIB_TRACE("One of the input data is not defined");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check payload data is defined */
+	if (!payload->data) {
+		LIB_TRACE("Payload buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	/* Check blob data is defined and big enough */
+	if (!blob->data) {
+		LIB_TRACE("Blob buffer error");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	if (blob->length > (payload->length + BLOB_BPAD_SIZE)) {
+		LIB_TRACE("Payload length too short");
+		return TEE_ERROR_SHORT_BUFFER;
+	}
+
+	/* Check Blob Type */
+	if (type > BLOB_MAX_TYPE) {
+		LIB_TRACE("Blob type is not correct");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	blob_data.type           = type;
+	blob_data.encaps         = false;
+	blob_data.key.data       = (uint8_t *)key;
+	blob_data.key.length     = BLOB_KEY_MODIFIER_SIZE;
+	blob_data.payload.data   = payload->data;
+	blob_data.payload.length = payload->length;
+	blob_data.blob.data      = blob->data;
+	blob_data.blob.length    = blob->length;
+
+	ret = blobdrv->operate(&blob_data);
+	/* Return the size of the decapsulated data */
+	payload->length = blob_data.payload.length;
+
+	return ret;
+}
diff --git a/core/lib/libimxcrypt/crypto_api/blob/sub.mk b/core/lib/libimxcrypt/crypto_api/blob/sub.mk
new file mode 100644
index 00000000..501acd4a
--- /dev/null
+++ b/core/lib/libimxcrypt/crypto_api/blob/sub.mk
@@ -0,0 +1 @@
+srcs-y += blob.c
\ No newline at end of file
diff --git a/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h b/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
index 42b19f1a..42661219 100644
--- a/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
+++ b/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
@@ -13,6 +13,7 @@
 #include <tee_api_types.h>
 #include <libimxcrypt.h>
 
+#ifdef _CFG_CRYPTO_WITH_MP
 /**
  * @brief   MP Signature Curve enumerate
  */
@@ -76,5 +77,101 @@ TEE_Result crypto_mp_sign(struct imxcrypt_mp_sign *sdata);
  * @retval TEE_ERROR_GENERIC           Generic error
  */
 TEE_Result crypto_generate_huk(struct imxcrypt_buf *huk);
+#endif // _CFG_CRYPTO_WITH_MP
 
-#endif /* __CRYPTO_EXTENSION_H */
+#ifdef _CFG_CRYPTO_WITH_BLOB
+/**
+ * @brief Encapsulates input data.
+ *  Resulting blob is the input length + 48 bytes
+ *
+ * @param[in] type       Type of blob
+ * @param[in] key        Key derivation (must be 128 bits length)
+ * @param[in] payload    Data to encapsulate
+ * @param[in] blob_len   Length of the blob buffer in bytes (size >= data_len +
+ *                       48 bytes)
+ *
+ * @param[in/out] blob   Resulting blob. The maximum length of the blob
+ *                       buffer in bytes must be given as input
+ *                       (size >= data_len + 48 bytes)
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+TEE_Result blob_encapsulate(enum blob_type type,
+		const uint8_t *key,
+		const struct imxcrypt_buf *payload,
+		struct imxcrypt_buf *blob);
+
+/**
+ * @brief Decapsulates input blob.
+ *  Resulting data is the blob length - 48 bytes
+ *
+ * @param[in] type         Type of blob
+ * @param[in] key          Key derivation (must be 128 bits length)
+ * @param[in] blob         Resulting blob.
+ *
+ * @param[in/out] payload  Data to decapsulate. The maximum length of the
+ *                         buffer in bytes must be given as input
+ *                         (payload length >= blob length - 48 bytes)
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+TEE_Result blob_decapsulate(enum blob_type type,
+		const uint8_t *key,
+		struct imxcrypt_buf *payload,
+		const struct imxcrypt_buf *blob);
+#endif // _CFG_CRYPTO_WITH_BLOB
+
+#ifdef _CFG_CRYPTO_WITH_BK
+/**
+ * @brief Encapsulates a key to a black key.
+ *
+ * @param[in] alg      Cryptographic Algorithm id
+ * @param[in] type     Type of black key
+ * @param[in] pk       Key to encapsulate
+ * @param[in/out] bk   Resulting black key.
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+TEE_Result bk_encapsulate(enum imxcrypt_algo_id alg, enum bk_type type,
+		const struct imxcrypt_buf *pk,
+		struct imxcrypt_buf *bk);
+
+/**
+ * @brief Sign data using a black key.
+ *
+ * @param[in] alg       CAAM cryptographic algorithm id
+ * @param[in] type      Encapsulation type
+ * @param[in] key       Key array
+ * @param[in] key_sz   Black keys array size
+ * @param[in] src       Source data
+ * @param[in/out] dst   Destination data
+ *
+ * @retval TEE_SUCCESS                 Success
+ * @retval TEE_ERROR_OUT_OF_MEMORY     Out of memory
+ * @retval TEE_ERROR_BAD_PARAMETERS    Bad parameters
+ * @retval TEE_ERROR_NOT_IMPLEMENTED   Algorithm is not implemented
+ * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
+ * @retval TEE_ERROR_GENERIC           Generic error
+ */
+TEE_Result bk_sign(enum imxcrypt_algo_id alg, enum bk_type type,
+		const struct imxcrypt_buf key[], size_t key_sz,
+		const struct imxcrypt_buf *src, struct imxcrypt_buf *dst);
+
+#endif // _CFG_CRYPTO_WITH_BK
+
+#endif /* __CRYPTO_EXTENSION_H */
\ No newline at end of file
diff --git a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt.h b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt.h
index f9c957ba..f4e49417 100644
--- a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt.h
+++ b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt.h
@@ -31,7 +31,9 @@ enum imxcrypt_algo_id {
 	CRYPTO_MP,           ///< Manufacturing Protection driver
 	CRYPTO_MATH_HW,      ///< Mathematical HW operation driver
 	CRYPTO_HUK,          ///< Hardware Unique Key operation driver
-	CRYPTO_MAX_ALGO      ///< Maximum numer of algo supported
+	CRYPTO_BLOB,         ///< Blob Encapsulation operation driver
+	CRYPTO_BK,           ///< Key Encapsulation operation driver
+	CRYPTO_MAX_ALGO      ///< Maximum number of algo supported
 };
 
 /**
@@ -42,6 +44,60 @@ struct imxcrypt_buf {
 	size_t  length;  ///< Length in bytes of the data buffer
 };
 
+/**
+ * @brief Blob encryption type
+ */
+enum blob_type {
+	RED       = 0,  ///< Red Blob mode   - data in plain text
+	BLACK_ECB,      ///< Black Blob mode - data encrypted in AES ECB
+	BLACK_CCM,      ///< Black Blod mode - data encrypted in AES CCM
+	BLOB_MAX_TYPE   ///< Maximum number of blob type supported
+};
+
+/**
+ * @brief Key encryption type
+ */
+enum bk_type {
+	BK_ECB,      ///< Black key mode - data encrypted in AES ECB
+	BK_CCM,      ///< Black key mode - data encrypted in AES CCM
+	BK_MAX_TYPE   ///< Maximum number of blob type supported
+};
+
+/**
+ * @brief   Blob Key Modifier size in bytes
+ */
+#define BLOB_KEY_MODIFIER_SIZE	16
+/**
+ * @brief   Blob Key (BKEK) size in bytes
+ */
+#define BLOB_BKEK_SIZE			32
+/**
+ * @brief   Blob MAC (BMAC) size in bytes
+ */
+#define BLOB_BMAC_SIZE			16
+/**
+ * @brief   Blob PAD (BPAD) size in bytes
+ */
+#define BLOB_BPAD_SIZE			(BLOB_BKEK_SIZE + BLOB_BMAC_SIZE)
+
+/**
+ * @brief   Max black key number for an operation
+ */
+#define BK_MAX_KEYS	10
+
+#define ROUNDUPI(n, width) (((n) + (width) - 1) & ~((width) - 1))
+#define PAD_16_BYTE(_key_size) (ROUNDUPI(_key_size, 16))
+#define ECB_BLACK_KEY_SIZE(_key_size) (PAD_16_BYTE(_key_size))
+#define PAD_8_BYTE(_key_size) (ROUNDUPI(_key_size, 8))
+#define NONCE_SIZE 6
+#define IV_SIZE 6
+#define CCM_OVERHEAD (NONCE_SIZE + IV_SIZE)
+#define CCM_BLACK_KEY_SIZE(_key_size) (PAD_8_BYTE(_key_size) \
+	+ CCM_OVERHEAD)
+#define BLOB_OVERHEAD (32 + 16)
+#define SECRET_SIZE_IN_CCM_BLACK_KEY(_key_size) \
+	((_key_size >= CCM_OVERHEAD) ? _key_size - CCM_OVERHEAD : 0)
+
 /**
  * @brief   Cryptographic module registration
  *
@@ -89,4 +145,4 @@ TEE_Result imxcrypt_libsoft_init(void);
  */
 TEE_Result crypto_driver_init(void);
 
-#endif /* __LIBIMXCRYPT_H__ */
+#endif /* __LIBIMXCRYPT_H__ */
\ No newline at end of file
diff --git a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_acipher.h b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_acipher.h
index e2a14845..f3f7cdb8 100644
--- a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_acipher.h
+++ b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_acipher.h
@@ -34,6 +34,10 @@ struct rsakey {
 	void   *key;      ///< Public or Private key
 	size_t n_size;    ///< Size in bytes of the Modulus N
 	bool   isprivate; ///< True if private key
+#ifdef _CFG_CRYPTO_WITH_BK
+	bool   is_black; ///< True if private key is a black key
+	uint32_t   bk_type; ///< Type of black key if is_black is true
+#endif
 };
 
 /**
diff --git a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_bk.h b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_bk.h
new file mode 100644
index 00000000..83b5213c
--- /dev/null
+++ b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_bk.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    libimxcrypt_bk.h
+ *
+ * @brief   Cryptographic library using the i.MX CAAM driver.\n
+ *          Key encapsulation interface library vs CAAM driver.
+ */
+#ifndef __LIBIMXCRYPT_BK_H__
+#define __LIBIMXCRYPT_BK_H__
+
+#include <tee_api_types.h>
+
+/**
+ * @brief Black key structure
+ */
+struct imxcrypt_bk_key {
+	enum bk_type type; ///< Black encryption type
+	enum imxcrypt_algo_id alg; ///< Cryptographic algorithm id
+	struct imxcrypt_buf pk; ///< Plain key data payload
+	struct imxcrypt_buf bk; ///< Black key of payload
+};
+
+/**
+ * @brief Black key data structure
+ */
+
+struct imxcrypt_bk_data {
+	enum imxcrypt_algo_id alg; ///< Cryptographic algorithm id
+	enum bk_type type; ///< Type of black key
+	struct imxcrypt_buf src; ///< Source data
+	struct imxcrypt_buf dst; ///< Destination data
+	size_t key_sz; ///< Destination data
+	struct imxcrypt_buf key[BK_MAX_KEYS]; ///< Holds key components
+};
+
+
+/**
+ * @brief   i.MX Crypto Library Black key driver operations
+ */
+struct imxcrypt_bk {
+	///< Encapsulate key
+	TEE_Result (*encapsulate)(struct imxcrypt_bk_key *bk_key);
+	TEE_Result (*sign)(struct imxcrypt_bk_data *bk_data);
+};
+
+#endif /* __LIBIMXCRYPT_BK_H__ */
diff --git a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h
new file mode 100644
index 00000000..ab348e57
--- /dev/null
+++ b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    libimxcrypt_blob.h
+ *
+ * @brief   Cryptographic library using the i.MX CAAM driver.\n
+ *          Blob data encapsulation interface library vs CAAM driver.
+ */
+#ifndef __LIBIMXCRYPT_BLOB_H__
+#define __LIBIMXCRYPT_BLOB_H__
+
+#include <tee_api_types.h>
+
+/**
+ * @brief Blob data structure
+ */
+struct imxcrypt_blob_data {
+	enum blob_type      type;    ///< Blob encryption type
+	bool                encaps;  ///< Encryption/Decryption direction
+	struct imxcrypt_buf key;     ///< Blob Key modifier
+	struct imxcrypt_buf payload; ///< Decrypted Blob data payload
+	struct imxcrypt_buf blob;    ///< Encrypted Blob of payload
+};
+
+/**
+ * @brief   i.MX Crypto Library BLOB driver operations
+ */
+struct imxcrypt_blob {
+	///< Encapsulate/Decapsulate data
+	TEE_Result (*operate)(struct imxcrypt_blob_data *blob_data);
+};
+
+#endif /* __LIBIMXCRYPT_BLOB_H__ */
\ No newline at end of file
diff --git a/core/lib/libimxcrypt/crypto_api/sub.mk b/core/lib/libimxcrypt/crypto_api/sub.mk
index 6839963b..c3033998 100644
--- a/core/lib/libimxcrypt/crypto_api/sub.mk
+++ b/core/lib/libimxcrypt/crypto_api/sub.mk
@@ -12,3 +12,5 @@ subdirs-$(_CFG_CRYPTO_WITH_ACIPHER) += oid
 subdirs-$(_CFG_CRYPTO_WITH_AUTHENC) += authenc
 subdirs-$(_CFG_CRYPTO_WITH_MP)      += mp
 subdirs-$(_CFG_CRYPTO_WITH_HUK)     += huk
+subdirs-$(_CFG_CRYPTO_WITH_BLOB)    += blob
+subdirs-$(_CFG_CRYPTO_WITH_BK)    += bk
diff --git a/lib/libmbedtls/include/mbedtls_config_uta.h b/lib/libmbedtls/include/mbedtls_config_uta.h
index 2f5f636e..d3c6e8e6 100644
--- a/lib/libmbedtls/include/mbedtls_config_uta.h
+++ b/lib/libmbedtls/include/mbedtls_config_uta.h
@@ -53,6 +53,8 @@
 #define MBEDTLS_PEM_PARSE_C
 #define MBEDTLS_PEM_WRITE_C
 
+#define MBEDTLS_CCM_C
+
 #include <mbedtls/check_config.h>
 
 #endif /* __MBEDTLS_CONFIG_UTA_H */
diff --git a/lib/libutee/include/pta_bk.h b/lib/libutee/include/pta_bk.h
new file mode 100644
index 00000000..bebf283e
--- /dev/null
+++ b/lib/libutee/include/pta_bk.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    pta_bk.h
+ *
+ * @brief   PTA Black key interface identification.
+ */
+#ifndef __PTA_BK_H__
+#define __PTA_BK_H__
+
+/**
+ * @brief   PTA UUID generated at http://www.itu.int/ITU-T/asn1/uuid.html
+ */
+#define PTA_BK_PTA_UUID { \
+	0xf4557e21, 0xaa4f, 0x4259, \
+	{0x90, 0xb6, 0xf9, 0x77, 0x6c, 0xee, 0xba, 0x29} }
+
+/**
+ * @brief   Encapsulates a plain key into black key command id
+ */
+#define PTA_BK_CMD_ENCAPS 1
+
+/**
+ * @brief   Sign using black key command id in PTA
+ */
+#define PTA_BK_CMD_SIGN   2
+
+/**
+ * @brief   PTA black key Type
+ *          Enumerate must be the same as the bk_type defined in the
+ *          crypto_extension.h
+ */
+enum PTA_BK_TYPE {
+	PTA_BK_ECB, ///< Black key mode - key encrypted in AES ECB
+	PTA_BK_CCM, ///< Black key mode - key encrypted in AES CCM
+};
+
+#endif /* __PTA_BK_H__ */
diff --git a/lib/libutee/include/pta_blob.h b/lib/libutee/include/pta_blob.h
new file mode 100644
index 00000000..06c122ed
--- /dev/null
+++ b/lib/libutee/include/pta_blob.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    pta_blob.h
+ *
+ * @brief   PTA Blob interface identification.
+ */
+#ifndef __PTA_BLOB_H__
+#define __PTA_BLOB_H__
+
+/**
+ * @brief   PTA UUID generated at http://www.itu.int/ITU-T/asn1/uuid.html
+ */
+#define PTA_BLOB_PTA_UUID { \
+	0x229b29a9, 0x520, 0x4018, \
+	{0x87, 0xa9, 0xdf, 0xa0, 0xcb, 0x8b, 0x26, 0xd6} }
+
+/**
+ * @brief   PTA Command IDs
+ */
+enum PTA_BLOB_CMD {
+	PTA_BLOB_CMD_ENCAPS = 0, ///< Encapsulation
+	PTA_BLOB_CMD_DECAPS,     ///< Decapsulation
+};
+
+/**
+ * @brief   PTA Blob Type
+ *          Enumerate must be the same as the blob_Type defined in the
+ *          crypto_extension.h
+ */
+enum PTA_BLOB_TYPE {
+	PTA_BLOB_RED = 0,   ///< Red Blob mode   - data in plain text
+	PTA_BLOB_BLACK_ECB, ///< Black Blob mode - data encrypted in AES ECB
+	PTA_BLOB_BLACK_CCM, ///< Black Blod mode - data encrypted in AES CCM
+};
+
+/**
+ * @brief   Blob Key Modifier size in bytes
+ */
+#define PTA_BLOB_KEY_SIZE	16
+
+/**
+ * @brief   Blob PAD size in bytes (padding added to store recovering
+ *          blob key (32 bytes) and a blob MAC (16 bytes)
+ */
+#define PTA_BLOB_PAD_SIZE	 48
+
+#endif /* __PTA_BLOB_H__ */
diff --git a/lib/libutee/include/pta_ocotp.h b/lib/libutee/include/pta_ocotp.h
new file mode 100644
index 00000000..7ed86b9f
--- /dev/null
+++ b/lib/libutee/include/pta_ocotp.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/**
+ * @copyright 2019 NXP
+ *
+ * @file    pta_ocotp.h
+ *
+ * @brief   PTA OCOTP interface identification.
+ */
+#ifndef __PTA_OCOTP_H__
+#define __PTA_OCOTP_H__
+
+
+/**
+ * @brief   PTA UUID generated at http://www.itu.int/ITU-T/asn1/uuid.html
+ */
+#define PTA_OCOTP_PTA_UUID { \
+	0x9abdf255, 0xd8fa, 0x40de, \
+	{0x8f, 0x60, 0x4d, 0x0b, 0x27, 0x92, 0x7b, 0x7d} \
+	}
+
+/**
+ * @brief   Get Chip Unique Id
+ */
+#define PTA_OCOTP_CMD_CHIP_UID 1
+
+
+#endif /* __PTA_OCOTP_H__ */
-- 
2.25.1


From e7862218eb3e6e7c14556957198493336e38daec Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Tue, 4 Aug 2020 11:36:27 +0200
Subject: [PATCH 02/22] Restore RSA CAAM fonctionnalities with plain text keys

Restore RSA operations in the CAAM driver with non-encrypted keys.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/lib/libimxcrypt/crypto_api/acipher/rsa.c    | 4 ++++
 core/lib/libimxcrypt/crypto_api/acipher/rsassa.c | 1 +
 2 files changed, 5 insertions(+)

diff --git a/core/lib/libimxcrypt/crypto_api/acipher/rsa.c b/core/lib/libimxcrypt/crypto_api/acipher/rsa.c
index 17b0cea2..d3a7a4fc 100644
--- a/core/lib/libimxcrypt/crypto_api/acipher/rsa.c
+++ b/core/lib/libimxcrypt/crypto_api/acipher/rsa.c
@@ -184,6 +184,7 @@ TEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,
 	rsa_data.key.key       = key;
 	rsa_data.key.isprivate = true;
 	rsa_data.key.n_size    = crypto_bignum_num_bytes(key->n);
+	rsa_data.key.is_black = false;
 
 	rsa = imxcrypt_getmod(CRYPTO_RSA);
 	if (rsa) {
@@ -244,6 +245,7 @@ TEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,
 	rsa_data.key.key       = key;
 	rsa_data.key.isprivate = false;
 	rsa_data.key.n_size    = crypto_bignum_num_bytes(key->n);
+	rsa_data.key.is_black = false;
 
 	if (rsa_data.key.n_size > *cipher_len) {
 		LIB_TRACE("Cipher length (%d) too short expected %d bytes",
@@ -338,6 +340,7 @@ TEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo,
 		rsa_data.key.key       = key;
 		rsa_data.key.isprivate = true;
 		rsa_data.key.n_size    = crypto_bignum_num_bytes(key->n);
+		rsa_data.key.is_black = false;
 
 		rsa_data.message.data   = msg;
 		rsa_data.message.length = *msg_len;
@@ -405,6 +408,7 @@ TEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo,
 	rsa_data.key.key       = key;
 	rsa_data.key.isprivate = false;
 	rsa_data.key.n_size    = crypto_bignum_num_bytes(key->n);
+	rsa_data.key.is_black = false;
 
 	if (rsa_data.key.n_size > *cipher_len) {
 		LIB_TRACE("Cipher length (%d) too short expected %d bytes",
diff --git a/core/lib/libimxcrypt/crypto_api/acipher/rsassa.c b/core/lib/libimxcrypt/crypto_api/acipher/rsassa.c
index bb6b31c3..9f84d960 100644
--- a/core/lib/libimxcrypt/crypto_api/acipher/rsassa.c
+++ b/core/lib/libimxcrypt/crypto_api/acipher/rsassa.c
@@ -220,6 +220,7 @@ static TEE_Result rsa_encrypt(struct imxcrypt_rsa_ssa *ssa_data,
 	rsa_data.key.key       = ssa_data->key.key;
 	rsa_data.key.isprivate = true;
 	rsa_data.key.n_size    = ssa_data->key.n_size;
+	rsa_data.key.is_black = false;
 
 	rsa = imxcrypt_getmod(CRYPTO_RSA);
 	if (rsa) {
-- 
2.25.1


From 8383fb9324db78e5d138df119bedebbb35b6ca5f Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Mon, 27 Jul 2020 14:29:44 +0200
Subject: [PATCH 03/22] TEE-575 imx: add imx_soc_digprog() function

imx_soc_digprog(). This function returns a 32bits digprog register value.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/arch/arm/plat-imx/imx-common.c | 11 +++++++++--
 core/arch/arm/plat-imx/imx.h        |  3 ++-
 2 files changed, 11 insertions(+), 3 deletions(-)

diff --git a/core/arch/arm/plat-imx/imx-common.c b/core/arch/arm/plat-imx/imx-common.c
index 401834f8..cc20eb8d 100644
--- a/core/arch/arm/plat-imx/imx-common.c
+++ b/core/arch/arm/plat-imx/imx-common.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: BSD-2-Clause
 /*
  * Copyright (C) 2016 Freescale Semiconductor, Inc.
- * Copyright 2017-2019 NXP
+ * Copyright 2017-2020 NXP
  *
  * Peng Fan <peng.fan@nxp.com>
  */
@@ -16,7 +16,7 @@
 static int imx_cpu_type     = (-1);
 static int imx_soc_revision = (-1);
 
-static void imx_digproc(void)
+static uint32_t imx_digproc(void)
 {
 	uint32_t digprog;
 	vaddr_t anatop_addr __maybe_unused;
@@ -59,6 +59,8 @@ static void imx_digproc(void)
 #else
 	imx_soc_revision = digprog & 0xFF;
 #endif
+
+	return digprog;
 }
 
 static uint32_t imx_soc_rev_major(void)
@@ -199,6 +201,11 @@ uint16_t soc_revision(void)
 	return imx_soc_revision;
 }
 
+uint32_t imx_soc_digprog(void)
+{
+	return imx_digproc();
+}
+
 #ifdef CFG_IMX_SNVS
 /**
  * @brief   Returns if the device is closed (full secure) or not
diff --git a/core/arch/arm/plat-imx/imx.h b/core/arch/arm/plat-imx/imx.h
index af7cb99a..9e5338d9 100644
--- a/core/arch/arm/plat-imx/imx.h
+++ b/core/arch/arm/plat-imx/imx.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: BSD-2-Clause */
 /*
- * Copyright 2017-2019 NXP
+ * Copyright 2017-2020 NXP
  *
  * Peng Fan <peng.fan@nxp.com>
  */
@@ -43,6 +43,7 @@ bool soc_is_imx8mm(void);
 bool soc_is_imx8mq(void);
 bool soc_is_imx8mq_b1_layer(void);
 uint16_t soc_revision(void);
+uint32_t imx_soc_digprog(void);
 void imx_gpcv2_set_core1_pdn_by_software(void);
 void imx_gpcv2_set_core1_pup_by_software(void);
 
-- 
2.25.1


From ab0e5a1b482532efca32b2c4c3ff6929843e692b Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Mon, 27 Jul 2020 14:33:38 +0200
Subject: [PATCH 04/22] TEE-575 imx: pta: add PTA soc_info

This PTA exposes soc related information to TAs.
this first commit exposes digprog register.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/arch/arm/plat-imx/conf.mk            |  1 +
 core/arch/arm/plat-imx/pta/pta_soc_info.c | 88 +++++++++++++++++++++++
 core/arch/arm/plat-imx/pta/sub.mk         |  4 +-
 3 files changed, 92 insertions(+), 1 deletion(-)
 create mode 100644 core/arch/arm/plat-imx/pta/pta_soc_info.c

diff --git a/core/arch/arm/plat-imx/conf.mk b/core/arch/arm/plat-imx/conf.mk
index 7dd1d7e2..6968855c 100644
--- a/core/arch/arm/plat-imx/conf.mk
+++ b/core/arch/arm/plat-imx/conf.mk
@@ -93,6 +93,7 @@ $(call force,CFG_MX8MM,y)
 $(call force,CFG_ARM64_core,y)
 $(call force,CFG_TEE_CORE_NB_CORE,4)
 $(call force,CFG_IMX_LPUART,n)
+CFG_PTA_SOC_INFO ?= y
 else ifneq (,$(filter $(PLATFORM_FLAVOR),$(mx8qm-flavorlist)))
 $(call force,CFG_MX8QM,y)
 $(call force,CFG_ARM64_core,y)
diff --git a/core/arch/arm/plat-imx/pta/pta_soc_info.c b/core/arch/arm/plat-imx/pta/pta_soc_info.c
new file mode 100644
index 00000000..abf12fc2
--- /dev/null
+++ b/core/arch/arm/plat-imx/pta/pta_soc_info.c
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright 2020 NXP
+ *
+ * PTA SoC info
+ */
+#include <imx.h>
+#include <kernel/pseudo_ta.h>
+#include <tee_api_types.h>
+
+#define PTA_SOC_INFO_NAME "soc_info.pta"
+#define PTA_SOC_INFO_UUID                                                      \
+	{                                                                      \
+		0x6e4afaee, 0xd000, 0x11ea,                                    \
+		{                                                              \
+			0x87, 0xd0, 0x02, 0x42, 0xac, 0x13, 0x00, 0x03         \
+		}                                                              \
+	}
+
+#define PTA_SOC_INFO_DIGPROG 0
+
+/*
+ * Command PTA_SOC_INFO_DIGPROG function.
+ * Expected parameters:
+ *       params[0] (TEE_PARAM_TYPE_VALUE_OUTPUT)
+ *            .a = digprog register value
+ *
+ * @param_types    TEE parameter types
+ * @params         TEE parameters
+ */
+static TEE_Result soc_digprog(uint32_t param_types,
+			       TEE_Param params[TEE_NUM_PARAMS])
+{
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_OUTPUT,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE,
+				TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	params[0].value.a = imx_soc_digprog();
+
+	return TEE_SUCCESS;
+}
+
+/*
+ * Invoke PTA command.
+ *
+ * @sess_ctx       session context
+ * @cmd_id         command ID
+ * @param_types    TEE parameter types
+ * @params         TEE parameters
+ */
+static TEE_Result invoke_command(void *sess_ctx __unused, uint32_t cmd_id,
+				 uint32_t param_types,
+				 TEE_Param params[TEE_NUM_PARAMS])
+{
+	switch (cmd_id) {
+	case PTA_SOC_INFO_DIGPROG:
+		return soc_digprog(param_types, params);
+	default:
+		return TEE_ERROR_NOT_SUPPORTED;
+	}
+}
+
+/*
+ * Open PTA session.
+ *
+ * @param_types    TEE parameter types
+ * @params         TEE parameters
+ * @sess_ctx       session context
+ */
+static TEE_Result open_session(uint32_t param_types __unused,
+			       TEE_Param params[TEE_NUM_PARAMS] __unused,
+			       void **sess_ctx __unused)
+{
+	/* Only a TA can invoke this PTA */
+	if (!tee_ta_get_calling_session())
+		return TEE_ERROR_ACCESS_DENIED;
+
+	return TEE_SUCCESS;
+}
+
+pseudo_ta_register(.uuid = PTA_SOC_INFO_UUID, .name = PTA_SOC_INFO_NAME,
+		   .flags = PTA_DEFAULT_FLAGS,
+		   .open_session_entry_point = open_session,
+		   .invoke_command_entry_point = invoke_command);
diff --git a/core/arch/arm/plat-imx/pta/sub.mk b/core/arch/arm/plat-imx/pta/sub.mk
index fc415a2d..626276b6 100644
--- a/core/arch/arm/plat-imx/pta/sub.mk
+++ b/core/arch/arm/plat-imx/pta/sub.mk
@@ -1,4 +1,6 @@
 srcs-$(CFG_MANUFACT_PROTEC_PTA) += pta_manufact_protec_mx.c
 srcs-$(CFG_BLOB_PTA) += pta_blob_mx.c
 srcs-$(CFG_BK_PTA) += pta_bk_mx.c
-srcs-$(CFG_OCOTP_PTA) += pta_ocotp_mx.c
\ No newline at end of file
+srcs-$(CFG_OCOTP_PTA) += pta_ocotp_mx.c
+srcs-$(CFG_PTA_SOC_INFO) += pta_soc_info.c
+
-- 
2.25.1


From 47bcad7478a9578303e163fb833f4752bc772662 Mon Sep 17 00:00:00 2001
From: Silvano di Ninno <silvano.dininno@nxp.com>
Date: Mon, 3 Aug 2020 16:42:59 +0200
Subject: [PATCH 05/22] libutil: io_clrsetbitsX() firends for 8bit and 16bit
 accesses

    Introduce io_setbits8(), io_clrbits8(), io_clrsetbits8() and
    io_setbits16(), io_clrbits16(), io_clrsetbits16() for bit clear/set
    util over 8bit and 16bit memory cells on the model of existing
    io_clrsetbits32() and friends.

    Signed-off-by: Etienne Carriere <etienne.carriere@linaro.org>
    Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>
---
 core/include/io.h | 58 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/core/include/io.h b/core/include/io.h
index 8e81f429..b7aaa028 100644
--- a/core/include/io.h
+++ b/core/include/io.h
@@ -54,6 +54,64 @@ static inline void io_mask32(vaddr_t addr, uint32_t val, uint32_t mask)
 	write32((read32(addr) & ~mask) | (val & mask), addr);
 }
 
+/*
+ * Set and clear bits helpers.
+ *
+ * @addr is the address of the memory cell accessed
+ * @set_mask represents the bit mask of the bit(s) to set, aka set to 1
+ * @clear_mask represents the bit mask of the bit(s) to clear, aka reset to 0
+ *
+ * io_clrsetbits32() clears then sets the target bits in this order. If a bit
+ * position is defined by both @set_mask and @clear_mask, the bit will be set.
+ */
+static inline void io_setbits32(vaddr_t addr, uint32_t set_mask)
+{
+	write32(read32(addr) | set_mask, addr);
+}
+
+static inline void io_clrbits32(vaddr_t addr, uint32_t clear_mask)
+{
+	write32(read32(addr) & ~clear_mask, addr);
+}
+
+static inline void io_clrsetbits32(vaddr_t addr, uint32_t clear_mask,
+				   uint32_t set_mask)
+{
+	write32((read32(addr) & ~clear_mask) | set_mask, addr);
+}
+
+static inline void io_setbits16(vaddr_t addr, uint16_t set_mask)
+{
+	write16(read16(addr) | set_mask, addr);
+}
+
+static inline void io_clrbits16(vaddr_t addr, uint16_t clear_mask)
+{
+	write16(read16(addr) & ~clear_mask, addr);
+}
+
+static inline void io_clrsetbits16(vaddr_t addr, uint16_t clear_mask,
+				   uint16_t set_mask)
+{
+	write16((read16(addr) & ~clear_mask) | set_mask, addr);
+}
+
+static inline void io_setbits8(vaddr_t addr, uint8_t set_mask)
+{
+	write8(read8(addr) | set_mask, addr);
+}
+
+static inline void io_clrbits8(vaddr_t addr, uint8_t clear_mask)
+{
+	write8(read8(addr) & ~clear_mask, addr);
+}
+
+static inline void io_clrsetbits8(vaddr_t addr, uint8_t clear_mask,
+				  uint8_t set_mask)
+{
+	write8((read8(addr) & ~clear_mask) | set_mask, addr);
+}
+
 static inline uint64_t get_be64(const void *p)
 {
 	return TEE_U64_FROM_BIG_ENDIAN(*(const uint64_t *)p);
-- 
2.25.1


From d6a510e987813476ba42d38f9cd977c5b1f9d783 Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Tue, 21 Jul 2020 11:30:14 +0200
Subject: [PATCH 06/22] TEE-571 imx: add CRM registers for imx8m platforms

Add CRM registers.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/arch/arm/plat-imx/registers/imx8m-crm.h  | 32 +++++++++++++++++++
 .../arch/arm/plat-imx/registers/imx8mm-regs.h | 14 ++++----
 2 files changed, 40 insertions(+), 6 deletions(-)
 create mode 100644 core/arch/arm/plat-imx/registers/imx8m-crm.h

diff --git a/core/arch/arm/plat-imx/registers/imx8m-crm.h b/core/arch/arm/plat-imx/registers/imx8m-crm.h
new file mode 100644
index 00000000..e7691e5e
--- /dev/null
+++ b/core/arch/arm/plat-imx/registers/imx8m-crm.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright 2017-2020 NXP
+ */
+#ifndef __IMX8M_CRM_H__
+#define __IMX8M_CRM_H__
+
+#include <util.h>
+
+/*
+ * CCGRx Registers (Clock Gating)
+ */
+#define CCM_CCGR0	   0x4000
+#define CCM_CCGRx_OFFSET   0x10
+#define CCM_CCGRx(idx)	   (((idx) * (CCM_CCGRx_OFFSET)) + CCM_CCGR0)
+#define CCM_CCGRx_SET(idx) (CCM_CCGRx(idx) + 0x4)
+#define CCM_CCGRx_CLR(idx) (CCM_CCGRx(idx) + 0x8)
+#define CCM_CCGRx_TOG(idx) (CCM_CCGRx(idx) + 0xC)
+
+#define BS_CCM_CCGRx_SETTING(idx) ((idx) * (4))
+#define BM_CCM_CCGRx_SETTING(idx) SHIFT_U32(0x3, BS_CCM_CCGRx_SETTING(idx))
+#define CCM_CCGRx_DISABLE(idx)	  SHIFT_U32(0, BS_CCM_CCGRx_SETTING(idx))
+#define CCM_CCGRx_RUN(idx)	  BIT32(BS_CCM_CCGRx_SETTING(idx))
+#define CCM_CCGRx_RUN_WAIT(idx)	  SHIFT_U32(0x2, BS_CCM_CCGRx_SETTING(idx))
+#define CCM_CCGRx_ALWAYS_ON(idx)  SHIFT_U32(0x3, BS_CCM_CCGRx_SETTING(idx))
+
+/*
+ * Clock Domain ID
+ */
+#define CCM_CLOCK_DOMAIN_OCOTP 34
+
+#endif /* __IMX8M_CRM_H__ */
diff --git a/core/arch/arm/plat-imx/registers/imx8mm-regs.h b/core/arch/arm/plat-imx/registers/imx8mm-regs.h
index 8f75cd3b..fd485d11 100644
--- a/core/arch/arm/plat-imx/registers/imx8mm-regs.h
+++ b/core/arch/arm/plat-imx/registers/imx8mm-regs.h
@@ -4,8 +4,9 @@
  *
  */
 
-#ifndef __IMX8_REGS_H__
-#define __IMX8_REGS_H__
+#ifndef __IMX8MM_REGS_H__
+#define __IMX8MM_REGS_H__
+#include <registers/imx8m-crm.h>
 
 #define GICD_BASE	0x38800000
 #define GICR_BASE	0x38880000
@@ -15,8 +16,9 @@
 #define UART4_BASE	0x30A60000
 #define TZASC_BASE	0x32F80000
 #define CAAM_BASE	0x30900000
-#define OCOTP_BASE  0x30350000
-#define ANATOP_BASE 0x30360000
-#define SNVS_BASE   0x30370000
+#define OCOTP_BASE  	0x30350000
+#define ANATOP_BASE 	0x30360000
+#define SNVS_BASE   	0x30370000
+#define CCM_BASE	0x30380000
 
-#endif /* __IMX8_REGS_H__ */
+#endif /* __IMX8MM_REGS_H__ */
-- 
2.25.1


From 31256d3847d56e25482932e963acb56bbc8011f6 Mon Sep 17 00:00:00 2001
From: Silvano di Ninno <silvano.dininno@nxp.com>
Date: Mon, 3 Aug 2020 16:38:19 +0200
Subject: [PATCH 07/22] TEE-571 arm:imx: update OCOTP driver

Add OCOTP driver for imx8mm platform.
Implement the read of shadow registers only, no write.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
Signed-off-by: Silvano di Ninno <silvano.dininno@nxp.com>
---
 core/arch/arm/plat-imx/imx_ocotp.c | 119 ++++++++++++++++++++++++++++-
 core/arch/arm/plat-imx/imx_ocotp.h |  20 +++++
 2 files changed, 137 insertions(+), 2 deletions(-)
 create mode 100644 core/arch/arm/plat-imx/imx_ocotp.h

diff --git a/core/arch/arm/plat-imx/imx_ocotp.c b/core/arch/arm/plat-imx/imx_ocotp.c
index 70c1763c..3963b960 100644
--- a/core/arch/arm/plat-imx/imx_ocotp.c
+++ b/core/arch/arm/plat-imx/imx_ocotp.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: BSD-2-Clause
 /**
- * @copyright 2019 NXP
+ * @copyright 2020 NXP
  *
  * @file    imx_ocotp.c
  *
@@ -8,16 +8,131 @@
  */
 
 /* Global includes */
+#include <initcall.h>
+#include <kernel/delay.h>
 #include <kernel/panic.h>
 #include <kernel/tee_common_otp.h>
-#include <mm/core_mmu.h>
 #include <mm/core_memprot.h>
+#include <mm/core_mmu.h>
 
 /* Platform includes */
 #include <imx.h>
+#include <imx_ocotp.h>
+
+#define OCOTP_CTRL	 0x0
+#define OCOTP_CTRL_ERROR BIT32(9)
+#define OCOTP_CTRL_BUSY	 BIT32(8)
+
+struct ocotp_instance {
+	vaddr_t base;
+	uint8_t nb_banks;
+	uint8_t nb_words;
+};
+
+static struct ocotp_instance ocotp_imx8m = {
+	.nb_banks = 14,
+	.nb_words = 4,
+};
 
 static uint64_t die_id;
 
+static struct ocotp_instance *g_ocotp;
+
+static void ocotp_clk_enable(bool enable)
+{
+	vaddr_t va = core_mmu_get_va(CCM_BASE, MEM_AREA_IO_SEC);
+
+	if (enable)
+		io_setbits32(va + CCM_CCGRx_SET(CCM_CLOCK_DOMAIN_OCOTP),
+			     CCM_CCGRx_ALWAYS_ON(0));
+	else
+		io_setbits32(va + CCM_CCGRx_CLR(CCM_CLOCK_DOMAIN_OCOTP),
+			     CCM_CCGRx_DISABLE(0));
+}
+
+static uint32_t shadow_offset(uint8_t bank, uint8_t word)
+{
+	return (bank * 0x40) + (word * 0x10) + 0x400;
+}
+
+static int ocotp_ctrl_wait_for(uint32_t mask)
+{
+	int timeout = 0;
+	uint32_t reg = 0;
+
+	for (timeout = 100; timeout >= 0; timeout--) {
+		reg = read32(g_ocotp->base + OCOTP_CTRL);
+		if (!(reg & mask))
+			break;
+		mdelay(10);
+	}
+
+	if (timeout < 0)
+		return TEE_ERROR_BUSY;
+
+	return TEE_SUCCESS;
+}
+
+TEE_Result imx_ocotp_read(uint8_t bank, uint8_t word, uint32_t *val)
+{
+	TEE_Result ret = TEE_ERROR_GENERIC;
+
+	if (!g_ocotp)
+		return TEE_ERROR_GENERIC;
+
+	if (bank > g_ocotp->nb_banks || word > g_ocotp->nb_words) {
+		EMSG("Bank/word out of range");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ocotp_clk_enable(true);
+
+	/* If error, must be cleared before any further access */
+	io_clrbits32(g_ocotp->base + OCOTP_CTRL, OCOTP_CTRL_ERROR);
+
+	/* Wait for busy flag to be cleared */
+	ret = ocotp_ctrl_wait_for(OCOTP_CTRL_BUSY);
+	if (ret)
+		return ret;
+
+	/* Read shadow register */
+	*val = read32(g_ocotp->base + shadow_offset(bank, word));
+
+	/* Check if shadow register read is locked */
+	if (*val == 0xBADABADA) {
+		EMSG("Shadow register read denied");
+		return TEE_ERROR_ACCESS_DENIED;
+	}
+
+	DMSG("OCOTP Bank %d Word %d Fuse 0x%" PRIx32, bank, word, *val);
+
+	return TEE_SUCCESS;
+}
+
+static TEE_Result imx_ocotp_init(void)
+{
+	vaddr_t va = 0;
+	TEE_Result ret = TEE_ERROR_GENERIC;
+
+	ocotp_clk_enable(true);
+
+	va = core_mmu_get_va(OCOTP_BASE, MEM_AREA_IO_SEC);
+	if (!va)
+		return TEE_ERROR_GENERIC;
+
+	if (soc_is_imx8mm()) {
+		g_ocotp = &ocotp_imx8m;
+		g_ocotp->base = va;
+		ret = TEE_SUCCESS;
+	} else {
+		g_ocotp = NULL;
+		ret = TEE_ERROR_NOT_SUPPORTED;
+	}
+
+	return ret;
+}
+driver_init(imx_ocotp_init);
+
 /**
  * @brief   Read device Die Id
  *
diff --git a/core/arch/arm/plat-imx/imx_ocotp.h b/core/arch/arm/plat-imx/imx_ocotp.h
new file mode 100644
index 00000000..e5f34c17
--- /dev/null
+++ b/core/arch/arm/plat-imx/imx_ocotp.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright 2020 NXP
+ */
+
+#ifndef _IMX_OCOTP_H
+#define _IMX_OCOTP_H
+
+#include <tee_api_types.h>
+
+/*
+ * Read OCOTP shadow register
+ *
+ * @base     Fuse bank number
+ * @index    Fuse word number
+ * @[out]val Shadow register value
+ */
+TEE_Result imx_ocotp_read(uint8_t bank, uint8_t word, uint32_t *val);
+
+#endif /* _IMX_OCOTP_H */
-- 
2.25.1


From 2042a9356f08452e1835eaa860d5d63f029ba258 Mon Sep 17 00:00:00 2001
From: Silvano di Ninno <silvano.dininno@nxp.com>
Date: Mon, 3 Aug 2020 17:20:26 +0200
Subject: [PATCH 08/22] TEE-571 imx: pta: update OCOTP PTA

Expose OCOTP driver functions.
Implement fuse read.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
Signed-off-by: Silvano di Ninno <silvano.dininno@nxp.com>
---
 core/arch/arm/plat-imx/pta/pta_ocotp_mx.c | 34 +++++++++++++++++++++++
 lib/libutee/include/pta_ocotp.h           |  4 +++
 2 files changed, 38 insertions(+)

diff --git a/core/arch/arm/plat-imx/pta/pta_ocotp_mx.c b/core/arch/arm/plat-imx/pta/pta_ocotp_mx.c
index e6ca0c06..67149c3c 100644
--- a/core/arch/arm/plat-imx/pta/pta_ocotp_mx.c
+++ b/core/arch/arm/plat-imx/pta/pta_ocotp_mx.c
@@ -25,6 +25,8 @@
 /* Global includes */
 #include <tee_api_defines.h>
 
+#include <imx_ocotp.h>
+
 /** @brief    PTA name */
 #define OCOTP_PTA_NAME "ocotp.pta"
 
@@ -85,6 +87,36 @@ static TEE_Result chip_uid(uint32_t param_types,
 	return TEE_SUCCESS;
 }
 
+/*
+ * Command PTA_OCOTP_READ_FUSE function.
+ * Expected parameters:
+ *       params[0] (TEE_PARAM_TYPE_VALUE_INPUT)
+ *            .a = OCOTP fuse bank
+ *            .b = OCOTP fuse word
+ *       params[1] (TEE_PARAM_TYPE_VALUE_OUTPUT)
+ *            .a = fuse value
+ *            .b = 0
+ *
+ * @param_types    TEE parameter types
+ * @params         TEE parameters
+ */
+static TEE_Result read_fuse(uint32_t param_types,
+			    TEE_Param params[TEE_NUM_PARAMS])
+{
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+				TEE_PARAM_TYPE_VALUE_OUTPUT,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types)
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	params[1].value.b = 0;
+	return imx_ocotp_read(params[0].value.a, params[0].value.b,
+			      &params[1].value.a);
+}
+
+
 /**
  * @brief   Called when a pseudo TA is invoked.
  *
@@ -107,6 +139,8 @@ static TEE_Result invokeCommandEntryPoint(void *sess_ctx __unused,
 	switch (cmd_id) {
 	case PTA_OCOTP_CMD_CHIP_UID:
 		return chip_uid(param_types, params);
+	case PTA_OCOTP_READ_FUSE:
+		return read_fuse(param_types, params);
 	default:
 		return TEE_ERROR_BAD_PARAMETERS;
 	}
diff --git a/lib/libutee/include/pta_ocotp.h b/lib/libutee/include/pta_ocotp.h
index 7ed86b9f..10b118ec 100644
--- a/lib/libutee/include/pta_ocotp.h
+++ b/lib/libutee/include/pta_ocotp.h
@@ -23,5 +23,9 @@
  */
 #define PTA_OCOTP_CMD_CHIP_UID 1
 
+/**
+ * @brief   Read OCOTP fuses
+ */
+#define PTA_OCOTP_READ_FUSE 2
 
 #endif /* __PTA_OCOTP_H__ */
-- 
2.25.1


From bfd72c2a9cd549850178eb46db1b42b6bedb84c0 Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Fri, 7 Aug 2020 14:48:16 +0200
Subject: [PATCH 09/22] Add imxcrypt_key object in the crypto API

This object is needed for future black key support in CAAM driver.
imxcrypt_key is wrapper around imxcryptbuf with a field to specify the
key type and a field for the key original size in case the key is a
black key.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 .../libimxcrypt/crypto_api/cipher/cipher.c    | 12 ++++++----
 .../crypto_api/include/crypto_extension.h     |  8 ++++++-
 .../crypto_api/include/libimxcrypt.h          |  3 ++-
 .../crypto_api/include/libimxcrypt_cipher.h   |  5 ++--
 core/lib/libimxcrypt/crypto_api/mac/mac.c     | 24 ++++++++++++-------
 5 files changed, 36 insertions(+), 16 deletions(-)

diff --git a/core/lib/libimxcrypt/crypto_api/cipher/cipher.c b/core/lib/libimxcrypt/crypto_api/cipher/cipher.c
index 85fb39d7..287ff3fc 100644
--- a/core/lib/libimxcrypt/crypto_api/cipher/cipher.c
+++ b/core/lib/libimxcrypt/crypto_api/cipher/cipher.c
@@ -230,10 +230,14 @@ TEE_Result crypto_cipher_init(void *ctx, uint32_t algo,
 			dinit.algo        = cipher_id;
 			dinit.encrypt     = ((mode == TEE_MODE_ENCRYPT) ?
 						true : false);
-			dinit.key1.data   = (uint8_t *)key1;
-			dinit.key1.length = key1_len;
-			dinit.key2.data   = (uint8_t *)key2;
-			dinit.key2.length = key2_len;
+			dinit.key1.buf.data   = (uint8_t *)key1;
+			dinit.key1.buf.length = key1_len;
+			dinit.key1.type = PLAIN_TEXT;
+			dinit.key1.size = key1_len;
+			dinit.key2.buf.data   = (uint8_t *)key2;
+			dinit.key2.buf.length = key2_len;
+			dinit.key2.type = PLAIN_TEXT;
+			dinit.key2.size = key2_len;
 			dinit.iv.data     = (uint8_t *)iv;
 			dinit.iv.length   = iv_len;
 			ret = cipher->init(&dinit);
diff --git a/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h b/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
index 42661219..a06f1db2 100644
--- a/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
+++ b/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
@@ -174,4 +174,10 @@ TEE_Result bk_sign(enum imxcrypt_algo_id alg, enum bk_type type,
 
 #endif // _CFG_CRYPTO_WITH_BK
 
-#endif /* __CRYPTO_EXTENSION_H */
\ No newline at end of file
+struct imxcrypt_key {
+	enum bk_type type;
+	struct imxcrypt_buf buf;
+	size_t size;
+};
+
+#endif /* __CRYPTO_EXTENSION_H */
diff --git a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt.h b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt.h
index f4e49417..541af895 100644
--- a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt.h
+++ b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt.h
@@ -58,6 +58,7 @@ enum blob_type {
  * @brief Key encryption type
  */
 enum bk_type {
+	PLAIN_TEXT,
 	BK_ECB,      ///< Black key mode - data encrypted in AES ECB
 	BK_CCM,      ///< Black key mode - data encrypted in AES CCM
 	BK_MAX_TYPE   ///< Maximum number of blob type supported
@@ -145,4 +146,4 @@ TEE_Result imxcrypt_libsoft_init(void);
  */
 TEE_Result crypto_driver_init(void);
 
-#endif /* __LIBIMXCRYPT_H__ */
\ No newline at end of file
+#endif /* __LIBIMXCRYPT_H__ */
diff --git a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_cipher.h b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_cipher.h
index d2df909a..5748217e 100644
--- a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_cipher.h
+++ b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_cipher.h
@@ -10,6 +10,7 @@
 #ifndef __LIBIMXCRYPT_CIPHER_H__
 #define __LIBIMXCRYPT_CIPHER_H__
 
+#include <crypto_extension.h>
 #include <tee_api_types.h>
 #include <util.h>
 
@@ -61,8 +62,8 @@ struct imxcrypt_cipher_init {
 	void                 *ctx;     ///< Software Context
 	enum imxcrypt_cipher_id algo;  ///< Cipher Algorithm id
 	bool                 encrypt;  ///< Encrypt or decrypt direction
-	struct imxcrypt_buf  key1;     ///< First Key
-	struct imxcrypt_buf  key2;     ///< Second Key
+	struct imxcrypt_key  key1;     ///< First Key
+	struct imxcrypt_key  key2;     ///< Second Key
 	struct imxcrypt_buf  iv;       ///< Initial Vector
 };
 
diff --git a/core/lib/libimxcrypt/crypto_api/mac/mac.c b/core/lib/libimxcrypt/crypto_api/mac/mac.c
index 90e51438..8afb309d 100644
--- a/core/lib/libimxcrypt/crypto_api/mac/mac.c
+++ b/core/lib/libimxcrypt/crypto_api/mac/mac.c
@@ -412,10 +412,14 @@ TEE_Result crypto_mac_init(void *ctx, uint32_t algo,
 		dinit.ctx         = cbc_ctx->ctx;
 		dinit.algo        = cipher_id;
 		dinit.encrypt     = true;
-		dinit.key1.data   = (uint8_t *)key;
-		dinit.key1.length = key_len;
-		dinit.key2.data   = NULL;
-		dinit.key2.length = 0;
+		dinit.key1.buf.data   = (uint8_t *)key;
+		dinit.key1.buf.length = key_len;
+		dinit.key1.type = PLAIN_TEXT;
+		dinit.key1.size = key_len;
+		dinit.key2.buf.data   = NULL;
+		dinit.key2.buf.length = 0;
+		dinit.key2.type = PLAIN_TEXT;
+		dinit.key2.size = 0;
 		dinit.iv.data     = iv_tmp;
 		dinit.iv.length   = cbc_ctx->sizeblock;
 		ret = cipher->init(&dinit);
@@ -433,10 +437,14 @@ TEE_Result crypto_mac_init(void *ctx, uint32_t algo,
 			dinit.ctx         = ctx;
 			dinit.algo        = cipher_id;
 			dinit.encrypt     = true;
-			dinit.key1.data   = (uint8_t *)key;
-			dinit.key1.length = key_len;
-			dinit.key2.data   = NULL;
-			dinit.key2.length = 0;
+			dinit.key1.buf.data   = (uint8_t *)key;
+			dinit.key1.buf.length = key_len;
+			dinit.key1.type = PLAIN_TEXT;
+			dinit.key1.size = key_len;
+			dinit.key2.buf.data   = NULL;
+			dinit.key2.buf.length = 0;
+			dinit.key2.type = PLAIN_TEXT;
+			dinit.key2.size = 0;
 			dinit.iv.data     = NULL;
 			dinit.iv.length   = 0;
 			ret = cipher->init(&dinit);
-- 
2.25.1


From b9de88fde23ec4ad638becdf81df66f48d45aead Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Fri, 7 Aug 2020 14:48:06 +0200
Subject: [PATCH 10/22] Add black key support to CAAM cipher

Modify the KEY command to support the loading of black key encrypted
with AES-ECB/CCM.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/drivers/caam/cipher/caam_cipher.c      | 78 +++++++++++++++------
 core/drivers/caam/cipher/caam_cipher_cmac.c | 16 ++++-
 core/drivers/caam/cipher/include/local.h    |  5 +-
 core/drivers/caam/include/caam_key.h        | 21 ++++++
 core/drivers/caam/include/desc_defines.h    |  9 +++
 core/drivers/caam/include/desc_helper.h     | 10 +++
 6 files changed, 112 insertions(+), 27 deletions(-)
 create mode 100644 core/drivers/caam/include/caam_key.h

diff --git a/core/drivers/caam/cipher/caam_cipher.c b/core/drivers/caam/cipher/caam_cipher.c
index 5b01c04c..743c26ba 100644
--- a/core/drivers/caam/cipher/caam_cipher.c
+++ b/core/drivers/caam/cipher/caam_cipher.c
@@ -22,6 +22,7 @@
 #include "common.h"
 #include "caam_cipher.h"
 #include "caam_jr.h"
+#include "caam_key.h"
 #include "local.h"
 
 /* Utils includes */
@@ -263,12 +264,34 @@ enum CAAM_Status do_block(struct cipherdata *ctx,
 
 	if (keyid == NEED_KEY1) {
 		/* Build the descriptor */
-		desc[desclen++] = LD_KEY_PLAIN(CLASS_1, REG, ctx->key1.length);
-		desc[desclen++] = ctx->key1.paddr;
+		if (ctx->key1.type == PLAIN_TEXT)
+			desc[desclen++] = LD_KEY_PLAIN(CLASS_1, REG,
+						       ctx->key1.size);
+		else if (ctx->key1.type == BK_ECB)
+			desc[desclen++] = LD_KEY_ENC(CLASS_1, REG,
+						       ctx->key1.size, ECB);
+		else if (ctx->key1.type == BK_CCM)
+			desc[desclen++] = LD_KEY_ENC(CLASS_1, REG,
+						       ctx->key1.size, CCM);
+		else
+			return CAAM_BAD_PARAM;
+
+		desc[desclen++] = ctx->key1.buf.paddr;
 	} else if (keyid == NEED_KEY2) {
 		/* Build the descriptor */
-		desc[desclen++] = LD_KEY_PLAIN(CLASS_1, REG, ctx->key2.length);
-		desc[desclen++] = ctx->key2.paddr;
+		if (ctx->key2.type == PLAIN_TEXT)
+			desc[desclen++] = LD_KEY_PLAIN(CLASS_1, REG,
+						       ctx->key2.size);
+		else if (ctx->key2.type == BK_ECB)
+			desc[desclen++] = LD_KEY_ENC(CLASS_1, REG,
+						       ctx->key2.size, ECB);
+		else if (ctx->key2.type == BK_CCM)
+			desc[desclen++] = LD_KEY_ENC(CLASS_1, REG,
+						       ctx->key2.size, CCM);
+		else
+			return CAAM_BAD_PARAM;
+
+		desc[desclen++] = ctx->key2.buf.paddr;
 	}
 
 	/* If there is a context register load it */
@@ -452,10 +475,10 @@ static void do_free_intern(struct cipherdata *ctx)
 		caam_free_desc(&ctx->descriptor);
 
 		/* Free the Key 1  */
-		caam_free_buf(&ctx->key1);
+		caam_free_buf(&ctx->key1.buf);
 
 		/* Free the Key 2  */
-		caam_free_buf(&ctx->key2);
+		caam_free_buf(&ctx->key2.buf);
 
 		/* Free the Tweak */
 		caam_free_buf(&ctx->tweak);
@@ -510,18 +533,22 @@ static void do_cpy_state(void *dst_ctx, void *src_ctx)
 		caam_cpy_block_src(&dst->blockbuf, &srcdata, 0);
 	}
 
-	if (src->key1.length) {
+	if (src->key1.buf.length) {
 		struct imxcrypt_buf key1 = {
-				.data   = src->key1.data,
-				.length = src->key1.length};
-		copy_ctx_data(&dst->key1, &key1);
+				.data   = src->key1.buf.data,
+				.length = src->key1.buf.length};
+		copy_ctx_data(&dst->key1.buf, &key1);
+		dst->key1.type = src->key1.type;
+		dst->key1.size = src->key1.size;
 	}
 
-	if (src->key2.length) {
+	if (src->key2.buf.length) {
 		struct imxcrypt_buf key2 = {
-				.data   = src->key2.data,
-				.length = src->key2.length};
-		copy_ctx_data(&dst->key2, &key2);
+				.data   = src->key2.buf.data,
+				.length = src->key2.buf.length};
+		copy_ctx_data(&dst->key2.buf, &key2);
+		dst->key2.type = src->key2.type;
+		dst->key2.size = src->key2.size;
 	}
 
 	if (src->ctx.length) {
@@ -609,17 +636,21 @@ static TEE_Result do_init(struct imxcrypt_cipher_init *dinit)
 
 	/* Check if all required keys are defined */
 	if (alg->require_key & NEED_KEY1) {
-		if ((!dinit->key1.data) || (dinit->key1.length == 0))
+		if ((!dinit->key1.buf.data) || (dinit->key1.buf.length == 0))
 			goto exit_init;
 
-		if (do_check_keysize(&alg->def_key, dinit->key1.length) !=
-			CAAM_NO_ERROR) {
+		/* Check size only if the key is plain text */
+		if (do_check_keysize(&alg->def_key, dinit->key1.size) !=
+		    CAAM_NO_ERROR) {
 			CIPHER_TRACE("Bad Key 1 size");
 			goto exit_init;
 		}
 
+		cipherdata->key1.size = dinit->key1.size;
+		cipherdata->key1.type = dinit->key1.type;
+
 		/* Copy the key 1 */
-		retstatus = copy_ctx_data(&cipherdata->key1, &dinit->key1);
+		retstatus = copy_ctx_data(&cipherdata->key1.buf, &dinit->key1.buf);
 		CIPHER_TRACE("Copy Key 1 returned %d", retstatus);
 
 		if (retstatus != CAAM_NO_ERROR) {
@@ -629,17 +660,20 @@ static TEE_Result do_init(struct imxcrypt_cipher_init *dinit)
 	}
 
 	if (alg->require_key & NEED_KEY2) {
-		if ((!dinit->key2.data) || (dinit->key2.length == 0))
+		if ((!dinit->key2.buf.data) || (dinit->key2.buf.length == 0))
 			goto exit_init;
 
-		if (do_check_keysize(&alg->def_key, dinit->key2.length) !=
-			CAAM_NO_ERROR) {
+		if (do_check_keysize(&alg->def_key, dinit->key2.size) !=
+		    CAAM_NO_ERROR) {
 			CIPHER_TRACE("Bad Key 2 size");
 			goto exit_init;
 		}
 
+		cipherdata->key2.size = dinit->key2.size;
+		cipherdata->key2.type = dinit->key2.type;
+
 		/* Copy the key 2 */
-		retstatus = copy_ctx_data(&cipherdata->key2, &dinit->key2);
+		retstatus = copy_ctx_data(&cipherdata->key2.buf, &dinit->key2.buf);
 		CIPHER_TRACE("Copy Key 2 returned %d", retstatus);
 
 		if (retstatus != CAAM_NO_ERROR) {
diff --git a/core/drivers/caam/cipher/caam_cipher_cmac.c b/core/drivers/caam/cipher/caam_cipher_cmac.c
index 1c7cd253..d97dc313 100644
--- a/core/drivers/caam/cipher/caam_cipher_cmac.c
+++ b/core/drivers/caam/cipher/caam_cipher_cmac.c
@@ -112,9 +112,19 @@ TEE_Result do_update_cmac(struct imxcrypt_cipher_update *dupdate)
 
 		if (ctx->alg->require_key & NEED_KEY1) {
 			/* Build the descriptor */
-			desc[desclen++] = LD_KEY_PLAIN(CLASS_1, REG,
-				ctx->key1.length);
-			desc[desclen++] = ctx->key1.paddr;
+			if (ctx->key1.type == PLAIN_TEXT)
+				desc[desclen++] = LD_KEY_PLAIN(CLASS_1, REG,
+							ctx->key1.size);
+			else if (ctx->key1.type == BK_ECB)
+				desc[desclen++] = LD_KEY_ENC(CLASS_1, REG,
+							ctx->key1.size, ECB);
+			else if (ctx->key1.type == BK_CCM)
+				desc[desclen++] = LD_KEY_ENC(CLASS_1, REG,
+							ctx->key1.size, CCM);
+			else
+				return CAAM_BAD_PARAM;
+
+			desc[desclen++] = ctx->key1.buf.paddr;
 		}
 
 		/* If context already allocated, this is an update */
diff --git a/core/drivers/caam/cipher/include/local.h b/core/drivers/caam/cipher/include/local.h
index 9225f12a..c92754f0 100644
--- a/core/drivers/caam/cipher/include/local.h
+++ b/core/drivers/caam/cipher/include/local.h
@@ -12,6 +12,7 @@
 /* Library i.MX includes */
 #include <libimxcrypt.h>
 #include <libimxcrypt_cipher.h>
+#include <caam_key.h>
 
 /*
  * Debug Macros
@@ -72,8 +73,8 @@ struct cipheralg {
 struct cipherdata {
 	descPointer_t descriptor;        ///< Job descriptor
 
-	struct caambuf key1;             ///< First Key
-	struct caambuf key2;             ///< Second Key
+	struct caamkey key1;             ///< First Key
+	struct caamkey key2;             ///< Second Key
 
 	struct caambuf tweak;            ///< XTS Tweak
 
diff --git a/core/drivers/caam/include/caam_key.h b/core/drivers/caam/include/caam_key.h
new file mode 100644
index 00000000..f2b8473d
--- /dev/null
+++ b/core/drivers/caam/include/caam_key.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/**
+ * @copyright 2018-2020 NXP
+ *
+ * @file    caam_key.h
+ *
+ * @brief   CAAM Key header.
+ */
+#ifndef __CAAM_KEY_H__
+#define __CAAM_KEY_H__
+
+#include <common.h>
+#include <crypto_extension.h>
+
+
+struct caamkey {
+	struct caambuf buf;
+	enum bk_type type;
+	size_t size; // Original size of the key
+};
+#endif /* __CAAM_KEY_H__ */
diff --git a/core/drivers/caam/include/desc_defines.h b/core/drivers/caam/include/desc_defines.h
index a9b5d68d..9eb343a9 100644
--- a/core/drivers/caam/include/desc_defines.h
+++ b/core/drivers/caam/include/desc_defines.h
@@ -45,6 +45,15 @@
  */
 #define CMD_KEY_TYPE			CMD_TYPE(0x00)
 
+/* Encrypted Store */
+#define KEY_TK			BIT32(15)
+#define KEY_ENC			BIT32(22)
+
+/* Key encryption algorithm */
+#define KEY_EKT(val)		SHIFT_U32((KEY_EKT_##val) & 0x1, 20)
+#define KEY_EKT_ECB		0x0
+#define KEY_EKT_CCM		0x1
+
 /* Key Destination */
 #define KEY_DEST(val)			SHIFT_U32((KEY_DEST_##val & 0x3), 16)
 #define KEY_DEST_REG			0x0
diff --git a/core/drivers/caam/include/desc_helper.h b/core/drivers/caam/include/desc_helper.h
index 2406400b..dafbdd98 100644
--- a/core/drivers/caam/include/desc_helper.h
+++ b/core/drivers/caam/include/desc_helper.h
@@ -346,6 +346,16 @@ static inline void dump_desc(void *desc)
 			KEY_DEST(MDHA_SPLIT) | \
 			KEY_LENGTH(len))
 
+/*
+ * Load black key of length len to register dst.
+ * A black key is encrypted with JDKEK (AES-ECB/CCM)
+ * For black key, the Class 2 key must be loaded prior to the Class 1 register,
+ * and the Class 1 black keys must be loaded prior any resources.
+ */
+#define LD_KEY_ENC(cla, dst, len, alg)                                         \
+	(CMD_KEY_TYPE | CMD_CLASS(cla) | KEY_ENC | KEY_DEST(dst) |             \
+	 KEY_EKT(alg) | KEY_LENGTH(len))
+
 /**
  * @brief  MPPRIVK generation function.
  */
-- 
2.25.1


From 34010ff3fe87ee186f9ca4c583dc62efb64f9970 Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Tue, 4 Aug 2020 16:12:14 +0200
Subject: [PATCH 11/22] Add Cipher PTA with black key support

Add the Cipher PTA with black key support.
Implemented Cipher operations:
 * alloc
 * init
 * update
 * final
 * free

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/arch/arm/plat-imx/pta/pta_bk_mx.c | 228 ++++++++++++++++++++++++-
 lib/libutee/include/pta_bk.h           |  28 ++-
 2 files changed, 244 insertions(+), 12 deletions(-)

diff --git a/core/arch/arm/plat-imx/pta/pta_bk_mx.c b/core/arch/arm/plat-imx/pta/pta_bk_mx.c
index c0591353..9056fe02 100644
--- a/core/arch/arm/plat-imx/pta/pta_bk_mx.c
+++ b/core/arch/arm/plat-imx/pta/pta_bk_mx.c
@@ -24,6 +24,7 @@
 /* Library crypto includes */
 #include <crypto_extension.h>
 #include <libimxcrypt_bk.h>
+#include <libimxcrypt_cipher.h>
 
 /* Library crypto includes */
 #include <crypto/crypto.h>
@@ -40,6 +41,12 @@ struct attr_packed {
 	uint32_t b;
 };
 
+/*
+ * Cipher context
+ */
+static void *g_cipher_ctx;
+static uint32_t g_cipher_alg;
+
 static TEE_Result imxcrypt_buf_from_attr(struct imxcrypt_buf *buf,
 const TEE_Attribute *attrs, uint32_t attr_count)
 {
@@ -250,7 +257,209 @@ out:
 	return res;
 }
 
-/**
+/*
+ * Call the Cryptographic Extension API to allocate cipher context.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = Cipher algo ID (TEE_ALG_XXX)
+ *     params[0].value.b = 0
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result cipher_alloc(uint32_t param_types,
+			       TEE_Param params[TEE_NUM_PARAMS])
+{
+	uint32_t exp_param_types = 0;
+	struct imxcrypt_cipher *ops = NULL;
+
+	exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_NONE,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_CIPHER);
+	if (!ops || !ops->alloc_ctx) {
+		EMSG("Cannot get cipher ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	g_cipher_alg = params[0].value.a;
+
+	return ops->alloc_ctx(&g_cipher_ctx, params[0].value.a);
+}
+
+
+/*
+ * Call the Cryptographic Extension API to initialize cipher context.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = 0-1 (decryption-encryption)[31] |
+ *                         key type[3:0]
+ *     params[0].value.b = Key size[15:0]
+ *     params[1].memref  = Key
+ *     params[2].memref  = IV
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result cipher_init(uint32_t param_types,
+			       TEE_Param params[TEE_NUM_PARAMS])
+{
+	struct imxcrypt_cipher *ops = NULL;
+	struct imxcrypt_cipher_init dinit = {0};
+	uint32_t exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+						   TEE_PARAM_TYPE_MEMREF_INPUT,
+						   TEE_PARAM_TYPE_MEMREF_INPUT,
+						   TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	dinit.algo = g_cipher_alg;
+	dinit.ctx = g_cipher_ctx;
+	dinit.encrypt = CIPHER_INIT_CMD_ENCRYPT(params[0].value.a);
+
+	dinit.key1.buf.data = params[1].memref.buffer;
+	dinit.key1.buf.length = params[1].memref.size;
+	dinit.key1.type = CIPHER_INIT_CMD_KEY1_TYPE(params[0].value.a);
+	dinit.key1.size = CIPHER_INIT_CMD_KEY1_SIZE(params[0].value.b);
+
+	dinit.iv.data = params[2].memref.buffer;
+	dinit.iv.length = params[2].memref.size;
+
+	ops = imxcrypt_getmod(CRYPTO_CIPHER);
+	if (!ops || !ops->init) {
+		EMSG("Cannot get cipher ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	EMSG("CIPHER INIT");
+
+	return ops->init(&dinit);
+}
+
+/*
+ * Call the Cryptographic Extension API to update cipher operation.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = 0-1 (decryption-encryption)
+ *     params[0].value.b = 0-1 (not last block-last block)
+ *     params[1].memref  = input buffer
+ *     params[2].memref  = output buffer
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result cipher_update(uint32_t param_types,
+				    TEE_Param params[TEE_NUM_PARAMS])
+{
+	struct imxcrypt_cipher *ops = NULL;
+	struct imxcrypt_cipher_update dupdate = {0};
+	uint32_t exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+						   TEE_PARAM_TYPE_MEMREF_INPUT,
+						   TEE_PARAM_TYPE_MEMREF_INPUT,
+						   TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	dupdate.algo = g_cipher_alg;
+	dupdate.ctx = g_cipher_ctx;
+	dupdate.encrypt = params[0].value.a ? true : false;
+	dupdate.last = params[0].value.b ? true : false;
+	dupdate.src.data = params[1].memref.buffer;
+	dupdate.src.length = params[1].memref.size;
+	dupdate.dst.data = params[2].memref.buffer;
+	dupdate.dst.length = params[2].memref.size;
+
+	ops = imxcrypt_getmod(CRYPTO_CIPHER);
+	if (!ops || !ops->update) {
+		EMSG("Cannot get cipher ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	return ops->update(&dupdate);
+}
+
+/*
+ * Call the Cryptographic Extension API to finalize cipher operation.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = Cipher algo ID (TEE_ALG_XXX)
+ *     params[0].value.b = 0
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ */
+static TEE_Result cipher_final(uint32_t param_types,
+				   TEE_Param params[TEE_NUM_PARAMS])
+{
+	struct imxcrypt_cipher *ops = NULL;
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_NONE,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_CIPHER);
+	if (!ops || !ops->final) {
+		EMSG("Cannot get cipher ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	ops->final(g_cipher_ctx, params[0].value.a);
+
+	return TEE_SUCCESS;
+}
+
+/*
+ * Call the Cryptographic Extension API to free cipher context.
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result cipher_free(uint32_t param_types __unused,
+				  TEE_Param params[TEE_NUM_PARAMS] __unused)
+{
+	struct imxcrypt_cipher *ops = NULL;
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_CIPHER);
+	if (!ops || !ops->free_ctx) {
+		EMSG("Cannot get cipher ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	ops->free_ctx(g_cipher_ctx);
+
+	return TEE_SUCCESS;
+}
+
+	/**
  * @brief   Called when a pseudo TA is invoked.
  *
  * @param[in]  sess_ctx       Session Identifier
@@ -265,15 +474,26 @@ out:
  * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
  * @retval TEE_ERROR_GENERIC           Generic error
  */
-static TEE_Result invokeCommandEntryPoint(void *sess_ctx __unused,
-		uint32_t cmd_id, uint32_t param_types,
-		TEE_Param params[TEE_NUM_PARAMS])
+	static TEE_Result
+	invokeCommandEntryPoint(void *sess_ctx __unused, uint32_t cmd_id,
+				uint32_t param_types,
+				TEE_Param params[TEE_NUM_PARAMS])
 {
 	switch (cmd_id) {
 	case PTA_BK_CMD_ENCAPS:
 		return encapsulate(param_types, params);
 	case PTA_BK_CMD_SIGN:
 		return sign(param_types, params);
+	case PTA_BK_CMD_CIPHER_ALLOC:
+		return cipher_alloc(param_types, params);
+	case PTA_BK_CMD_CIPHER_INIT:
+		return cipher_init(param_types, params);
+	case PTA_BK_CMD_CIPHER_UPDATE:
+		return cipher_update(param_types, params);
+	case PTA_BK_CMD_CIPHER_FINAL:
+		return cipher_final(param_types, params);
+	case PTA_BK_CMD_CIPHER_FREE:
+		return cipher_free(param_types, params);
 	default:
 		return TEE_ERROR_BAD_PARAMETERS;
 	}
diff --git a/lib/libutee/include/pta_bk.h b/lib/libutee/include/pta_bk.h
index bebf283e..1c19ba08 100644
--- a/lib/libutee/include/pta_bk.h
+++ b/lib/libutee/include/pta_bk.h
@@ -16,15 +16,27 @@
 	0xf4557e21, 0xaa4f, 0x4259, \
 	{0x90, 0xb6, 0xf9, 0x77, 0x6c, 0xee, 0xba, 0x29} }
 
-/**
- * @brief   Encapsulates a plain key into black key command id
- */
-#define PTA_BK_CMD_ENCAPS 1
+enum PTA_BK_CMD {
+	PTA_BK_CMD_ENCAPS = 0,	  // Encapsulate plain key into black key
+	PTA_BK_CMD_SIGN,	  // Sign using black key
+	PTA_BK_CMD_CIPHER_ALLOC,  // Allocate cipher context
+	PTA_BK_CMD_CIPHER_INIT,	  // Initialize cipher context
+	PTA_BK_CMD_CIPHER_UPDATE, // Cipher update opreation
+	PTA_BK_CMD_CIPHER_FINAL,  // Cipher final operation
+	PTA_BK_CMD_CIPHER_FREE,	  // Free cipher context
+};
 
-/**
- * @brief   Sign using black key command id in PTA
- */
-#define PTA_BK_CMD_SIGN   2
+#define CIPHER_INIT_CMD_ENCRYPT(val)	((val) & BIT(31)) ? true : false
+#define CIPHER_INIT_CMD_KEY1_TYPE(val)	(val) & GENMASK_32(3, 0)
+#define CIPHER_INIT_CMD_KEY2_TYPE(val)	(((val) & GENMASK_32(7, 4)) >> 4)
+#define CIPHER_INIT_CMD_KEY1_SIZE(val)	(val) & GENMASK_32(15, 0)
+#define CIPHER_INIT_CMD_KEY2_SIZE(val)	(((val) & GENMASK_32(31, 16)) >> 16)
+
+#define CIPHER_ENC		BIT(31)
+#define CIPHER_KEY1_TYPE(val)	((val) & 0xF)
+#define CIPHER_KEY2_TYPE(val)	SHIFT_U32((val) & 0xF, 4)
+#define CIPHER_KEY1_SIZE(val)	((val) & 0xFFFF)
+#define CIPHER_KEY2_SIZE(val)	SHIFT_U32((val) & 0xFFFF, 16)
 
 /**
  * @brief   PTA black key Type
-- 
2.25.1


From e4c8f0294c34720c78bfd8deeae1974002143adc Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Fri, 7 Aug 2020 15:01:27 +0200
Subject: [PATCH 12/22] Add black key support to CAAM Hash

Change the hardware key split to support black key as input key.
Modify the KEY command to support the loading of black key encrypted
with AES-ECB/CCM.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/drivers/caam/caam_hash.c                 | 53 +++++++++++++++----
 .../crypto_api/include/crypto_extension.h     |  3 ++
 2 files changed, 47 insertions(+), 9 deletions(-)

diff --git a/core/drivers/caam/caam_hash.c b/core/drivers/caam/caam_hash.c
index 1332da0f..d1e9a8ec 100644
--- a/core/drivers/caam/caam_hash.c
+++ b/core/drivers/caam/caam_hash.c
@@ -20,6 +20,7 @@
 /* Library i.MX includes */
 #include <libimxcrypt.h>
 #include <libimxcrypt_hash.h>
+#include <crypto_extension.h>
 
 /* Local includes */
 #include "common.h"
@@ -35,9 +36,8 @@
 /*
  * Debug Macros
  */
-//#define HASH_DEBUG
 #ifdef HASH_DEBUG
-//#define DUMP_DESC
+#define DUMP_DESC
 //#define DUMP_BUF
 #define HASH_TRACE		DRV_TRACE
 #else
@@ -149,6 +149,7 @@ struct hashdata {
 
 	struct caambuf key;             ///< HMAC split key
 	enum keytype   key_type;        ///< HMAC key type
+	enum bk_type bk_type;
 
 	enum imxcrypt_hash_id algo_id;  ///< Hash Algorithm Id
 	const struct hashalg  *alg;     ///< Reference to the algo constants
@@ -229,9 +230,10 @@ exit_reduce:
  * @retval  TEE_ERROR_GENERIC        General error
  * @retval  TEE_ERROR_OUT_OF_MEMORY  Out of memory error
  */
-static TEE_Result do_split_key(void *ctx, const uint8_t *ikey, size_t ilen)
+TEE_Result do_split_key_2(void *ctx, const uint8_t *ikey, size_t ilen,
+			  size_t ikey_origin, enum bk_type type)
 {
-#define KEY_COMPUTE_DESC_ENTRIES	8
+#define KEY_COMPUTE_DESC_ENTRIES 8
 	TEE_Result    ret = TEE_ERROR_GENERIC;
 	enum CAAM_Status retstatus;
 
@@ -302,14 +304,26 @@ static TEE_Result do_split_key(void *ctx, const uint8_t *ikey, size_t ilen)
 	}
 
 	/* Load either input key or the reduced input key into key register */
-	desc[desclen++] = LD_KEY_PLAIN(CLASS_2, REG, key.length);
+	if (type == PLAIN_TEXT)
+		desc[desclen++] = LD_KEY_PLAIN(CLASS_2, REG, key.length);
+	else if (type == BK_ECB)
+		desc[desclen++] = LD_KEY_ENC(CLASS_2, REG, ikey_origin, ECB);
+	else if (type == BK_CCM)
+		desc[desclen++] = LD_KEY_ENC(CLASS_2, REG, ikey_origin, CCM);
+
 	desc[desclen++] = key.paddr;
+
 	/* Split the key */
 	desc[desclen++] = HMAC_INIT_DECRYPT(alg->type);
 	desc[desclen++] = FIFO_LD_IMM(CLASS_2, MSG, LAST_C2, 0);
 	/* Store the split key */
-	desc[desclen++] = FIFO_ST(C2_MDHA_SPLIT_KEY_AES_ECB_JKEK,
+	if (type == PLAIN_TEXT || type == BK_ECB)
+		desc[desclen++] = FIFO_ST(C2_MDHA_SPLIT_KEY_AES_ECB_JKEK,
+					hashdata->key.length);
+	else
+		desc[desclen++] = FIFO_ST(C2_MDHA_SPLIT_KEY_AES_CCM_JKEK,
 					hashdata->key.length);
+
 	desc[desclen++] = hashdata->key.paddr;
 
 	/* Set the descriptor Header with length */
@@ -329,6 +343,7 @@ static TEE_Result do_split_key(void *ctx, const uint8_t *ikey, size_t ilen)
 			hashdata->key.length);
 
 		hashdata->key_type = KEY_PRECOMP;
+		hashdata->bk_type = type;
 		ret = TEE_SUCCESS;
 	} else {
 		HASH_TRACE("CAAM Status 0x%08"PRIx32"", jobctx.status);
@@ -341,6 +356,11 @@ exit_split_key:
 	return ret;
 }
 
+static TEE_Result do_split_key(void *ctx, const uint8_t *ikey, size_t ilen)
+{
+	return do_split_key_2(ctx, ikey, ilen, ilen, PLAIN_TEXT);
+}
+
 /**
  * @brief   Free the internal hashing data context
  *
@@ -578,8 +598,16 @@ static TEE_Result do_update(void *ctx, enum imxcrypt_hash_id algo,
 			/* Check if there is a key to load it */
 			if (hashdata->key_type == KEY_PRECOMP) {
 				HASH_TRACE("Insert Key");
-				desc[desclen++] = LD_KEY_SPLIT(
-					hashdata->key.length);
+				if (hashdata->bk_type == PLAIN_TEXT)
+					desc[desclen++] = LD_KEY_SPLIT(
+						hashdata->key.length);
+				else if (hashdata->bk_type == BK_CCM)
+					desc[desclen++] = LD_KEY_SPLIT(
+						hashdata->key.length) | KEY_ENC | KEY_EKT(CCM);
+				else if (hashdata->bk_type == BK_ECB)
+					desc[desclen++] = LD_KEY_SPLIT(
+						hashdata->key.length) | KEY_ENC | KEY_EKT(ECB);
+
 				desc[desclen++] = hashdata->key.paddr;
 
 				/* Algo Operation - HMAC Init */
@@ -747,7 +775,14 @@ static TEE_Result do_final(void *ctx, enum imxcrypt_hash_id algo,
 	/* Check if there is a key to load it */
 	if (hashdata->key_type == KEY_PRECOMP) {
 		HASH_TRACE("Load key");
-		desc[desclen++] = LD_KEY_SPLIT(hashdata->key.length);
+		if (hashdata->bk_type == PLAIN_TEXT)
+			desc[desclen++] = LD_KEY_SPLIT(hashdata->key.length);
+		else if (hashdata->bk_type == BK_CCM)
+			desc[desclen++] = LD_KEY_SPLIT(
+				hashdata->key.length) | KEY_ENC | KEY_EKT(CCM);
+		else
+			desc[desclen++] = LD_KEY_SPLIT(
+				hashdata->key.length) | KEY_ENC | KEY_EKT(ECB);
 		desc[desclen++] = hashdata->key.paddr;
 
 		/* Clean Split key */
diff --git a/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h b/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
index a06f1db2..e4247338 100644
--- a/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
+++ b/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
@@ -180,4 +180,7 @@ struct imxcrypt_key {
 	size_t size;
 };
 
+TEE_Result do_split_key_2(void *ctx, const uint8_t *ikey, size_t ilen,
+			  size_t ikey_origin, enum bk_type type);
+
 #endif /* __CRYPTO_EXTENSION_H */
-- 
2.25.1


From 478f52aa6a30f04a78558fe8019cf6a739d91673 Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Tue, 4 Aug 2020 17:07:47 +0200
Subject: [PATCH 13/22] Add HMAC PTA with black key support

Add HMAC PTA with black key support
Implemented HMAC operations:
 * alloc
 * init
 * update
 * final
 * free
 * compute_key

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/arch/arm/plat-imx/pta/pta_bk_mx.c | 235 ++++++++++++++++++++++++-
 lib/libutee/include/pta_bk.h           |  12 +-
 2 files changed, 236 insertions(+), 11 deletions(-)

diff --git a/core/arch/arm/plat-imx/pta/pta_bk_mx.c b/core/arch/arm/plat-imx/pta/pta_bk_mx.c
index 9056fe02..a5592b84 100644
--- a/core/arch/arm/plat-imx/pta/pta_bk_mx.c
+++ b/core/arch/arm/plat-imx/pta/pta_bk_mx.c
@@ -25,6 +25,7 @@
 #include <crypto_extension.h>
 #include <libimxcrypt_bk.h>
 #include <libimxcrypt_cipher.h>
+#include <libimxcrypt_hash.h>
 
 /* Library crypto includes */
 #include <crypto/crypto.h>
@@ -47,6 +48,11 @@ struct attr_packed {
 static void *g_cipher_ctx;
 static uint32_t g_cipher_alg;
 
+/*
+ * HMAC context
+ */
+static void *g_hmac_ctx;
+
 static TEE_Result imxcrypt_buf_from_attr(struct imxcrypt_buf *buf,
 const TEE_Attribute *attrs, uint32_t attr_count)
 {
@@ -459,7 +465,215 @@ static TEE_Result cipher_free(uint32_t param_types __unused,
 	return TEE_SUCCESS;
 }
 
-	/**
+/*
+ * Call the Cryptographic Extension API to allocate HMAC context.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = HMAC algo ID (TEE_ALG_XXX)
+ *     params[0].value.b = 0
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result hmac_alloc(uint32_t param_types,
+			     TEE_Param params[TEE_NUM_PARAMS])
+{
+	uint32_t exp_param_types = 0;
+	struct imxcrypt_hash *ops = NULL;
+
+	exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_NONE,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_HMAC);
+	if (!ops || !ops->alloc_ctx) {
+		EMSG("Cannot get hmac ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	return ops->alloc_ctx(&g_hmac_ctx, params[0].value.a);
+}
+
+/*
+ * Call the Cryptographic Extension API to initialize HMAC context.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = HMAC algo ID (TEE_ALG_XXX)
+ *     params[0].value.b = 0
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result hmac_init(uint32_t param_types,
+			    TEE_Param params[TEE_NUM_PARAMS])
+{
+	struct imxcrypt_hash *ops = NULL;
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_NONE,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_HMAC);
+	if (!ops || !ops->init) {
+		EMSG("Cannot get HMAC ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	return ops->init(g_hmac_ctx, params[0].value.a);
+}
+
+/*
+ * Call the Cryptographic Extension API to update HMAC operation.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = HMAC algo ID (TEE_ALG_XXX)
+ *     params[0].value.b = 0
+ *     params[1].memref  = input buffer
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result hmac_update(uint32_t param_types,
+			      TEE_Param params[TEE_NUM_PARAMS])
+{
+	struct imxcrypt_hash *ops = NULL;
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+				TEE_PARAM_TYPE_MEMREF_INPUT,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_HMAC);
+	if (!ops || !ops->update) {
+		EMSG("Cannot get HMAC ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	return ops->update(g_hmac_ctx, params[0].value.a,
+			   params[1].memref.buffer, params[1].memref.size);
+}
+
+/*
+ * Call the Cryptographic Extension API to finalize HMAC operation.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = HMAC algo ID (TEE_ALG_XXX)
+ *     params[0].value.b = 0
+ *     params[1].memref  = digest buffer
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ *
+ */
+static TEE_Result hmac_final(uint32_t param_types,
+			     TEE_Param params[TEE_NUM_PARAMS])
+{
+	struct imxcrypt_hash *ops = NULL;
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+				TEE_PARAM_TYPE_MEMREF_OUTPUT,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_HMAC);
+	if (!ops || !ops->final) {
+		EMSG("Cannot get HMAC ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	return ops->final(g_hmac_ctx, params[0].value.a,
+			  params[1].memref.buffer, params[1].memref.size);
+}
+
+/*
+ * Call the Cryptographic Extension API to free HMAC context.
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result hmac_free(uint32_t param_types __unused,
+			    TEE_Param params[TEE_NUM_PARAMS] __unused)
+{
+	struct imxcrypt_hash *ops = NULL;
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_HMAC);
+	if (!ops || !ops->free_ctx) {
+		EMSG("Cannot get HMAC ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	ops->free_ctx(g_hmac_ctx);
+
+	return TEE_SUCCESS;
+}
+
+/*
+ * Call the Cryptographic Extension API to compute HMAC key.
+ *
+ *  Params are:
+ *    Inputs:
+ *     params[0].value.a = BK type
+ *     params[0].value.b = Original key size (before BK encapsulation)
+ *     params[1].memref  = Black key
+ *
+ * @param[in]  param_types    TEE parameters
+ * @param[in]  params         Buffer parameters
+ */
+static TEE_Result hmac_compute_key(uint32_t param_types,
+				   TEE_Param params[TEE_NUM_PARAMS])
+{
+	struct imxcrypt_hash *ops = NULL;
+	uint32_t exp_param_types =
+		TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+				TEE_PARAM_TYPE_MEMREF_INPUT,
+				TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+
+	if (param_types != exp_param_types) {
+		EMSG("Wrong parameter type");
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	ops = imxcrypt_getmod(CRYPTO_HMAC);
+	if (!ops || !ops->compute_key) {
+		EMSG("Cannot get HMAC ops");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	return do_split_key_2(g_hmac_ctx, params[1].memref.buffer,
+			      params[1].memref.size, params[0].value.b,
+			      params[0].value.a);
+}
+
+/**
  * @brief   Called when a pseudo TA is invoked.
  *
  * @param[in]  sess_ctx       Session Identifier
@@ -474,10 +688,9 @@ static TEE_Result cipher_free(uint32_t param_types __unused,
  * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
  * @retval TEE_ERROR_GENERIC           Generic error
  */
-	static TEE_Result
-	invokeCommandEntryPoint(void *sess_ctx __unused, uint32_t cmd_id,
-				uint32_t param_types,
-				TEE_Param params[TEE_NUM_PARAMS])
+static TEE_Result invokeCommandEntryPoint(void *sess_ctx __unused,
+					  uint32_t cmd_id, uint32_t param_types,
+					  TEE_Param params[TEE_NUM_PARAMS])
 {
 	switch (cmd_id) {
 	case PTA_BK_CMD_ENCAPS:
@@ -494,6 +707,18 @@ static TEE_Result cipher_free(uint32_t param_types __unused,
 		return cipher_final(param_types, params);
 	case PTA_BK_CMD_CIPHER_FREE:
 		return cipher_free(param_types, params);
+	case PTA_BK_CMD_HMAC_ALLOC:
+		return hmac_alloc(param_types, params);
+	case PTA_BK_CMD_HMAC_INIT:
+		return hmac_init(param_types, params);
+	case PTA_BK_CMD_HMAC_UPDATE:
+		return hmac_update(param_types, params);
+	case PTA_BK_CMD_HMAC_FINAL:
+		return hmac_final(param_types, params);
+	case PTA_BK_CMD_HMAC_FREE:
+		return hmac_free(param_types, params);
+	case PTA_BK_CMD_HMAC_COMPUTE_KEY:
+		return hmac_compute_key(param_types, params);
 	default:
 		return TEE_ERROR_BAD_PARAMETERS;
 	}
diff --git a/lib/libutee/include/pta_bk.h b/lib/libutee/include/pta_bk.h
index 1c19ba08..7e02fe04 100644
--- a/lib/libutee/include/pta_bk.h
+++ b/lib/libutee/include/pta_bk.h
@@ -24,6 +24,12 @@ enum PTA_BK_CMD {
 	PTA_BK_CMD_CIPHER_UPDATE, // Cipher update opreation
 	PTA_BK_CMD_CIPHER_FINAL,  // Cipher final operation
 	PTA_BK_CMD_CIPHER_FREE,	  // Free cipher context
+	PTA_BK_CMD_HMAC_ALLOC,    // Alloc HMAC context
+	PTA_BK_CMD_HMAC_INIT,     // Initialize HMAC context
+	PTA_BK_CMD_HMAC_UPDATE,   // HMAC update operation
+	PTA_BK_CMD_HMAC_FINAL,    // HMAC final operation
+	PTA_BK_CMD_HMAC_FREE,     // HMAC free operation
+	PTA_BK_CMD_HMAC_COMPUTE_KEY, // HMAC compute key operation
 };
 
 #define CIPHER_INIT_CMD_ENCRYPT(val)	((val) & BIT(31)) ? true : false
@@ -32,12 +38,6 @@ enum PTA_BK_CMD {
 #define CIPHER_INIT_CMD_KEY1_SIZE(val)	(val) & GENMASK_32(15, 0)
 #define CIPHER_INIT_CMD_KEY2_SIZE(val)	(((val) & GENMASK_32(31, 16)) >> 16)
 
-#define CIPHER_ENC		BIT(31)
-#define CIPHER_KEY1_TYPE(val)	((val) & 0xF)
-#define CIPHER_KEY2_TYPE(val)	SHIFT_U32((val) & 0xF, 4)
-#define CIPHER_KEY1_SIZE(val)	((val) & 0xFFFF)
-#define CIPHER_KEY2_SIZE(val)	SHIFT_U32((val) & 0xFFFF, 16)
-
 /**
  * @brief   PTA black key Type
  *          Enumerate must be the same as the bk_type defined in the
-- 
2.25.1


From 68bea4135842dcda37985b89e3457580f7a92840 Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Wed, 5 Aug 2020 17:40:35 +0200
Subject: [PATCH 14/22] Add CIPHER black key encapsulation descriptor

Add descriptor builder for Cipher black key encapsulation.
Add support for AES-ECB/CCM encapsulation.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/drivers/caam/caam_bk.c | 47 +++++++++++++++++++++++++++++++++++++
 1 file changed, 47 insertions(+)

diff --git a/core/drivers/caam/caam_bk.c b/core/drivers/caam/caam_bk.c
index 6668aaa3..8c22e3e3 100644
--- a/core/drivers/caam/caam_bk.c
+++ b/core/drivers/caam/caam_bk.c
@@ -101,6 +101,49 @@ static uint8_t build_rsa_encap_jobdesc(descPointer_t desc, enum bk_type type,
 	return desclen;
 }
 
+/**
+ * @brief
+ * Build Cipher key encapsulation job descriptor.
+ *
+ * Load key to class 1 key register.
+ * Write back out via FIFO store.
+ *
+ * @param[in/out] desc Pointer to job descriptor buffer
+ * @param[in] type     Encapsulation type
+ * @param[in] pk_ptr   Physical address of plain key
+ * @param[in] pk_size  Plain key size
+ * @param[in] bk_ptr   Physical address of black key
+ *
+ * @retval desclen     Length of the constructed job descriptor
+ */
+static uint8_t build_cipher_encap_jobdesc(descPointer_t desc, enum bk_type type,
+		paddr_t pk_ptr, size_t pk_size, paddr_t bk_ptr)
+{
+
+	uint8_t desclen = 1;
+
+	desc[desclen++] = (CMD_KEY_TYPE | CMD_CLASS(CLASS_1) | KEY_DEST(REG)
+			| KEY_LENGTH(pk_size));
+	desc[desclen++] = pk_ptr;
+
+	/* ...and write back out via FIFO store */
+	if (type == BK_ECB)
+		desc[desclen] = FIFO_STORE_OUTPUT(KEY_AES_ECB_JKEK);
+	else if (type == BK_CCM)
+		desc[desclen] = FIFO_STORE_OUTPUT(KEY_AES_CCM_JKEK);
+	else
+		desc[desclen] = 0;
+
+	desc[desclen++] |= CMD_FIFO_STORE_TYPE | CMD_CLASS(CLASS_1)
+			| FIFO_STORE_LENGTH(pk_size);
+	desc[desclen++] = bk_ptr;
+
+	/* finish off the job header */
+	desc[0] = DESC_HEADER_IDX(desclen, 0);
+
+	return desclen;
+}
+
 /**
  * @brief   CAAM driver does not implement free_keypair function.
  *			Manually free key.
@@ -204,6 +247,10 @@ static TEE_Result do_encapsulate(struct imxcrypt_bk_key *bk_key)
 		build_rsa_encap_jobdesc(desc, bk_key->type,
 			paddr_input, pk_size, out_buf.paddr);
 		break;
+	case CRYPTO_CIPHER:
+		build_cipher_encap_jobdesc(desc, bk_key->type,
+			paddr_input, pk_size, out_buf.paddr);
+		break;
 	default:
 		BK_TRACE("Algo not supported CAAM BK");
 		ret = TEE_ERROR_NOT_SUPPORTED;
-- 
2.25.1


From dc50c4d196b2b7adc7a77fafb26a14620eb87404 Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Fri, 7 Aug 2020 15:07:29 +0200
Subject: [PATCH 15/22] Change black key PTA command IDs

Change from enum to defines for better readability.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 lib/libutee/include/pta_bk.h | 28 +++++++++++++---------------
 1 file changed, 13 insertions(+), 15 deletions(-)

diff --git a/lib/libutee/include/pta_bk.h b/lib/libutee/include/pta_bk.h
index 7e02fe04..738861f4 100644
--- a/lib/libutee/include/pta_bk.h
+++ b/lib/libutee/include/pta_bk.h
@@ -16,21 +16,19 @@
 	0xf4557e21, 0xaa4f, 0x4259, \
 	{0x90, 0xb6, 0xf9, 0x77, 0x6c, 0xee, 0xba, 0x29} }
 
-enum PTA_BK_CMD {
-	PTA_BK_CMD_ENCAPS = 0,	  // Encapsulate plain key into black key
-	PTA_BK_CMD_SIGN,	  // Sign using black key
-	PTA_BK_CMD_CIPHER_ALLOC,  // Allocate cipher context
-	PTA_BK_CMD_CIPHER_INIT,	  // Initialize cipher context
-	PTA_BK_CMD_CIPHER_UPDATE, // Cipher update opreation
-	PTA_BK_CMD_CIPHER_FINAL,  // Cipher final operation
-	PTA_BK_CMD_CIPHER_FREE,	  // Free cipher context
-	PTA_BK_CMD_HMAC_ALLOC,    // Alloc HMAC context
-	PTA_BK_CMD_HMAC_INIT,     // Initialize HMAC context
-	PTA_BK_CMD_HMAC_UPDATE,   // HMAC update operation
-	PTA_BK_CMD_HMAC_FINAL,    // HMAC final operation
-	PTA_BK_CMD_HMAC_FREE,     // HMAC free operation
-	PTA_BK_CMD_HMAC_COMPUTE_KEY, // HMAC compute key operation
-};
+#define PTA_BK_CMD_ENCAPS	    0 // Encapsulate plain key into black key
+#define PTA_BK_CMD_SIGN		    1	 // Sign using black key
+#define PTA_BK_CMD_CIPHER_ALLOC	    2	 // Allocate cipher context
+#define PTA_BK_CMD_CIPHER_INIT	    3	 // Initialize cipher context
+#define PTA_BK_CMD_CIPHER_UPDATE    4	 // Cipher update opreation
+#define PTA_BK_CMD_CIPHER_FINAL	    5	 // Cipher final operation
+#define PTA_BK_CMD_CIPHER_FREE	    6	 // Free cipher context
+#define PTA_BK_CMD_HMAC_ALLOC	    7	 // Alloc HMAC context
+#define PTA_BK_CMD_HMAC_INIT	    8	 // Initialize HMAC context
+#define PTA_BK_CMD_HMAC_UPDATE	    9	 // HMAC update operation
+#define PTA_BK_CMD_HMAC_FINAL	    10 // HMAC final operation
+#define PTA_BK_CMD_HMAC_FREE	    11 // HMAC free operation
+#define PTA_BK_CMD_HMAC_COMPUTE_KEY 12 // HMAC compute key operation
 
 #define CIPHER_INIT_CMD_ENCRYPT(val)	((val) & BIT(31)) ? true : false
 #define CIPHER_INIT_CMD_KEY1_TYPE(val)	(val) & GENMASK_32(3, 0)
-- 
2.25.1


From c9add6e893b465275e56ad26ae7ae01bdf76df2d Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Fri, 7 Aug 2020 16:09:42 +0200
Subject: [PATCH 16/22] Restore origin commands IDs for BK PTA

The first commands must start from 1 and not 0 for retro compatibility
with previous TA implementation.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 lib/libutee/include/pta_bk.h | 26 +++++++++++++-------------
 1 file changed, 13 insertions(+), 13 deletions(-)

diff --git a/lib/libutee/include/pta_bk.h b/lib/libutee/include/pta_bk.h
index 738861f4..ed67693d 100644
--- a/lib/libutee/include/pta_bk.h
+++ b/lib/libutee/include/pta_bk.h
@@ -16,19 +16,19 @@
 	0xf4557e21, 0xaa4f, 0x4259, \
 	{0x90, 0xb6, 0xf9, 0x77, 0x6c, 0xee, 0xba, 0x29} }
 
-#define PTA_BK_CMD_ENCAPS	    0 // Encapsulate plain key into black key
-#define PTA_BK_CMD_SIGN		    1	 // Sign using black key
-#define PTA_BK_CMD_CIPHER_ALLOC	    2	 // Allocate cipher context
-#define PTA_BK_CMD_CIPHER_INIT	    3	 // Initialize cipher context
-#define PTA_BK_CMD_CIPHER_UPDATE    4	 // Cipher update opreation
-#define PTA_BK_CMD_CIPHER_FINAL	    5	 // Cipher final operation
-#define PTA_BK_CMD_CIPHER_FREE	    6	 // Free cipher context
-#define PTA_BK_CMD_HMAC_ALLOC	    7	 // Alloc HMAC context
-#define PTA_BK_CMD_HMAC_INIT	    8	 // Initialize HMAC context
-#define PTA_BK_CMD_HMAC_UPDATE	    9	 // HMAC update operation
-#define PTA_BK_CMD_HMAC_FINAL	    10 // HMAC final operation
-#define PTA_BK_CMD_HMAC_FREE	    11 // HMAC free operation
-#define PTA_BK_CMD_HMAC_COMPUTE_KEY 12 // HMAC compute key operation
+#define PTA_BK_CMD_ENCAPS	    1 // Encapsulate plain key into black key
+#define PTA_BK_CMD_SIGN		    2	 // Sign using black key
+#define PTA_BK_CMD_CIPHER_ALLOC	    3	 // Allocate cipher context
+#define PTA_BK_CMD_CIPHER_INIT	    4	 // Initialize cipher context
+#define PTA_BK_CMD_CIPHER_UPDATE    5	 // Cipher update opreation
+#define PTA_BK_CMD_CIPHER_FINAL	    6	 // Cipher final operation
+#define PTA_BK_CMD_CIPHER_FREE	    7	 // Free cipher context
+#define PTA_BK_CMD_HMAC_ALLOC	    8	 // Alloc HMAC context
+#define PTA_BK_CMD_HMAC_INIT	    9	 // Initialize HMAC context
+#define PTA_BK_CMD_HMAC_UPDATE	    10	 // HMAC update operation
+#define PTA_BK_CMD_HMAC_FINAL	    11 // HMAC final operation
+#define PTA_BK_CMD_HMAC_FREE	    12 // HMAC free operation
+#define PTA_BK_CMD_HMAC_COMPUTE_KEY 13 // HMAC compute key operation
 
 #define CIPHER_INIT_CMD_ENCRYPT(val)	((val) & BIT(31)) ? true : false
 #define CIPHER_INIT_CMD_KEY1_TYPE(val)	(val) & GENMASK_32(3, 0)
-- 
2.25.1


From 370523d121aa025652736e29f612cb6c344f9d23 Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Mon, 17 Aug 2020 16:55:32 +0200
Subject: [PATCH 17/22] Add the plain key size for blob encapsulation

Add the plain key size as parameter for the blob encapsulation
to ensure enough space is allocated for the blob.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/arch/arm/plat-imx/pta/pta_blob_mx.c                  | 2 +-
 core/lib/libimxcrypt/crypto_api/blob/blob.c               | 5 +++--
 .../lib/libimxcrypt/crypto_api/include/crypto_extension.h | 8 ++++----
 .../lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h | 3 ++-
 4 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/core/arch/arm/plat-imx/pta/pta_blob_mx.c b/core/arch/arm/plat-imx/pta/pta_blob_mx.c
index 707eb595..77951301 100644
--- a/core/arch/arm/plat-imx/pta/pta_blob_mx.c
+++ b/core/arch/arm/plat-imx/pta/pta_blob_mx.c
@@ -86,7 +86,7 @@ static TEE_Result encapsulate(uint32_t param_types,
 	blob.data   = params[3].memref.buffer;
 	blob.length = params[3].memref.size;
 
-	res = blob_encapsulate(params[0].value.a,
+	res = blob_encapsulate(params[0].value.a, params[0].value.b,
 			params[1].memref.buffer,
 			&payload, &blob);
 
diff --git a/core/lib/libimxcrypt/crypto_api/blob/blob.c b/core/lib/libimxcrypt/crypto_api/blob/blob.c
index a3fb6898..03ed2832 100644
--- a/core/lib/libimxcrypt/crypto_api/blob/blob.c
+++ b/core/lib/libimxcrypt/crypto_api/blob/blob.c
@@ -42,7 +42,7 @@
  * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
  * @retval TEE_ERROR_GENERIC           Generic error
  */
-TEE_Result blob_encapsulate(enum blob_type type,
+TEE_Result blob_encapsulate(enum blob_type type, uint32_t pk_size,
 		const uint8_t *key,
 		const struct imxcrypt_buf *payload,
 		struct imxcrypt_buf *blob)
@@ -75,7 +75,7 @@ TEE_Result blob_encapsulate(enum blob_type type,
 		return TEE_ERROR_BAD_PARAMETERS;
 	}
 
-	if ((blob->length - BLOB_BPAD_SIZE) < payload->length) {
+	if ((blob->length - BLOB_BPAD_SIZE) < pk_size) {
 		LIB_TRACE("Blob length too short");
 		return TEE_ERROR_SHORT_BUFFER;
 	}
@@ -88,6 +88,7 @@ TEE_Result blob_encapsulate(enum blob_type type,
 
 	blob_data.type           = type;
 	blob_data.encaps         = true;
+	blob_data.pk_size        = pk_size;
 	blob_data.key.data       = (uint8_t *)key;
 	blob_data.key.length     = BLOB_KEY_MODIFIER_SIZE;
 	blob_data.payload.data   = payload->data;
diff --git a/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h b/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
index e4247338..10fe6e28 100644
--- a/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
+++ b/core/lib/libimxcrypt/crypto_api/include/crypto_extension.h
@@ -101,10 +101,10 @@ TEE_Result crypto_generate_huk(struct imxcrypt_buf *huk);
  * @retval TEE_ERROR_SHORT_BUFFER      Output buffer too short
  * @retval TEE_ERROR_GENERIC           Generic error
  */
-TEE_Result blob_encapsulate(enum blob_type type,
-		const uint8_t *key,
-		const struct imxcrypt_buf *payload,
-		struct imxcrypt_buf *blob);
+TEE_Result blob_encapsulate(enum blob_type type, uint32_t pk_size,
+			    const uint8_t *key,
+			    const struct imxcrypt_buf *payload,
+			    struct imxcrypt_buf *blob);
 
 /**
  * @brief Decapsulates input blob.
diff --git a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h
index ab348e57..9953def8 100644
--- a/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h
+++ b/core/lib/libimxcrypt/crypto_api/include/libimxcrypt_blob.h
@@ -18,6 +18,7 @@
 struct imxcrypt_blob_data {
 	enum blob_type      type;    ///< Blob encryption type
 	bool                encaps;  ///< Encryption/Decryption direction
+	size_t pk_size;              ///< Size of the plain key blackened
 	struct imxcrypt_buf key;     ///< Blob Key modifier
 	struct imxcrypt_buf payload; ///< Decrypted Blob data payload
 	struct imxcrypt_buf blob;    ///< Encrypted Blob of payload
@@ -31,4 +32,4 @@ struct imxcrypt_blob {
 	TEE_Result (*operate)(struct imxcrypt_blob_data *blob_data);
 };
 
-#endif /* __LIBIMXCRYPT_BLOB_H__ */
\ No newline at end of file
+#endif /* __LIBIMXCRYPT_BLOB_H__ */
-- 
2.25.1


From 7cdafd128fcb40ae5cef8e0ff5baa121fa5d392c Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Mon, 17 Aug 2020 16:56:34 +0200
Subject: [PATCH 18/22] Add AUX parameter for FIFO_STORE command

Add the auxiliary control bits for the FIFO_STORE command in the CAAM blob
encapsulation.
This bit field determines the source register for the FIFO STORE
command. In this case, AUX=0x1 selects the Class 1 key register to be
stored.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/drivers/caam/caam_bk.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/drivers/caam/caam_bk.c b/core/drivers/caam/caam_bk.c
index 8c22e3e3..cb225eee 100644
--- a/core/drivers/caam/caam_bk.c
+++ b/core/drivers/caam/caam_bk.c
@@ -135,7 +135,7 @@ static uint8_t build_cipher_encap_jobdesc(descPointer_t desc, enum bk_type type,
 		desc[desclen] = 0;
 
 	desc[desclen++] |= CMD_FIFO_STORE_TYPE | CMD_CLASS(CLASS_1)
-			| FIFO_STORE_LENGTH(pk_size);
+			| FIFO_STORE_LENGTH(pk_size) | MOVE_AUX(0x1);
 	desc[desclen++] = bk_ptr;
 
 	/* finish off the job header */
-- 
2.25.1


From 3f77081cb7ab1ddd2c20e023372d6e537fe774bc Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Tue, 18 Aug 2020 10:07:38 +0200
Subject: [PATCH 19/22] Rework the CAAM blob operation function

Simplify the blob encapsulation/decapsulations switch case.
Fix the return value of caam_realloc_align().

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/drivers/caam/caam_blob.c | 122 ++++++++++++++++------------------
 1 file changed, 59 insertions(+), 63 deletions(-)

diff --git a/core/drivers/caam/caam_blob.c b/core/drivers/caam/caam_blob.c
index e8450fdd..483861c9 100644
--- a/core/drivers/caam/caam_blob.c
+++ b/core/drivers/caam/caam_blob.c
@@ -200,63 +200,39 @@ static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
 	paddr_t paddr_key = 0;
 
 	struct caambuf out_buf = {0};
-	size_t insize, rinsize;
-	size_t outsize, routsize;
+	struct imxcrypt_buf *input = NULL;
+	struct imxcrypt_buf *output = NULL;
+	size_t insize;
+	size_t outsize;
 
 	uint32_t opflag   = 0;
 	int retS = 0;
 	uint8_t desclen = 1;
 
-	BLOB_TRACE("Blob %s - Type %d - Payload %d bytes - Blob %d bytes",
+	BLOB_TRACE("Blob %s - Type %d - Payload %ld bytes - Blob %ld bytes",
 			(blob_data->encaps) ? "Encaps" : "Decaps",
 			blob_data->type,
 			blob_data->payload.length,
 			blob_data->blob.length);
 
 	paddr_key = virt_to_phys(blob_data->key.data);
-	if (!paddr_key)
+	if (!paddr_key) {
+		BLOB_TRACE("Fail to get physical address of key modifier");
 		goto exit_operate;
+	}
 
 	if (blob_data->encaps) {
-		retS = caam_realloc_align(blob_data->blob.data, &out_buf,
-				blob_data->blob.length);
-		if (retS == (-1)) {
-			BLOB_TRACE("Signature reallocation error");
-			ret = TEE_ERROR_OUT_OF_MEMORY;
-			goto exit_operate;
-		}
-
-		insize  = blob_data->payload.length;
-		outsize = blob_data->blob.length;
-
-		paddr_input = virt_to_phys(blob_data->payload.data);
-		if (!paddr_input)
-			goto exit_operate;
-
-		BLOB_DUMPBUF("Input",
-			blob_data->payload.data, blob_data->payload.length);
+		input = &blob_data->payload;
+		output = &blob_data->blob;
 	} else {
-		retS = caam_realloc_align(blob_data->payload.data, &out_buf,
-		blob_data->payload.length);
-		if (retS == (-1)) {
-			BLOB_TRACE("Signature reallocation error");
-			ret = TEE_ERROR_OUT_OF_MEMORY;
-			goto exit_operate;
-		}
-		insize  = blob_data->blob.length;
-		outsize = blob_data->payload.length;
+		input = &blob_data->blob;
+		output = &blob_data->payload;
 
-		paddr_input = virt_to_phys(blob_data->blob.data);
-		if (!paddr_input)
-			goto exit_operate;
-
-		BLOB_DUMPBUF("Input",
-			blob_data->blob.data, blob_data->blob.length);
+		insize = input->length;
+		outsize = input->length - BLOB_BPAD_SIZE;
+		blob_data->pk_size = outsize;
 	}
 
-	rinsize  = insize;
-	routsize = outsize;
-
 	switch (blob_data->type) {
 	case BLACK_CCM:
 		opflag = PROT_BLOB_TYPE(BLACK_KEY) | PROT_BLOB_INFO(CCM);
@@ -265,9 +241,10 @@ static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
 		 * which contains more data
 		 */
 		if (blob_data->encaps)
-			rinsize = BLACK_KEY_CCM_SIZE(insize);
+			insize = blob_data->pk_size;
 		else
-			routsize = ROUNDUP(BLACK_KEY_CCM_SIZE(outsize), 16);
+			output->length = BLACK_KEY_CCM_SIZE(outsize);
+
 		break;
 
 	case BLACK_ECB:
@@ -277,12 +254,18 @@ static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
 		 * which contains more data
 		 */
 		if (blob_data->encaps)
-			rinsize = BLACK_KEY_CCM_SIZE(insize);
+			insize = blob_data->pk_size;
 		else
-			routsize = ROUNDUP(BLACK_KEY_ECB_SIZE(outsize), 16);
+			output->length = BLACK_KEY_ECB_SIZE(outsize);
+
 		break;
 
 	case RED:
+		if (blob_data->encaps)
+			insize = input->length;
+		else
+			output->length = outsize;
+
 		break;
 
 	default:
@@ -290,6 +273,31 @@ static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
 		goto exit_operate;
 	}
 
+	if (blob_data->encaps) {
+		outsize = insize + BLOB_BPAD_SIZE;
+		output->length = outsize;
+	}
+
+	BLOB_TRACE("payload %p(%ld)[real %ld] %s blob(%d) %p(%ld)",
+		blob_data->payload.data, blob_data->payload.data,
+		blob_data->pk_size, (blob_data->encaps) ? "->" : "<-",
+		blob_data->type, blob_data->blob.data, blob_data->blob.data);
+
+	paddr_input = virt_to_phys(input->data);
+	if (!paddr_input) {
+		BLOB_TRACE("Fail to get physical address of input buffer");
+		goto exit_operate;
+	}
+
+	BLOB_DUMPBUF("Input", input->data, input->length);
+
+	retS = caam_realloc_align(output->data, &out_buf, output->length);
+	if (retS == (-1)) {
+		BLOB_TRACE("Fail to realloc output buffer");
+		ret = TEE_ERROR_OUT_OF_MEMORY;
+		goto exit_operate;
+	}
+
 	/* Allocate the descriptor */
 	desc = caam_alloc_desc(BLOB_OPERATE_DESC_ENTRIES);
 	if (!desc) {
@@ -329,12 +337,7 @@ static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
 	cache_operation(TEE_CACHECLEAN, blob_data->key.data,
 		blob_data->key.length);
 
-	if (blob_data->encaps)
-		cache_operation(TEE_CACHECLEAN, blob_data->payload.data,
-			rinsize);
-	else
-		cache_operation(TEE_CACHECLEAN, blob_data->blob.data,
-			rinsize);
+	cache_operation(TEE_CACHECLEAN, input->data, input->length);
 
 	if (out_buf.nocache == 0)
 		cache_operation(TEE_CACHEFLUSH, out_buf.data, out_buf.length);
@@ -350,32 +353,25 @@ static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
 			cache_operation(TEE_CACHEINVALIDATE, out_buf.data,
 				out_buf.length);
 
-		BLOB_DUMPBUF("Output", out_buf.data, routsize);
+		BLOB_DUMPBUF("Output", out_buf.data, out_buf.length);
 
 		if (retS == 1) {
 			/*
 			 * Copy the result data in the correct output
 			 * buffer function of the operation direction
 			 */
-			if (blob_data->encaps)
-				memcpy(blob_data->blob.data,
-					out_buf.data, routsize);
-			else
-				memcpy(blob_data->payload.data,
-					out_buf.data, routsize);
-
-			ret = TEE_SUCCESS;
+			memcpy(output->data, out_buf.data, out_buf.length);
 		}
-
-		if (blob_data->encaps)
-			blob_data->blob.length = routsize;
-		else
-			blob_data->payload.length = routsize;
+		ret = TEE_SUCCESS;
 	} else {
 		BLOB_TRACE("CAAM Status 0x%08"PRIx32"", jobctx.status);
 		ret = TEE_ERROR_GENERIC;
 	}
 
+	BLOB_TRACE("Done CAAM BLOB %s outbuf: %p(%ld)",
+			blob_data->encaps ? "Encaps" : "Decaps",
+			output->data, output->length);
+
 exit_operate:
 	if (retS == 1)
 		caam_free_buf(&out_buf);
-- 
2.25.1


From 6fcd7f8123ba3486fc1b92891548057462a76221 Mon Sep 17 00:00:00 2001
From: Franck LENORMAND <franck.lenormand@nxp.com>
Date: Wed, 9 Sep 2020 16:26:51 +0200
Subject: [PATCH 20/22] Fix do_update_cipher shifting offset

In do_update_cipher the offset is added to the data pointer but
also increased each time creating a shift at each iteration of
the loop.

The issue only happens when there is more than 16k bytes to
process and/or when not finishing on a 8k boundary.

Signed-off-by: Franck LENORMAND <franck.lenormand@nxp.com>
---
 core/drivers/caam/cipher/caam_cipher.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/core/drivers/caam/cipher/caam_cipher.c b/core/drivers/caam/cipher/caam_cipher.c
index 743c26ba..ef635784 100644
--- a/core/drivers/caam/cipher/caam_cipher.c
+++ b/core/drivers/caam/cipher/caam_cipher.c
@@ -1112,8 +1112,8 @@ static TEE_Result do_update_cipher(struct imxcrypt_cipher_update *dupdate)
 		dstbuf.length = MAX_CIPHER_BUFFER;
 
 		do {
-			srcbuf.data  += offset;
-			srcbuf.paddr += offset;
+			srcbuf.data  = dupdate->src.data + offset;
+			srcbuf.paddr = psrc + offset;
 
 			CIPHER_TRACE("Do Idx=%d, offset %d", nbBuf, offset);
 			retstatus = do_block(ctx, true, NEED_KEY1, dupdate->encrypt,
@@ -1136,9 +1136,9 @@ static TEE_Result do_update_cipher(struct imxcrypt_cipher_update *dupdate)
 
 	if ((dupdate->src.length - offset) > 0) {
 		CIPHER_TRACE("Do Last %d offset %d", dupdate->src.length - offset, offset);
-		srcbuf.data  += offset;
+		srcbuf.data  = dupdate->src.data + offset;
 		srcbuf.length = (dupdate->src.length - offset);
-		srcbuf.paddr += offset;
+		srcbuf.paddr = psrc + offset;
 
 		dstbuf.length = (dupdate->dst.length - offset);
 
-- 
2.25.1


From bc501e925045025ebcf86d8ae7f298e5e9972ccb Mon Sep 17 00:00:00 2001
From: Cedric Neveux <cedric.neveux@nxp.com>
Date: Fri, 5 Jul 2019 08:19:11 +0200
Subject: [PATCH 21/22] TEE-422 HAB failure event (open mode)

  Removed the selection of the JR Index in the hal_cfg.c file
  when CFG_WITH_HAB enabled.
  Now JR index can be selected from crypto_conf.mk file
  with the CFG_JR_IDX variable.
  Remove the CFG_WITH_HAB flag and change the CAAM driver
  boot initialization to complete all JRs at the end of
  driver initialization.
  Change the CAAM RNG module to no more start the RNG Data
  generation during the initialisation when CAAM Driver
  used. All Data Generation descriptors are created anyway.
  Then the RNG Generation descriptors will started at the
  first RNG data request.

  Modify the JR used by default on iMX8 device to be JR1
  keep JR0 on iMX6/7

Signed-off-by: Cedric Neveux <cedric.neveux@nxp.com>
(cherry picked from commit 04e1dd72f67b0d1c5e28455ad40da114094fa98b)
---
 core/arch/arm/plat-imx/conf.mk         |  7 -------
 core/arch/arm/plat-imx/crypto_conf.mk  | 12 ++++++++++++
 core/drivers/caam/caam_ctrl.c          |  4 +---
 core/drivers/caam/caam_jr.c            |  5 +----
 core/drivers/caam/caam_rng.c           |  4 ----
 core/drivers/caam/hal/common/hal_cfg.c | 18 +++---------------
 core/drivers/caam/include/caam_jr.h    |  5 +----
 7 files changed, 18 insertions(+), 37 deletions(-)

diff --git a/core/arch/arm/plat-imx/conf.mk b/core/arch/arm/plat-imx/conf.mk
index 6968855c..63285c13 100644
--- a/core/arch/arm/plat-imx/conf.mk
+++ b/core/arch/arm/plat-imx/conf.mk
@@ -103,7 +103,6 @@ $(call force,CFG_TZC380,n)
 $(call force,CFG_CSU,n)
 $(call force,CFG_IMX_UART,n)
 $(call force,CFG_IMX_SNVS,n)
-$(call force,CFG_WITH_HAB,n)
 else ifneq (,$(filter $(PLATFORM_FLAVOR),$(mx8qx-flavorlist)))
 $(call force,CFG_MX8QX,y)
 $(call force,CFG_ARM64_core,y)
@@ -113,7 +112,6 @@ $(call force,CFG_TZC380,n)
 $(call force,CFG_CSU,n)
 $(call force,CFG_IMX_UART,n)
 $(call force,CFG_IMX_SNVS,n)
-$(call force,CFG_WITH_HAB,n)
 else
 $(error Unsupported PLATFORM_FLAVOR "$(PLATFORM_FLAVOR)")
 endif
@@ -143,7 +141,6 @@ CFG_IMX_UART ?= y
 CFG_IMX_LPUART ?= y
 CFG_IMX_CAAM ?= y
 CFG_IMX_SNVS ?= y
-CFG_WITH_HAB ?= y
 else
 # arm-v7 platforms Common definition
 ta-targets = ta_arm32
@@ -164,7 +161,6 @@ CFG_TZC380 ?= y
 CFG_CSU ?= y
 CFG_IMX_CAAM ?= y
 CFG_IMX_SNVS ?= y
-CFG_WITH_HAB ?= y
 $(call force,CFG_BOOT_SYNC_CPU,n)
 $(call force,CFG_BOOT_SECONDARY_REQUEST,n)
 $(call force,CFG_IMX_LPUART,n)
@@ -186,7 +182,6 @@ CFG_BOOT_SECONDARY_REQUEST ?= y
 CFG_ENABLE_SCTLR_RR ?= y
 CFG_IMX_CAAM ?= y
 CFG_IMX_SNVS ?= y
-CFG_WITH_HAB ?= y
 $(call force,CFG_IMX_LPUART,n)
 endif
 
@@ -200,7 +195,6 @@ CFG_TZC380 ?= y
 CFG_CSU ?= y
 CFG_IMX_CAAM ?= y
 CFG_IMX_SNVS ?= y
-CFG_WITH_HAB ?= y
 $(call force,CFG_IMX_LPUART,n)
 endif
 
@@ -210,7 +204,6 @@ include core/arch/arm/cpu/cortex-a7.mk
 CFG_IMX_LPUART ?= y
 $(call force,CFG_BOOT_SECONDARY_REQUEST,n)
 CFG_IMX_CAAM ?= y
-CFG_WITH_HAB ?= y
 $(call force,CFG_IMX_UART,n)
 endif
 
diff --git a/core/arch/arm/plat-imx/crypto_conf.mk b/core/arch/arm/plat-imx/crypto_conf.mk
index fa423944..a61b778a 100644
--- a/core/arch/arm/plat-imx/crypto_conf.mk
+++ b/core/arch/arm/plat-imx/crypto_conf.mk
@@ -2,6 +2,18 @@
 # Define the cryptographic algorithm to be built
 #
 
+ifeq ($(filter y, $(CFG_MX6)$(CFG_MX7)),y)
+# Job Ring 0
+$(call force,CFG_JR_IDX,0x0)
+# Job Ring IRQ Num(105 + 32) = 137
+$(call force,CFG_JR_IRQ_ID,137)
+else
+# Job Ring 1
+$(call force,CFG_JR_IDX,0x1)
+# Job Ring IRQ Num(106 + 32) = 138
+$(call force,CFG_JR_IRQ_ID,138)
+endif
+
 ifeq ($(CFG_IMXCRYPT), y)
 $(call force, CFG_CRYPTO_WITH_HW_ACC,y)
 #
diff --git a/core/drivers/caam/caam_ctrl.c b/core/drivers/caam/caam_ctrl.c
index dd822d8a..9d95160d 100644
--- a/core/drivers/caam/caam_ctrl.c
+++ b/core/drivers/caam/caam_ctrl.c
@@ -202,10 +202,9 @@ exit_init:
 driver_init(crypto_driver_init);
 #endif
 
-#ifdef CFG_WITH_HAB
 /**
  * @brief   Crypto driver late initialization function to complete
- *          CAAM operation in case of HAB usage on Closed devices
+ *          CAAM operation
  *
  * @retval  TEE_SUCCESS        Success
  * @retval  TEE_ERROR_GENERIC  Generic Error (driver init failure)
@@ -222,4 +221,3 @@ static TEE_Result init_caam_late(void)
 		return TEE_ERROR_GENERIC;
 }
 driver_init_late(init_caam_late);
-#endif
diff --git a/core/drivers/caam/caam_jr.c b/core/drivers/caam/caam_jr.c
index 922be889..02d5aa23 100644
--- a/core/drivers/caam/caam_jr.c
+++ b/core/drivers/caam/caam_jr.c
@@ -767,11 +767,9 @@ void caam_jr_resume(uint32_t pm_hint)
 		hal_jr_resume(jr_privdata->baseaddr);
 }
 
-#ifdef CFG_WITH_HAB
 /**
  * @brief   Forces the completion of all CAAM Job to ensure
- *          CAAM is not BUSY. This enable the HAB to execute
- *          CAAM Jobs.
+ *          CAAM is not BUSY.
  *
  * @retval 0    CAAM is no more busy
  * @retval (-1) CAAM is still busy
@@ -786,4 +784,3 @@ int caam_jr_complete(void)
 
 	return ret;
 }
-#endif
diff --git a/core/drivers/caam/caam_rng.c b/core/drivers/caam/caam_rng.c
index fece27ad..47539f0c 100644
--- a/core/drivers/caam/caam_rng.c
+++ b/core/drivers/caam/caam_rng.c
@@ -432,10 +432,6 @@ static enum CAAM_Status caam_rng_init_data(void)
 	for (idx = 0; (idx < RNG_DATABUF_NB); idx++) {
 		rng = &rng_privdata->databuf[idx];
 		retstatus = prepare_gen_desc(rng);
-		if (retstatus == CAAM_NO_ERROR) {
-			RNG_TRACE("Start RNG #%d data generation", idx);
-			retstatus = do_rng_start(rng);
-		}
 
 		if (retstatus != CAAM_NO_ERROR)
 			break;
diff --git a/core/drivers/caam/hal/common/hal_cfg.c b/core/drivers/caam/hal/common/hal_cfg.c
index eff03b22..95993108 100644
--- a/core/drivers/caam/hal/common/hal_cfg.c
+++ b/core/drivers/caam/hal/common/hal_cfg.c
@@ -51,13 +51,8 @@
 /**
  * @brief   Define the TEE Job Ring to be used
  */
-#define CFG_JR_INDEX		0
-#define CFG_JR_IRQ			105
-
-#ifdef CFG_WITH_HAB
-#define CFG_JR_INDEX_HAB	1
-#define CFG_JR_IRQ_HAB		106
-#endif
+#define CFG_JR_INDEX		CFG_JR_IDX
+#define CFG_JR_IRQ		CFG_JR_IRQ_ID
 #endif
 
 #ifdef CFG_DT
@@ -229,14 +224,7 @@ enum CAAM_Status hal_cfg_get_conf(struct jr_cfg *jr_cfg)
 	jr_cfg->offset  = (CFG_JR_INDEX + 1) * JRx_BLOCK_SIZE;
 	jr_cfg->nb_jobs = NB_JOBS_QUEUE;
 	// Add index of the first SPI interrupt
-	jr_cfg->it_num  = CFG_JR_IRQ + 32;
-
-#ifdef CFG_WITH_HAB
-	if (imx_is_device_closed()) {
-		jr_cfg->offset = (CFG_JR_INDEX_HAB + 1) * JRx_BLOCK_SIZE;
-		jr_cfg->it_num = CFG_JR_IRQ_HAB + 32;
-	}
-#endif
+	jr_cfg->it_num  = CFG_JR_IRQ;
 #endif // CFG_DT
 
 	retstatus = CAAM_NO_ERROR;
diff --git a/core/drivers/caam/include/caam_jr.h b/core/drivers/caam/include/caam_jr.h
index 7e62f693..a36d43ee 100644
--- a/core/drivers/caam/include/caam_jr.h
+++ b/core/drivers/caam/include/caam_jr.h
@@ -113,16 +113,13 @@ int caam_jr_flush(void);
  */
 void caam_jr_resume(uint32_t pm_hints);
 
-#ifdef CFG_WITH_HAB
 /**
  * @brief   Forces the completion of all CAAM Job to ensure
- *          CAAM is not BUSY. This enable the HAB to execute
- *          CAAM Jobs.
+ *          CAAM is not BUSY.
  *
  * @retval 0    CAAM is no more busy
  * @retval (-1) CAAM is still busy
  */
 int caam_jr_complete(void);
-#endif
 #endif /* __CAAM_JR_H__ */
 
-- 
2.25.1


From feacf06edb47c311b470292ae1f266401bf78c4f Mon Sep 17 00:00:00 2001
From: Clement Faure <clement.faure@nxp.com>
Date: Tue, 13 Oct 2020 17:24:34 +0200
Subject: [PATCH 22/22] Remove CAAM blob dump debug traces

Over security concerns, debug traces that would eventually dump
sensitive data such as keys and blobs are removed.

Signed-off-by: Clement Faure <clement.faure@nxp.com>
---
 core/drivers/caam/caam_blob.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/core/drivers/caam/caam_blob.c b/core/drivers/caam/caam_blob.c
index 483861c9..9a3fa3f0 100644
--- a/core/drivers/caam/caam_blob.c
+++ b/core/drivers/caam/caam_blob.c
@@ -139,8 +139,6 @@ static TEE_Result caam_master_key_verif(struct imxcrypt_buf *outkey)
 	if (retstatus == CAAM_NO_ERROR) {
 		cache_operation(TEE_CACHEINVALIDATE, outkey_align.data,
 				outkey_align.length);
-		BLOB_DUMPBUF("Master Key", outkey_align.data,
-				outkey_align.length);
 
 		if (realloc == 1)
 			memcpy(outkey->data, outkey_align.data,
@@ -289,8 +287,6 @@ static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
 		goto exit_operate;
 	}
 
-	BLOB_DUMPBUF("Input", input->data, input->length);
-
 	retS = caam_realloc_align(output->data, &out_buf, output->length);
 	if (retS == (-1)) {
 		BLOB_TRACE("Fail to realloc output buffer");
@@ -353,8 +349,6 @@ static TEE_Result do_operate(struct imxcrypt_blob_data *blob_data)
 			cache_operation(TEE_CACHEINVALIDATE, out_buf.data,
 				out_buf.length);
 
-		BLOB_DUMPBUF("Output", out_buf.data, out_buf.length);
-
 		if (retS == 1) {
 			/*
 			 * Copy the result data in the correct output
-- 
2.25.1

