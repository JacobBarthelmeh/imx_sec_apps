From e578a4052e84448289f070cefbbd8a19cc535a0a Mon Sep 17 00:00:00 2001
From: Marouene Boubakri <marouene.boubakri@nxp.com>
Date: Wed, 04 Dec 2019 09:57:29 +0200
Subject: [PATCH] Full Disk Encryption using CAAM Secure Key

---
 arch/arm64/configs/defconfig     |  16 +
 crypto/testmgr.c                 | 377 ++++++++++++++++++++++-
 drivers/crypto/caam/Kconfig      |  51 +++-
 drivers/crypto/caam/Makefile     |   6 +
 drivers/crypto/caam/black_keys.c | 317 ++++++++++++++++++++
 drivers/crypto/caam/blob.c       | 510 ++++++++++++++++++++++++++++++++
 drivers/crypto/caam/caam.h       |  41 +++
 drivers/crypto/caam/caam_desc.c  | 548 ++++++++++++++++++++++++++++++++++
 drivers/crypto/caam/caam_desc.h  | 117 ++++++++
 drivers/crypto/caam/caam_key.c   | 623 +++++++++++++++++++++++++++++++++++++++
 drivers/crypto/caam/caam_key.h   |  58 ++++
 drivers/crypto/caam/caam_util.c  | 233 +++++++++++++++
 drivers/crypto/caam/caam_util.h  | 130 ++++++++
 drivers/crypto/caam/desc.h       |   3 +
 drivers/crypto/caam/jr.c         |  45 +++
 drivers/crypto/caam/sm.h         |  35 +--
 drivers/crypto/caam/sm_store.c   | 581 ++----------------------------------
 drivers/crypto/caam/sm_test.c    | 189 ++++++++++--
 drivers/md/dm-crypt.c            |  43 +--
 include/linux/key-type.h         |   3 +
 20 files changed, 3287 insertions(+), 639 deletions(-)
 create mode 100644 drivers/crypto/caam/black_keys.c
 create mode 100644 drivers/crypto/caam/blob.c
 create mode 100644 drivers/crypto/caam/caam.h
 create mode 100644 drivers/crypto/caam/caam_desc.c
 create mode 100644 drivers/crypto/caam/caam_desc.h
 create mode 100644 drivers/crypto/caam/caam_key.c
 create mode 100644 drivers/crypto/caam/caam_key.h
 create mode 100644 drivers/crypto/caam/caam_util.c
 create mode 100644 drivers/crypto/caam/caam_util.h

diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 211e517..0e29c34 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -809,6 +809,9 @@ CONFIG_CRYPTO_DEV_FSL_CAAM=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_DESC=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLOB=y
 CONFIG_ARM64_CRYPTO=y
 CONFIG_CRYPTO_SHA512_ARM64=m
 CONFIG_CRYPTO_SHA1_ARM64_CE=y
@@ -820,3 +823,16 @@ CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_CHACHA20_NEON=m
 CONFIG_CRYPTO_AES_ARM64_BS=m
+# Enable dm-crypt and its dependencies
+CONFIG_BLK_DEV_DM=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD=y
+CONFIG_DM_CRYPT=y
+# Force test of caamalg algos
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=n
+# Create RAM disks
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=300000
+CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API=y
+CONFIG_CAAM_KEYS=y
diff --git a/crypto/testmgr.c b/crypto/testmgr.c
index 5b20f32..3045939 100644
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@ -37,6 +37,10 @@
 
 #include "internal.h"
 
+#include "../../drivers/crypto/caam/tag_object.h"
+#include "../../drivers/crypto/caam/caam_util.h"
+#include "../../drivers/crypto/caam/caam_desc.h"
+
 static bool notests;
 module_param(notests, bool, 0644);
 MODULE_PARM_DESC(notests, "disable crypto self-tests");
@@ -1750,20 +1754,22 @@ static int alg_test_skcipher(const struct alg_test_desc *desc,
 
 	tfm = crypto_alloc_skcipher(driver, type, mask);
 	if (IS_ERR(tfm)) {
-		printk(KERN_ERR "alg: skcipher: Failed to load transform for "
-		       "%s: %ld\n", driver, PTR_ERR(tfm));
+		pr_err("alg: skcipher: Failed to load transform for %s: %ld\n",
+		       driver, PTR_ERR(tfm));
 		return PTR_ERR(tfm);
 	}
 
 	if (desc->suite.cipher.enc.vecs) {
-		err = test_skcipher(tfm, ENCRYPT, desc->suite.cipher.enc.vecs,
+		err = test_skcipher(tfm, ENCRYPT,
+				    desc->suite.cipher.enc.vecs,
 				    desc->suite.cipher.enc.count);
 		if (err)
 			goto out;
 	}
 
 	if (desc->suite.cipher.dec.vecs)
-		err = test_skcipher(tfm, DECRYPT, desc->suite.cipher.dec.vecs,
+		err = test_skcipher(tfm, DECRYPT,
+				    desc->suite.cipher.dec.vecs,
 				    desc->suite.cipher.dec.count);
 
 out:
@@ -1771,6 +1777,345 @@ static int alg_test_skcipher(const struct alg_test_desc *desc,
 	return err;
 }
 
+#if defined(CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API)
+
+#if defined(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY)
+
+/* Structure passed as contect when testing tk algorithm */
+struct black_key_ctx {
+	u8 auth;
+};
+
+static int create_black_key(struct device *jrdev, struct cipher_testvec *tv,
+			    u8 auth)
+{
+	int ret;
+	char *black_key;
+	size_t black_key_length;
+	u32 tagged_key_length;
+	struct tag_object_conf tag;
+	enum tag_type type;
+
+	if (auth) {
+		black_key_length = CCM_BLACK_KEY_SIZE(tv->klen);
+		type = TAG_TYPE_BLACK_KEY_CCM;
+	} else {
+		black_key_length = ECB_BLACK_KEY_SIZE(tv->klen);
+		type = TAG_TYPE_BLACK_KEY_ECB;
+	}
+	tagged_key_length = black_key_length + TAG_OVERHEAD;
+
+	black_key = kzalloc(black_key_length, GFP_KERNEL | GFP_DMA);
+	if (!black_key) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	/* Create black key */
+	ret = caam_black_key(jrdev,
+			     tv->key, tv->klen, DATA_GENMEM,
+			     black_key, &black_key_length,
+			     DATA_GENMEM, auth, UNTRUSTED_KEY);
+	if (ret) {
+		pr_err("Encapsulation fail: %d\n", ret);
+		goto free_black_key;
+	}
+
+	/* Encapsulate the black key */
+	init_tag_object_header(&tag.header, type);
+	init_blackey_conf(&tag.conf.bk_conf, tv->klen, auth, false);
+
+	ret = set_tag_object_conf(&tag, black_key, black_key_length,
+				  &tagged_key_length);
+	if (ret) {
+		pr_err("Tagging fail: %d\n", ret);
+		goto free_black_key;
+	}
+
+	/* Update the test vector */
+	tv->key = black_key;
+	tv->klen = tagged_key_length;
+
+	goto exit;
+
+free_black_key:
+	kfree(black_key);
+
+exit:
+	return ret;
+}
+
+static void free_black_key(struct cipher_testvec *tv)
+{
+	kfree(tv->key);
+}
+
+/*
+ * Transform the plainkeys in the test description into black keys
+ * The black key allcated must be free with free_black_keys_cipher()
+ */
+static int transform_test_desc_cipher(struct alg_test_desc *copy_desc,
+				      void *ctx)
+{
+	int i;
+	int ret = 0;
+	struct black_key_ctx *bk_ctx = ctx;
+	u8 auth = bk_ctx->auth;
+	struct cipher_testvec *encs;
+	struct cipher_testvec *decs;
+	struct device *jrdev;
+
+	/* Set the list of enc and dec vectors */
+	encs = (struct cipher_testvec *)copy_desc->suite.cipher.enc.vecs;
+	decs = (struct cipher_testvec *)copy_desc->suite.cipher.dec.vecs;
+
+	/* Allocate a jobring */
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev)) {
+		ret = PTR_ERR(jrdev);
+		goto exit;
+	}
+
+	/* Loop over the keys in the test suite to make tagged key */
+
+	/* Encryption test vectors */
+	for (i = 0; i < copy_desc->suite.cipher.enc.count; i++) {
+		ret = create_black_key(jrdev, &encs[i], auth);
+		if (ret) {
+			int j;
+
+			/* Free the keys already allocated */
+			for (j = i - 1; j >= 0; j--)
+				free_black_key(&encs[j]);
+
+			goto exit;
+		}
+	}
+
+	/* Decryption test vectors */
+	for (i = 0; i < copy_desc->suite.cipher.dec.count; i++) {
+		ret = create_black_key(jrdev, &decs[i], auth);
+		if (ret) {
+			int j;
+
+			/* Free the keys already allocated */
+			for (j = i - 1; j >= 0; j--)
+				free_black_key(&decs[j]);
+			for (j = copy_desc->suite.cipher.enc.count; j >= 0; j--)
+				free_black_key(&encs[j]);
+
+			goto exit;
+		}
+	}
+
+exit:
+	caam_jr_free(jrdev);
+
+	return ret;
+}
+
+/* Free the black keys allocated in a test description */
+static void free_black_keys_cipher(struct alg_test_desc *desc, void *ctx)
+{
+	int i;
+	struct cipher_testvec *encs;
+	struct cipher_testvec *decs;
+
+	encs = (struct cipher_testvec *)desc->suite.cipher.enc.vecs;
+	decs = (struct cipher_testvec *)desc->suite.cipher.dec.vecs;
+
+	for (i = 0; i < desc->suite.cipher.enc.count; i++)
+		free_black_key(&encs[i]);
+
+	for (i = 0; i < desc->suite.cipher.dec.count; i++)
+		free_black_key(&decs[i]);
+}
+#endif /* CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY */
+
+/*
+ * Make a deep copy of the test description except the values tested
+ * To be freed with free_test_desc_cipher()
+ */
+static
+struct alg_test_desc *copy_test_desc_cipher(const struct alg_test_desc *desc)
+{
+	int ret = 0;
+	int i;
+	struct alg_test_desc *copy_desc;
+	const struct cipher_testvec *encs, *decs;
+	struct cipher_testvec *copy_encs, *copy_decs;
+
+	encs = desc->suite.cipher.enc.vecs;
+	decs = desc->suite.cipher.dec.vecs;
+
+	/*
+	 * Perform a deep copy of the test description for cipher
+	 * We need to copy:
+	 *  - main structure
+	 *  - encryptions vectors
+	 *  - decryption vectors
+	 */
+	copy_desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+	if (!copy_desc) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	copy_encs = kcalloc(desc->suite.cipher.enc.count, sizeof(*encs),
+			    GFP_KERNEL);
+	if (!copy_encs) {
+		ret = -ENOMEM;
+		goto free_copy_desc;
+	}
+
+	copy_decs = kcalloc(desc->suite.cipher.dec.count, sizeof(*decs),
+			    GFP_KERNEL);
+	if (!copy_decs) {
+		ret = -ENOMEM;
+		goto free_copy_encs;
+	}
+
+	/* Copy the main structure */
+	memcpy(copy_desc, desc, sizeof(*desc));
+
+	/* Copy encryption vectors */
+	copy_desc->suite.cipher.enc.vecs = copy_encs;
+	for (i = 0; i < desc->suite.cipher.enc.count; i++)
+		memcpy(&copy_encs[i], &encs[i], sizeof(*encs));
+
+	/* Copy decryption vectors */
+	copy_desc->suite.cipher.dec.vecs = copy_decs;
+	for (i = 0; i < desc->suite.cipher.dec.count; i++)
+		memcpy(&copy_decs[i], &decs[i], sizeof(*decs));
+
+	goto exit;
+
+free_copy_encs:
+	kfree(copy_encs);
+
+free_copy_desc:
+	kfree(copy_desc);
+
+exit:
+	return (ret) ? NULL : copy_desc;
+}
+
+/* Free a test description copied with copy_test_desc_cipher() */
+static void free_test_desc_cipher(struct alg_test_desc *desc)
+{
+	struct cipher_testvec *encs, *decs;
+
+	encs = (struct cipher_testvec *)desc->suite.cipher.enc.vecs;
+	decs = (struct cipher_testvec *)desc->suite.cipher.dec.vecs;
+
+	kfree(encs);
+	kfree(decs);
+
+	kfree(desc);
+}
+
+/*
+ * Structure passed to alg_test_tk_skcipher() to modify the test vector
+ * depending on the tk type to test
+ */
+struct tk_test_config {
+	/* Function to transform the test vector */
+	int (*transform_test_desc)(struct alg_test_desc *desc, void *ctx);
+
+	/* Function to free the test vector transformed */
+	void (*free_transform_test_desc)(struct alg_test_desc *desc, void *ctx);
+
+	/* Data to pass to the functions */
+	void *ctx;
+};
+
+/* Test the implementation of an algo which takes black keys tagged as input */
+static int alg_test_tk_config(const struct alg_test_desc *desc,
+			      const char *driver, u32 type, u32 mask,
+			      const struct tk_test_config *tk_config,
+			      int (*alg_test)(const struct alg_test_desc *desc,
+					      const char *driver, u32 type,
+					      u32 mask))
+{
+	int err = 0;
+	struct alg_test_desc *copy_desc;
+
+	if (!desc || !driver || !tk_config || !alg_test ||
+	    !tk_config->transform_test_desc)
+		return -EINVAL;
+
+	/* Copy the input test description */
+	copy_desc = copy_test_desc_cipher(desc);
+	if (!copy_desc)
+		return -ENOMEM;
+
+	/* Transform the copy of the test descriptor */
+	err = tk_config->transform_test_desc(copy_desc, tk_config->ctx);
+	if (err)
+		goto exit;
+
+	/* Test the test description */
+	err = alg_test(copy_desc, driver, type, mask);
+
+	/* Free memory allocated during the transformation */
+	if (tk_config->free_transform_test_desc)
+		tk_config->free_transform_test_desc(copy_desc, tk_config->ctx);
+
+exit:
+	/* Free test description copied */
+	free_test_desc_cipher(copy_desc);
+
+	return err;
+}
+
+static int alg_test_tk_skcipher(const struct alg_test_desc *desc,
+				const char *driver, u32 type, u32 mask)
+{
+	int i;
+	int ret = -EINVAL;
+
+#if defined(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY)
+	/* TK configs for black keys with both encryptions */
+	struct black_key_ctx bk_ctx_ecb = {KEY_COVER_ECB};
+	struct tk_test_config tk_config_bk_ecb = {
+		transform_test_desc_cipher,
+		free_black_keys_cipher,
+		&bk_ctx_ecb,
+	};
+
+	struct black_key_ctx bk_ctx_ccm = {KEY_COVER_CCM};
+	struct tk_test_config tk_config_bk_ccm = {
+		transform_test_desc_cipher,
+		free_black_keys_cipher,
+		&bk_ctx_ccm,
+	};
+#endif
+
+	/* The list of tk configs to test */
+	struct tk_test_config *tk_config_list[] = {
+#if defined(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY)
+		&tk_config_bk_ecb,
+		&tk_config_bk_ccm,
+#endif
+	};
+
+	/* Check input */
+	if (!desc || !driver)
+		goto exit;
+
+	/* Loop over the tk configs and test them */
+	for (i = 0; i < ARRAY_SIZE(tk_config_list); i++) {
+		ret = alg_test_tk_config(desc, driver, type, mask,
+					 tk_config_list[i], alg_test_skcipher);
+		if (ret)
+			goto exit;
+	}
+
+exit:
+	return ret;
+}
+#endif /* CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API */
+
 static int alg_test_comp(const struct alg_test_desc *desc, const char *driver,
 			 u32 type, u32 mask)
 {
@@ -3501,7 +3846,7 @@ static const struct alg_test_desc alg_test_descs[] = {
 		.suite = {
 			.hash = __VECS(sha512_tv_template)
 		}
-	}, {
+	},  {
 		.alg = "tgr128",
 		.test = alg_test_hash,
 		.suite = {
@@ -3519,7 +3864,29 @@ static const struct alg_test_desc alg_test_descs[] = {
 		.suite = {
 			.hash = __VECS(tgr192_tv_template)
 		}
+	},
+#if defined(CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API)
+	{
+		.alg = "tk-cbc-aes-caam",
+		.test = alg_test_tk_skcipher,
+		.suite = {
+			.cipher = {
+				.enc = __VECS(aes_cbc_enc_tv_template),
+				.dec = __VECS(aes_cbc_dec_tv_template)
+			}
+		}
 	}, {
+		.alg = "tk-ecb-aes-caam",
+		.test = alg_test_tk_skcipher,
+		.suite = {
+			.cipher = {
+				.enc = __VECS(aes_enc_tv_template),
+				.dec = __VECS(aes_dec_tv_template)
+			}
+		}
+	},
+#endif
+	{
 		.alg = "vmac(aes)",
 		.test = alg_test_hash,
 		.suite = {
diff --git a/drivers/crypto/caam/Kconfig b/drivers/crypto/caam/Kconfig
index 4b9168f..ea9d037 100644
--- a/drivers/crypto/caam/Kconfig
+++ b/drivers/crypto/caam/Kconfig
@@ -146,6 +146,7 @@ config CRYPTO_DEV_FSL_CAAM_RNG_API
 config CRYPTO_DEV_FSL_CAAM_TK_API
 	bool "Register tagged key cryptography implementations with Crypto API"
 	depends on CRYPTO_DEV_FSL_CAAM_CRYPTO_API
+	default n
 	help
 	  Selecting this will register algorithms supporting tagged
 	  key.
@@ -187,7 +188,7 @@ config CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE
 
 config CRYPTO_DEV_FSL_CAAM_SM_TEST
 	tristate "CAAM Secure Memory - Keystore Test/Example (EXPERIMENTAL)"
-	depends on CRYPTO_DEV_FSL_CAAM_SM
+	depends on CRYPTO_DEV_FSL_CAAM_SM && CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY && CRYPTO_DEV_FSL_CAAM_UTIL_BLOB
 	default n
 	help
 	  Example thread to exercise the Keystore API and to verify that
@@ -213,3 +214,51 @@ config CRYPTO_DEV_FSL_CAAM_DEBUG
 config CRYPTO_DEV_FSL_CAAM_CRYPTO_API_DESC
 	def_tristate (CRYPTO_DEV_FSL_CAAM_CRYPTO_API || \
 		      CRYPTO_DEV_FSL_CAAM_CRYPTO_API_QI)
+
+config CRYPTO_DEV_FSL_CAAM_DESC
+	bool "Add descriptor constructor for common operation"
+	default n
+	help
+	  Selecting this will add generic descriptor constructor. These
+	  descriptor constructor can help to produce a valid descriptor which
+	  can be provided to CAAM. The constructor available are for example:
+	  covering of key, encapsulation and decapsulation of blobs
+
+config CRYPTO_DEV_FSL_CAAM_UTIL
+	def_bool (CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY || \
+		      CRYPTO_DEV_FSL_CAAM_UTIL_BLOB)
+
+config CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY
+	bool "Enable utility function to cover keys"
+	default n
+	depends on CRYPTO_DEV_FSL_CAAM_DESC && CRYPTO_DEV_FSL_CAAM_JR
+	help
+	  Selecting this will add utility functions to easily create red and
+	  black keys using the CAAM and test their loading by the CAAM.
+	  Using these functions reduce the code needed to do these operations.
+	  The utility functions does not handle batch of operations hence are
+	  not optimal for performance.
+
+config CRYPTO_DEV_FSL_CAAM_UTIL_BLOB
+	bool "Enable utility function to create blobs"
+	default n
+	depends on CRYPTO_DEV_FSL_CAAM_DESC && CRYPTO_DEV_FSL_CAAM_JR
+	help
+	  Selecting this will add utility functions to easily encapsulate or
+	  decapsulate red and black blobs.
+	  Using these functions reduce the code needed to do these operations.
+	  The utility functions does not handle batch of operations hence are
+	  not optimal for performance.
+
+config CAAM_KEYS
+	tristate "CAAM_KEYS"
+	default n
+	depends on KEYS && CRYPTO_DEV_FSL_CAAM_JR && CRYPTO_DEV_FSL_CAAM_TK_API && CRYPTO_DEV_FSL_CAAM_UTIL
+	help
+	  This option provide support for creating caam key in kernel. CAAM keys
+	  are keys encrypted by value only accessible by CAAM hardware. The key
+	  is stored in a black key for use or in a black blob for storing between power cycle.
+	  The userspace nether has access to the key used for encryption.
+	  The keys are only usable by transformation defined by the CAAM.
+
+	  If you are unsure as to whether this is required, answer N.
diff --git a/drivers/crypto/caam/Makefile b/drivers/crypto/caam/Makefile
index 229e7d9..3db6756 100644
--- a/drivers/crypto/caam/Makefile
+++ b/drivers/crypto/caam/Makefile
@@ -17,6 +17,10 @@ obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_PKC_API) += caam_pkc.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SM) += sm_store.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST) += sm_test.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO) += secvio.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_DESC) += caam_desc.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL) += caam_util.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY) += black_keys.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLOB) += blob.o
 
 caam-objs := ctrl.o
 caam_jr-objs := jr.o key_gen.o error.o inst_rng.o
@@ -27,3 +31,5 @@ ifneq ($(CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API_QI),)
 endif
 
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API) += tag_object.o
+
+obj-$(CONFIG_CAAM_KEYS) += caam_key.o
diff --git a/drivers/crypto/caam/black_keys.c b/drivers/crypto/caam/black_keys.c
new file mode 100644
index 0000000..7d756df
--- /dev/null
+++ b/drivers/crypto/caam/black_keys.c
@@ -0,0 +1,317 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Key covering function for CAAM
+ *
+ * Copyright 2018 NXP
+ */
+
+#include "caam.h"
+#include "desc.h"
+#include "caam_desc.h"
+#include "caam_util.h"
+#include "desc_constr.h"
+
+/**
+ * @brief         Cover a key and create a black key
+ *
+ * @details       Details:
+ * - If @b memtype is setted to @b DATA_SECMEM, the key to cover is read
+ *   directly by the CAAM from Secure Memeory without intermediate copy. The
+ *   value of @b key must be a physical address in secure memory.
+ * - The parameter @b black_key_length is used to check the output memory can
+ *   store the covered key and inform the user of the size of the covered key.
+ *
+ * @attention     Limited to class 1 keys at the present time
+ *
+ * @attention     The input and output data are copied to temporary arrays
+ *                except for @b key if @b memtype is @b DATA_SECMEM.
+ *
+ * @param[in]     jrdev              The jrdev
+ * @param[in]     key                The key
+ * @param[in]     key_length         The key length
+ * @param[in]     key_memtype        The memtype
+ * @param[out]    black_key          The black key
+ * @param[in,out] black_key_length   The black key length
+ * @param[in]     black_key_memtype  The black key memtype
+ * @param[in]     keyauth            The keyauth
+ * @param[in]     trusted_key        The trusted key
+ *
+ * @return        0 if no error, otherwise error code
+ */
+int caam_black_key(struct device *jrdev,
+		   const void *key, size_t key_length, u8 key_memtype,
+		   void *black_key, size_t *black_key_length,
+		   u8 black_key_memtype, u8 keyauth, u8 trusted_key)
+{
+	int retval = 0;
+	u32 dsize, jstat;
+	u32 __iomem *coverdesc = NULL;
+	size_t black_key_length_req = 0;
+
+	u8 *temp_key = NULL;
+	caam_dma_addr_t key_dma;
+	u8 *temp_black_key = NULL;
+	caam_dma_addr_t black_key_dma;
+
+	/* Check input */
+	if (!jrdev)
+		return -EINVAL;
+
+//#ifdef DEBUG
+	dev_info(jrdev, "%s input: [key: %p(%zu) black_key: %p(%zu), auth: %x]",
+		 __func__, key, key_length,
+		 black_key, *black_key_length, keyauth);
+//#endif
+
+	/* Trusted key not supported */
+	if (trusted_key == TRUSTED_KEY)
+		return -EINVAL;
+
+	if (!key || !black_key)
+		return -EINVAL;
+
+	if (!is_memory_type(key_memtype) ||
+	    !is_memory_type(black_key_memtype) ||
+	    !is_auth(keyauth) ||
+	    !is_trusted_key(trusted_key))
+		return -EINVAL;
+
+	/* Advanced tests */
+	if (keyauth == KEY_COVER_ECB) {
+		black_key_length_req = ECB_BLACK_KEY_SIZE(key_length);
+		if (*black_key_length < black_key_length_req) {
+			*black_key_length = black_key_length_req;
+			return -EINVAL;
+		}
+	} else if (keyauth == KEY_COVER_CCM) {
+		black_key_length_req = CCM_BLACK_KEY_SIZE(key_length);
+		if (*black_key_length < black_key_length_req) {
+			*black_key_length = black_key_length_req;
+			return -EINVAL;
+		}
+	}
+	*black_key_length = key_length;
+
+	if (black_key_memtype == DATA_SECMEM) {
+		black_key_dma = get_caam_dma_addr(black_key);
+		if (black_key_dma == 0)
+			return -EINVAL;
+	}
+
+//#ifdef DEBUG
+	dev_info(jrdev, "%s processing: [key: %p(%zu) black_key: %p(%zu)",
+		 __func__, key, key_length, black_key, *black_key_length);
+	dev_info(jrdev, "req:%zu, auth: 0x%x]", black_key_length_req, keyauth);
+//#endif
+
+	if (key_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, key, key_length,
+				       &key_dma, &temp_key)) {
+			dev_err(jrdev, "unable to prepare key: %p\n", key);
+			retval = -ENOMEM;
+			goto exit;
+		}
+	} else {
+		key_dma = get_caam_dma_addr(key);
+		if (key_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (black_key_memtype == DATA_GENMEM) {
+		if (prepare_read_data(jrdev, black_key_length_req,
+				      &black_key_dma, &temp_black_key)) {
+			dev_err(jrdev, "unable to prepare cover key\n");
+			retval = -ENOMEM;
+			goto unprepare_key;
+		}
+	} else {
+		black_key_dma = get_caam_dma_addr(black_key);
+		if (black_key_dma == 0)
+			return -ENOMEM;
+	}
+
+	dsize = cnstr_black_key_jobdesc(&coverdesc, key_dma, key_length,
+					black_key_dma, *black_key_length,
+					keyauth, trusted_key);
+	if (!dsize) {
+		dev_err(jrdev, "failed to construct the cover descriptor:\n");
+		retval = -ENOMEM;
+		goto unprepare_black_key;
+	}
+
+	jstat = jr_run_job_and_wait_completion(jrdev, coverdesc);
+	if (jstat) {
+		dev_err(jrdev, "Covering job failed\n");
+		retval = -EIO;
+		goto free_desc;
+	}
+
+	if (black_key_memtype == DATA_GENMEM) {
+		read_data_prepared(jrdev, black_key, black_key_dma,
+				   temp_black_key, black_key_length_req);
+	}
+
+	/* Update with correct size */
+	*black_key_length = black_key_length_req;
+
+free_desc:
+	kfree(coverdesc);
+
+unprepare_black_key:
+	if (black_key_memtype == DATA_GENMEM)
+		unprepare_read_data(jrdev, black_key_dma, temp_black_key,
+				    black_key_length_req);
+
+unprepare_key:
+	if (key_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, key_dma, temp_key, key_length);
+
+exit:
+	return retval;
+}
+EXPORT_SYMBOL(caam_black_key);
+
+int caam_random_black_key(struct device *jrdev,
+			  size_t key_length,
+			  void *black_key, size_t *black_key_length,
+			  u8 black_key_memtype, u8 keyauth, u8 trusted_key)
+{
+	int retval = 0;
+	u32 jstat;
+	u32 __iomem *coverdesc = NULL;
+	size_t black_key_length_req = 0;
+
+	u8 *temp_black_key = NULL;
+	caam_dma_addr_t black_key_dma;
+
+	/* Check job ring */
+	if (!jrdev)
+		return -EINVAL;
+
+//#ifdef DEBUG
+	dev_info(jrdev, "%s input: [key: (%zu) black_key: %p(%zu), auth: %x]",
+		 __func__, key_length,
+		 black_key, *black_key_length, keyauth);
+//#endif
+
+	/* Advanced tests */
+	if (keyauth == KEY_COVER_ECB)
+		black_key_length_req = ECB_BLACK_KEY_SIZE(key_length);
+	else if (keyauth == KEY_COVER_CCM)
+		black_key_length_req = CCM_BLACK_KEY_SIZE(key_length);
+
+	if (*black_key_length < black_key_length_req) {
+		*black_key_length = black_key_length_req;
+		return -EINVAL;
+	}
+	*black_key_length = key_length;
+
+//#ifdef DEBUG
+	dev_info(jrdev, "%s processing: [key: (%zu) black_key: %p(%zu)",
+		 __func__, key_length, black_key, *black_key_length);
+	dev_info(jrdev, "req:%zu, auth: 0x%x]", black_key_length_req, keyauth);
+//#endif
+
+	if (prepare_read_data(jrdev, black_key_length_req,
+			      &black_key_dma, &temp_black_key)) {
+		dev_err(jrdev, "unable to prepare covered random key\n");
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	retval = cnstr_random_black_key_jobdesc(&coverdesc, key_length,
+						black_key_dma,
+						*black_key_length,
+						keyauth, trusted_key);
+	if (retval) {
+		dev_err(jrdev,
+			"failed to construct the cover random descriptor\n");
+		goto unprepare_black_key;
+	}
+
+	jstat = jr_run_job_and_wait_completion(jrdev, coverdesc);
+	if (jstat) {
+		dev_err(jrdev, "Covering random job failed\n");
+		retval = -EIO;
+		goto free_desc;
+	}
+
+	read_data_prepared(jrdev, black_key, black_key_dma,
+			   temp_black_key, black_key_length_req);
+
+	*black_key_length = black_key_length_req;
+
+	retval = 0;
+
+free_desc:
+	kfree(coverdesc);
+
+unprepare_black_key:
+	unprepare_read_data(jrdev, black_key_dma, temp_black_key,
+			    black_key_length_req);
+
+exit:
+	return retval;
+}
+EXPORT_SYMBOL(caam_random_black_key);
+
+/* Test of black key generation depending on secret size */
+
+#include <linux/module.h>
+
+#define MAX_INPUT_SIZE 64
+
+static char input[MAX_INPUT_SIZE];
+static char output[MAX_INPUT_SIZE + CCM_OVERHEAD];
+
+int create_black_key_size_n(struct device *jrdev, size_t n, u8 auth)
+{
+	int ret;
+	size_t output_size = sizeof(output);
+
+	ret = caam_black_key(jrdev,
+			     input, n, DATA_GENMEM,
+			     output, &output_size,
+			     DATA_GENMEM, auth, UNTRUSTED_KEY);
+	if (ret)
+		pr_err("Creation of black key size: %zd, auth: %d -> %d",
+		       n, auth, ret);
+
+	return (ret) ? 1 : 0;
+}
+
+int bk_test(void)
+{
+	int nb_errors = 0;
+	int i;
+	struct device *jrdev;
+
+	jrdev = caam_jr_alloc();
+	if (!jrdev)
+		return -ENOMEM;
+
+	for (i = 1; i <= MAX_INPUT_SIZE; i++) {
+		pr_info("Size %d\n", i);
+		nb_errors += create_black_key_size_n(jrdev, i, KEY_COVER_ECB);
+		nb_errors += create_black_key_size_n(jrdev, i, KEY_COVER_CCM);
+	}
+
+	pr_info("Nb errors: %d\n", nb_errors);
+
+	return nb_errors;
+}
+
+int bk_init(void)
+{
+#ifdef DEBUG
+	return bk_test();
+#endif
+	return 0;
+}
+
+void bk_exit(void)
+{
+}
+
+module_init(bk_init)
+module_exit(bk_exit)
diff --git a/drivers/crypto/caam/blob.c b/drivers/crypto/caam/blob.c
new file mode 100644
index 0000000..8994dc8
--- /dev/null
+++ b/drivers/crypto/caam/blob.c
@@ -0,0 +1,510 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Blob encapsulation/decapsulation functions for CAAM
+ *
+ * Copyright 2018 NXP
+ */
+
+#include "caam.h"
+#include "desc.h"
+#include "caam_desc.h"
+#include "caam_util.h"
+
+/**
+ * @brief         Perform the encapsulation of a secret in a blob
+ *
+ * @details       Details:
+ * - If @b memtype is setted to @b DATA_SECMEM, the secret to encapsulate is
+ *   read directly by the CAAM from Secure Memeory without intermediate copy.
+ *   The value of @b secret must be a physical address in secure memory.
+ *
+ * - The parameter @b keymod_length is used to check the size of the key
+ *   modifier is long enough, else the function will fail with the appropriate
+ *   size set.
+ *
+ * - The parameter @b blob_length is used to check the size of the output for
+ *   the blob is long enough, else the function will fail with the appropriate
+ *   size set.
+ *
+ * - The parameter @b key_length_in_secret is used to indicate the real size of
+ *   the key to encapsulate in the case it is a black key.
+ *
+ * @attention     The input and output data are copied to temporary arrays
+ *                except for @b secret if @b memtype is @b DATA_SECMEM.
+ *
+ * @param[in]     jrdev                 The jrdev
+ * @param[in]     secret                The secret
+ * @param[in]     secret_length         The secret length
+ * @param[in]     secret_memtype        The secret memtype
+ * @param[in]     keycolor              The keycolor
+ * @param[in]     key_length_in_secret  The key length in secret, if the secret
+ *                                      to encapsulate is a covered key (black
+ *                                      key), the original size of the key must
+ *                                      be provided.
+ * @param[in]     auth                  The auth
+ * @param[in]     trusted_key           The trusted key
+ * @param[in]     keymod                The keymod
+ * @param[in,out] keymod_length         The keymod length
+ * @param[in]     keymod_memtype        The keymod memtype
+ * @param[out]    blob                  The blob
+ * @param[in,out] blob_length           The blob length
+ * @param[in]     blob_memtype          The memtype
+ * @param[in]     blobcolor             The blobcolor
+ *
+ * @return        0 if no error, otherwise error code
+ */
+int caam_blob_encap(struct device *jrdev,
+		    const void  *secret, size_t secret_length,
+		    u8 secret_memtype,
+		    u8 keycolor, size_t key_length_in_secret,
+		    u8 auth, u8 trusted_key,
+		    const void *keymod, size_t *keymod_length,
+		    u8 keymod_memtype,
+		    void *blob, size_t *blob_length,
+		    u8 blob_memtype, u8 blobcolor)
+{
+	int retval = 0;
+	u32 dsize, jstat;
+	u32 __iomem *blob_encap = NULL;
+	size_t secret_length_for_cnstr = 0;
+
+	u8 *temp_secret = NULL;
+	caam_dma_addr_t secret_dma;
+	u8 *temp_keymod = NULL;
+	caam_dma_addr_t keymod_dma;
+	u8 *temp_blob = NULL;
+	caam_dma_addr_t blob_dma;
+
+	/*
+	 * basic checks
+	 */
+
+	/* Check job ring */
+	if (!jrdev)
+		return -EINVAL;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s input:[secret: %p(%zu) color:%x auth:%x, memtype:%x",
+		 __func__, secret, secret_length, keycolor, auth,
+		 secret_memtype);
+	dev_info(jrdev, ", keymod: %p(%zu), memtype:%x",
+		 keymod, *keymod_length, keymod_memtype);
+	dev_info(jrdev, "blob: %p(%zu), memtype:%x color: %x]",
+		 blob, *blob_length, blob_memtype, blobcolor);
+#endif
+
+	/* Check input buffers */
+	if (!secret || !keymod || !blob)
+		return -EINVAL;
+
+	/* Check values */
+	if (!is_memory_type(secret_memtype) ||
+	    !is_key_color(keycolor) ||
+	    !is_memory_type(keymod_memtype) ||
+	    !is_memory_type(blob_memtype) ||
+	    !is_blob_color(blobcolor))
+		return -EINVAL;
+
+	if (keycolor == BLACK_KEY) {
+		if (!is_auth(auth) || !is_trusted_key(trusted_key))
+			return -EINVAL;
+
+		/* Trusted key not supported */
+		if (trusted_key == TRUSTED_KEY)
+			return -EINVAL;
+	} else {
+		auth = KEY_COVER_ECB; // No value for auth for red keys
+	}
+
+	/*
+	 * Advanced checks
+	 */
+
+	/* Check the keymod is long enough */
+	if (secret_memtype == DATA_SECMEM) {
+		if (*keymod_length < KEYMOD_SIZE_SM) {
+			*keymod_length = KEYMOD_SIZE_SM;
+			return -EINVAL;
+		}
+		*keymod_length = KEYMOD_SIZE_SM;
+	} else {
+		if (*keymod_length < KEYMOD_SIZE_GM) {
+			*keymod_length = KEYMOD_SIZE_GM;
+			return -EINVAL;
+		}
+		*keymod_length = KEYMOD_SIZE_GM;
+	}
+
+	/* A black key cannot be stored in a red blob */
+	if (keycolor == BLACK_KEY && blobcolor == RED_BLOB)
+		return -EINVAL;
+
+	/* A red key can only be put in a black blob if it comes from secure
+	 * memory
+	 */
+	if (keycolor == RED_KEY && blobcolor == BLACK_BLOB)
+		if (secret_memtype != DATA_SECMEM)
+			return -EINVAL;
+
+	/* adapt the size of the black key */
+	secret_length_for_cnstr = secret_length;
+	if (keycolor == BLACK_KEY)
+		secret_length_for_cnstr = key_length_in_secret;
+
+	/* Check the blob can be stored */
+	if ((secret_length_for_cnstr + BLOB_OVERHEAD) > *blob_length) {
+		*blob_length = (secret_length_for_cnstr + BLOB_OVERHEAD);
+		return -EINVAL;
+	}
+	*blob_length = secret_length_for_cnstr + BLOB_OVERHEAD;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s processing: [secret: %p(%zu) cnstr:%zu",
+		 __func__,
+		 secret, secret_length, secret_length_for_cnstr);
+	dev_info(jrdev, " color:%x auth:%x, memtype:%x,",
+		 keycolor, auth, secret_memtype);
+	dev_info(jrdev, ", keymod: %p(%zu), memtype:%x",
+		 keymod, *keymod_length, keymod_memtype);
+	dev_info(jrdev, "blob: %p(%zu), memtype:%x color: %x]",
+		 blob, *blob_length, blob_memtype, blobcolor);
+#endif
+
+	if (secret_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, secret, secret_length,
+				       &secret_dma, &temp_secret)) {
+			dev_err(jrdev, "unable to prepare secret: %p\n",
+				secret);
+			retval = -ENOMEM;
+			goto exit;
+		}
+	} else {
+		secret_dma = get_caam_dma_addr(secret);
+		if (secret_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (keymod_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, keymod, *keymod_length,
+				       &keymod_dma, &temp_keymod)) {
+			dev_err(jrdev, "unable to prepare keymod: %p\n",
+				keymod);
+			retval = -ENOMEM;
+			goto unprepare_secret;
+		}
+	} else {
+		keymod_dma = get_caam_dma_addr(secret);
+		if (secret_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (blob_memtype == DATA_GENMEM) {
+		if (prepare_read_data(jrdev, *blob_length, &blob_dma,
+				      &temp_blob)) {
+			dev_err(jrdev, "unable to prepare blob\n");
+			retval = -ENOMEM;
+			goto unprepare_keymod;
+		}
+	} else {
+		blob_dma = get_caam_dma_addr(secret);
+		if (secret_dma == 0)
+			return -ENOMEM;
+	}
+
+	dsize = cnstr_blob_encap_jobdesc(&blob_encap,
+					 secret_dma, secret_length_for_cnstr,
+					 keycolor, auth, trusted_key,
+					 secret_memtype,
+					 keymod_dma, *keymod_length,
+					 blob_dma, *blob_length, blobcolor);
+	if (!dsize) {
+		dev_err(jrdev, "failed to construct the encap descriptor:\n");
+		retval = -ENOMEM;
+		goto unprepare_blob;
+	}
+
+	jstat = jr_run_job_and_wait_completion(jrdev, blob_encap);
+	if (jstat) {
+		dev_err(jrdev, "Encapsulation job failed\n");
+		retval = -EIO;
+		goto free_desc;
+	}
+
+	if (blob_memtype == DATA_GENMEM)
+		read_data_prepared(jrdev, blob, blob_dma, temp_blob,
+				   *blob_length);
+
+free_desc:
+	kfree(blob_encap);
+
+unprepare_blob:
+	if (blob_memtype == DATA_GENMEM)
+		unprepare_read_data(jrdev, blob_dma, temp_blob, *blob_length);
+
+unprepare_keymod:
+	if (keymod_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, keymod_dma, temp_keymod,
+				     *keymod_length);
+
+unprepare_secret:
+	if (secret_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, secret_dma, temp_secret,
+				     secret_length);
+
+exit:
+	return retval;
+}
+EXPORT_SYMBOL(caam_blob_encap);
+
+/**
+ * @brief         Perform the decapsulation of a secret from a blob
+ *
+ * @details       Details:
+ * - If @b memtype is setted to @b DATA_SECMEM, the secret to decapsulate is
+ *   written directly by the CAAM to Secure Memeory without intermediate copy.
+ *   The value of @b secret must be a physical address in secure memory.
+ *
+ * - If @b memtype is setted to @b DATA_SECMEM, it is possible to retrieve data
+ *   or key from a black blob without the output to be covered.
+ *
+ * - The parameter @b keymod_length is used to check the size of the key
+ *   modifier is long enough, else the function will fail with the appropriate
+ *   size set.
+ *
+ * - The parameter @b secret_length is used to check the size of the output
+ *   memory is long enough, else the function will fail with the appropriate
+ *   size set.
+ *
+ * - The parameter @b key_length_in_secret is used to indicate the user of the
+ *   real size of the data encapsulated in the blob which is useful in case of
+ *   decapsulation of black keys.
+ *
+ * @attention     The input and output data are copied to temporary arrays
+ *                except for @b secret if @b memtype is @b DATA_SECMEM.
+ *
+ * @param[in]     jrdev                 The jrdev
+ * @param[in]     blob                  The blob
+ * @param[in]     blob_length           The blob length
+ * @param[in]     blob_memtype          The memtype
+ * @param[in]     blobcolor             The blobcolor
+ * @param[in]     keymod                The keymod
+ * @param[in,out] keymod_length         The keymod length
+ * @param[in]     keymod_memtype        The keymod memtype
+ * @param[in]     secret                The secret
+ * @param[in,out] secret_length         The secret length
+ * @param[in]     secret_memtype        The secret memtype
+ * @param[in]     keycolor              The keycolor
+ * @param[out]    key_length_in_secret  The key length in secret
+ * @param[in]     auth                  The auth
+ * @param[in]     trusted_key           The trusted key
+ *
+ * @return        0 if no error, otherwise error code
+ */
+int caam_blob_decap(struct device *jrdev,
+		    const void *blob, size_t blob_length, u8 blob_memtype,
+		    u8 blobcolor,
+		    const void *keymod, size_t *keymod_length,
+		    u8 keymod_memtype,
+		    void *secret, size_t *secret_length, u8 secret_memtype,
+		    u8 keycolor, size_t *key_length_in_secret,
+		    u8 auth, u8 trusted_key)
+{
+	int retval = 0;
+	u32 dsize, jstat;
+	u32 __iomem *blob_decap = NULL;
+	size_t secret_length_for_cnstr;
+	size_t secret_length_req;
+
+	u8 *temp_secret = NULL;
+	caam_dma_addr_t secret_dma;
+	u8 *temp_keymod = NULL;
+	caam_dma_addr_t keymod_dma;
+	u8 *temp_blob = NULL;
+	caam_dma_addr_t blob_dma;
+
+	/*
+	 * basic checks
+	 */
+
+	/* Check job ring */
+	if (!jrdev)
+		return -EINVAL;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s input: [blob: %p(%zu), memtype:%x ,blob color: %x",
+		 __func__,
+		 blob, blob_length, blob_memtype, blobcolor);
+	dev_info(jrdev, " keymod: %p(%zu), memtype:%x",
+		 keymod, *keymod_length, keymod_memtype);
+	dev_info(jrdev, " secret: %p(%zu) color:%x auth:%x, memtype:%x]",
+		 secret, *secret_length, keycolor, auth, secret_memtype);
+#endif
+
+	/* Check input buffers */
+	if (!secret || !keymod || !blob)
+		return -EINVAL;
+
+	/* Check values */
+	if (!is_key_color(keycolor) ||
+	    !is_memory_type(blob_memtype) ||
+	    !is_blob_color(blobcolor) ||
+	    !is_memory_type(keymod_memtype) ||
+	    !is_memory_type(secret_memtype))
+		return -EINVAL;
+
+	if (keycolor == BLACK_KEY) {
+		if (!is_auth(auth) || !is_trusted_key(trusted_key))
+			return -EINVAL;
+
+		/* Trusted key not supported */
+		if (trusted_key == TRUSTED_KEY)
+			return -EINVAL;
+	} else {
+		auth = KEY_COVER_ECB; // No value for auth for red keys
+	}
+
+	/*
+	 * Advanced checks
+	 */
+
+	/* Check keymod size depending on memory type */
+	if (secret_memtype == DATA_SECMEM) {
+		if (*keymod_length < KEYMOD_SIZE_SM) {
+			*keymod_length = KEYMOD_SIZE_SM;
+			return -EINVAL;
+		}
+		*keymod_length = KEYMOD_SIZE_SM;
+	} else {
+		if (*keymod_length < KEYMOD_SIZE_GM) {
+			*keymod_length = KEYMOD_SIZE_GM;
+			return -EINVAL;
+		}
+		*keymod_length = KEYMOD_SIZE_GM;
+	}
+
+	/* Check the user want a black key if it is a black blob */
+	if (blobcolor != BLACK_BLOB && keycolor == BLACK_KEY)
+		return -EINVAL;
+
+	/* Check the blob is valid */
+	if (blob_length <= BLOB_OVERHEAD)
+		return -EINVAL;
+
+	*key_length_in_secret = blob_length - BLOB_OVERHEAD;
+	secret_length_req = *key_length_in_secret;
+	secret_length_for_cnstr = *key_length_in_secret;
+
+	/* Compute the size of of the output array required to stock the
+	 * secret
+	 */
+	if (keycolor == BLACK_KEY) {
+		if (auth == KEY_COVER_CCM)
+			secret_length_req =
+					CCM_BLACK_KEY_SIZE(secret_length_req);
+		else
+			secret_length_req =
+					ECB_BLACK_KEY_SIZE(secret_length_req);
+	}
+
+	/* Chech the secret can be stored */
+	if (*secret_length < secret_length_req) {
+		*secret_length = secret_length_req;
+		return -EINVAL;
+	}
+	*secret_length = secret_length_req;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s processing: [blob: %p(%zu), memtype:%x ,blob color: %x,",
+		 __func__,
+		 blob, blob_length, blob_memtype, blobcolor);
+	dev_info(jrdev, " keymod: %p(%zu), memtype:%x, secret: %p(%zu) cnstr:%zu",
+		 keymod, *keymod_length, keymod_memtype,
+		 secret, *secret_length, secret_length_for_cnstr);
+	dev_info(jrdev, " color:%x auth:%x, memtype:%x]",
+		 keycolor, auth, secret_memtype);
+#endif
+
+	if (blob_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, blob, blob_length,
+				       &blob_dma, &temp_blob)) {
+			dev_err(jrdev, "unable to prepare blob: %p\n", blob);
+			retval = -ENOMEM;
+			goto exit;
+		}
+	} else {
+		blob_dma = get_caam_dma_addr(blob);
+		if (blob_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (keymod_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, keymod, *keymod_length,
+				       &keymod_dma, &temp_keymod)) {
+			dev_err(jrdev, "unable to prepare keymod: %p\n",
+				keymod);
+			retval = -ENOMEM;
+			goto unprepare_blob;
+		}
+	} else {
+		keymod_dma = get_caam_dma_addr(keymod);
+		if (keymod_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (secret_memtype == DATA_GENMEM) {
+		if (prepare_read_data(jrdev, *secret_length,
+				      &secret_dma, &temp_secret)) {
+			dev_err(jrdev, "unable to prepare secret\n");
+			retval = -ENOMEM;
+			goto unprepare_keymod;
+		}
+	} else {
+		secret_dma = get_caam_dma_addr(secret);
+		if (secret_dma == 0)
+			return -ENOMEM;
+	}
+
+	dsize = cnstr_blob_decap_jobdesc(&blob_decap,
+					 blob_dma, blob_length, blobcolor,
+					 keymod_dma, *keymod_length,
+					 secret_dma, secret_length_for_cnstr,
+					 keycolor, auth, trusted_key,
+					 secret_memtype);
+	if (!dsize) {
+		dev_err(jrdev, "failed to construct the encap descriptor:\n");
+		retval = -ENOMEM;
+		goto unprepare_secret;
+	}
+
+	jstat = jr_run_job_and_wait_completion(jrdev, blob_decap);
+	if (jstat) {
+		dev_err(jrdev, "Decapsulation job failed\n");
+		retval = -EIO;
+		goto free_desc;
+	}
+
+	if (secret_memtype == DATA_GENMEM)
+		read_data_prepared(jrdev, secret, secret_dma, temp_secret,
+				   *secret_length);
+
+free_desc:
+	kfree(blob_decap);
+
+unprepare_secret:
+	if (secret_memtype == DATA_GENMEM)
+		unprepare_read_data(jrdev, secret_dma, temp_secret,
+				    *secret_length);
+
+unprepare_keymod:
+	if (keymod_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, keymod_dma, temp_keymod,
+				     *keymod_length);
+
+unprepare_blob:
+	if (blob_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, blob_dma, temp_blob, blob_length);
+
+exit:
+	return retval;
+}
+EXPORT_SYMBOL(caam_blob_decap);
diff --git a/drivers/crypto/caam/caam.h b/drivers/crypto/caam/caam.h
new file mode 100644
index 0000000..e2e56c0
--- /dev/null
+++ b/drivers/crypto/caam/caam.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2018 NXP
+ */
+
+#ifndef _CAAM_H_
+#define _CAAM_H_
+
+#include <linux/types.h>
+
+/* Retrieve a reference on a CAAM JR */
+struct device *caam_jr_alloc(void);
+
+/* Release a reference on a CAAM JR */
+void caam_jr_free(struct device *jrdev);
+
+/* Enqueue a job to be processed
+ *
+ * The function cbk will be called when the job is completed with:
+ *  - jrdev the device used for enqueing
+ *  - desc the descriptor processed
+ *  - status the status of the processing: 0 if completed with no error,
+ *    another value if there was an error. The error can be decoded with
+ *    caam_jr_strstatus
+ *  - areq pointer on user specific data
+ */
+int caam_jr_enqueue(struct device *jrdev, u32 *desc,
+		    void (*cbk)(struct device *jrdev, u32 *desc,
+				u32 status, void *areq),
+		    void *areq);
+
+/* Print a description of status
+ * status is the error code passed to the callback when enqueing a job with
+ * caam_jr_enqueue
+ */
+void caam_jr_strstatus(struct device *jrdev, u32 status);
+
+/* Enqueue a job and wait for its completion */
+int jr_run_job_and_wait_completion(struct device *jrdev, u32 *jobdesc);
+
+#endif /* _CAAM_H_ */
diff --git a/drivers/crypto/caam/caam_desc.c b/drivers/crypto/caam/caam_desc.c
new file mode 100644
index 0000000..77aa3c7
--- /dev/null
+++ b/drivers/crypto/caam/caam_desc.c
@@ -0,0 +1,548 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Descriptors for CAAM:
+ *  - red/black key
+ *  - encapsulation/decapsulation in blob
+ *
+ * Copyright 2018 NXP
+ */
+
+#include "caam.h"
+#include "desc.h"
+#include "caam_desc.h"
+#include "desc_constr.h"
+
+#define INITIAL_DESCSZ 16	/* size of tmp buffer for descriptor const. */
+
+/*
+ * Construct a black key conversion job descriptor
+ *
+ * This function constructs a job descriptor capable of performing
+ * a key blackening operation on a plaintext secure memory resident object.
+ *
+ * - desc	pointer to a pointer to the descriptor generated by this
+ *		function. Caller will be responsible to kfree() this
+ *		descriptor after execution.
+ * - key	physical pointer to the plaintext, which will also hold
+ *		the result. Since encryption occurs in place, caller must
+ *              ensure that the space is large enough to accommodate the
+ *              blackened key
+ * - keysz	size of the plaintext
+ * - auth	if a CCM-covered key is required, use KEY_COVER_CCM, else
+ *		use KEY_COVER_ECB.
+ *
+ * Cleanup: The descriptor must be freed
+ */
+int cnstr_black_key_jobdesc(u32 **desc, caam_dma_addr_t key, size_t key_length,
+			    caam_dma_addr_t cover_key, size_t cover_key_length,
+			    u8 auth, u8 trusted_key)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize, idx;
+	u32 key_length_for_desc = key_length;
+
+	/* Trusted key not supported */
+	if (trusted_key != UNTRUSTED_KEY)
+		return 0;
+
+	memset(tmpdesc, 0, sizeof(*tmpdesc) * ARRAY_SIZE(tmpdesc));
+	idx = 1;
+
+	/*
+	 * KEY commands seems limited to 32 bytes, so we should use the load
+	 * command instead which can load up to 64 bytes.
+	 * The size must also be loaded.
+	 *
+	 * TODO: The KEY command indicate it should be able to load key bigger
+	 * than 32bytes but it doesn't work in practice
+	 *
+	 * TODO: The LOAD command indicate it should be able to load up to 96
+	 * byte keys it doesn't work in practice ans is limited to 64 bytes
+	 */
+
+	/* Load key to class 1 key register */
+	tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_1_CCB | LDST_SRCDST_BYTE_KEY |
+			 key_length_for_desc;
+	tmpdesc[idx++] = (uintptr_t)key;
+	/* Load the size of the key */
+	tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_1_CCB | LDST_IMM |
+			 LDST_SRCDST_WORD_KEYSZ_REG |
+			 sizeof(key_length_for_desc);
+	tmpdesc[idx++] = key_length_for_desc;
+
+	/* ...and write back out via FIFO store*/
+	tmpdesc[idx] = CMD_FIFO_STORE | CLASS_1 |
+		       (cover_key_length & KEY_LENGTH_MASK);
+
+	/* plus account for ECB/CCM option in FIFO_STORE */
+	if (auth == KEY_COVER_ECB)
+		tmpdesc[idx] |= FIFOST_TYPE_KEY_KEK;
+	else
+		tmpdesc[idx] |= FIFOST_TYPE_KEY_CCM_JKEK;
+
+	idx++;
+	tmpdesc[idx++] = (uintptr_t)cover_key;
+
+	/* finish off the job header */
+	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
+	dsize = idx * sizeof(u32);
+
+	/* now allocate execution buffer and coat it with executable */
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "cover desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return dsize;
+}
+EXPORT_SYMBOL(cnstr_black_key_jobdesc);
+
+/*
+ * Construct a black key using RNG job descriptor
+ *
+ * This function constructs a job descriptor capable of performing
+ * a key blackening operation on RNG generated.
+ *
+ * - desc	pointer to a pointer to the descriptor generated by this
+ *		function. Caller will be responsible to kfree() this
+ *		descriptor after execution.
+ * - key	physical pointer to the plaintext, which will also hold
+ *		the result. Since encryption occurs in place, caller must
+ *              ensure that the space is large enough to accommodate the
+ *              blackened key
+ * - keysz	size of the plaintext
+ * - auth	if a CCM-covered key is required, use KEY_COVER_CCM, else
+ *		use KEY_COVER_ECB.
+ *
+ * Cleanup: The descriptor must be freed
+ */
+int cnstr_random_black_key_jobdesc(u32 **desc,
+				   size_t key_length,
+				   caam_dma_addr_t cover_key,
+				   size_t cover_key_length,
+				   u8 auth, u8 trusted_key)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize;
+	u32 bk_store;
+
+	memset(tmpdesc, 0, sizeof(*tmpdesc) * ARRAY_SIZE(tmpdesc));
+
+	init_job_desc(tmpdesc, CMD_DESC_HDR);
+
+	/* Prepare RNG */
+	append_operation(tmpdesc, OP_ALG_ALGSEL_RNG | OP_TYPE_CLASS1_ALG);
+
+	/* Generate RNG and left it in output data fifo */
+	append_cmd(tmpdesc, CMD_FIFO_STORE | FIFOST_TYPE_RNGFIFO | key_length);
+
+	/* Copy RNG from outfifo to class 1 Key register */
+	append_move(tmpdesc, MOVE_SRC_OUTFIFO | MOVE_DEST_CLASS1KEY |
+			MOVE_WAITCOMP | (key_length & MOVE_LEN_MASK));
+
+	/* Write the size of the key moved */
+	append_load_imm_u32(tmpdesc, key_length, LDST_CLASS_1_CCB |
+			    LDST_SRCDST_WORD_KEYSZ_REG | LDST_IMM);
+
+	bk_store = CLASS_1;
+	if (auth == KEY_COVER_ECB)
+		bk_store |= FIFOST_TYPE_KEY_KEK;
+	else
+		bk_store |= FIFOST_TYPE_KEY_CCM_JKEK;
+
+	/* Fifo store to save the key as black key in memory */
+	append_fifo_store(tmpdesc, cover_key, cover_key_length, bk_store);
+
+	dsize = desc_bytes(&tmpdesc);
+
+	/* now allocate execution buffer and coat it with executable */
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return -ENOMEM;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "cover random desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_random_black_key_jobdesc);
+
+/*
+ * Construct a blob encapsulation job descriptor
+ *
+ * This function dynamically constructs a blob encapsulation job descriptor
+ * from the following arguments:
+ *
+ * - desc	pointer to a pointer to the descriptor generated by this
+ *		function. Caller will be responsible to kfree() this
+ *		descriptor after execution.
+ * - keymod	Physical pointer to a key modifier, which must reside in a
+ *		contiguous piece of memory. Modifier will be assumed to be
+ *		8 bytes long for a blob of type DATA_SECMEM, or 16 bytes long
+ *		for a blob of type DATA_GENMEM (see blobcolor argument).
+ * - secretbuf	Physical pointer to a secret, normally a black or red key,
+ *		possibly residing within an accessible secure memory page,
+ *		of the secret to be encapsulated to an output blob.
+ * - outbuf	Physical pointer to the destination buffer to receive the
+ *		encapsulated output. This buffer will need to be 48 bytes
+ *		larger than the input because of the added encapsulation data.
+ *		The generated descriptor will account for the increase in size,
+ *		but the caller must also account for this increase in the
+ *		buffer allocator.
+ * - secretsz	Size of input secret, in bytes. This is limited to 65536
+ *		less the size of blob overhead, since the length embeds into
+ *		DECO pointer in/out instructions.
+ * - keycolor   Determines if the source data is covered (black key) or
+ *		plaintext (red key). RED_KEY or BLACK_KEY are defined in
+ *		for this purpose.
+ * - blobcolor	Determine if encapsulated blob should be a secure memory
+ *		blob (DATA_SECMEM), with partition data embedded with key
+ *		material, or a general memory blob (DATA_GENMEM).
+ * - auth	If BLACK_KEY source is covered via AES-CCM, specify
+ *		KEY_COVER_CCM, else uses AES-ECB (KEY_COVER_ECB).
+ *
+ * Upon completion, desc points to a buffer containing a CAAM job
+ * descriptor which encapsulates data into an externally-storable blob
+ * suitable for use across power cycles.
+ *
+ * This is an example of a black key encapsulation job into a general memory
+ * blob. Notice the 16-byte key modifier in the LOAD instruction. Also note
+ * the output 48 bytes longer than the input:
+ *
+ * [00] B0800008       jobhdr: stidx=0 len=8
+ * [01] 14400010           ld: ccb2-key len=16 offs=0
+ * [02] 08144891               ptr->@0x08144891
+ * [03] F800003A    seqoutptr: len=58
+ * [04] 01000000               out_ptr->@0x01000000
+ * [05] F000000A     seqinptr: len=10
+ * [06] 09745090               in_ptr->@0x09745090
+ * [07] 870D0004    operation: encap blob  reg=memory, black, format=normal
+ *
+ * This is an example of a red key encapsulation job for storing a red key
+ * into a secure memory blob. Note the 8 byte modifier on the 12 byte offset
+ * in the LOAD instruction; this accounts for blob permission storage:
+ *
+ * [00] B0800008       jobhdr: stidx=0 len=8
+ * [01] 14400C08           ld: ccb2-key len=8 offs=12
+ * [02] 087D0784               ptr->@0x087d0784
+ * [03] F8000050    seqoutptr: len=80
+ * [04] 09251BB2               out_ptr->@0x09251bb2
+ * [05] F0000020     seqinptr: len=32
+ * [06] 40000F31               in_ptr->@0x40000f31
+ * [07] 870D0008    operation: encap blob  reg=memory, red, sec_mem,
+ *                             format=normal
+ *
+ * Note: this function only generates 32-bit pointers at present, and should
+ * be refactored using a scheme that allows both 32 and 64 bit addressing
+ */
+int cnstr_blob_encap_jobdesc(u32 **desc,
+			     caam_dma_addr_t secret, size_t secret_length,
+			     u8 keycolor, u8 auth, u8 trusted_key,
+			     u8 memtype,
+			     caam_dma_addr_t keymod, size_t keymod_length,
+			     caam_dma_addr_t blob, size_t blob_length,
+			     u8 blobcolor)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize, idx;
+
+	/* Trusted key not supported */
+	if (trusted_key != UNTRUSTED_KEY)
+		return 0;
+
+	memset(tmpdesc, 0, sizeof(*tmpdesc) * ARRAY_SIZE(tmpdesc));
+	idx = 1;
+
+	/*
+	 * Key modifier works differently for secure/general memory blobs
+	 * This accounts for the permission/protection data encapsulated
+	 * within the blob if a secure memory blob is requested
+	 */
+	if (memtype == DATA_SECMEM)
+		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
+				 LDST_SRCDST_BYTE_KEY |
+				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
+				 | (keymod_length & LDST_LEN_MASK);
+	else /* is general memory blob */
+		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB
+				 | LDST_SRCDST_BYTE_KEY
+				 | (keymod_length & LDST_LEN_MASK);
+
+	tmpdesc[idx++] = (u32)keymod;
+
+	/*
+	 * Encapsulation output must include space for blob key encryption
+	 * key and MAC tag
+	 */
+	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | (secret_length + BLOB_OVERHEAD);
+	tmpdesc[idx++] = (u32)blob;
+
+	/* Input data, should be somewhere in secure memory */
+	tmpdesc[idx++] = CMD_SEQ_IN_PTR | secret_length;
+	tmpdesc[idx++] = (uintptr_t)secret;
+
+	/* Set blob encap, then color */
+	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_ENCAP_PROTOCOL | OP_PCLID_BLOB;
+
+	if (memtype == DATA_SECMEM)
+		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;
+
+	if (auth == KEY_COVER_CCM)
+		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
+
+	/* An input black key cannot be stored in a red blob */
+	if (keycolor == BLACK_KEY)
+		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;
+
+	idx++;
+	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
+	dsize = idx * sizeof(u32);
+
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "encap desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return dsize;
+}
+EXPORT_SYMBOL(cnstr_blob_encap_jobdesc);
+
+/*
+ * Construct a blob decapsulation job descriptor
+ *
+ * This function dynamically constructs a blob decapsulation job descriptor
+ * from the following arguments:
+ *
+ * - desc	pointer to a pointer to the descriptor generated by this
+ *		function. Caller will be responsible to kfree() this
+ *		descriptor after execution.
+ * - keymod	Physical pointer to a key modifier, which must reside in a
+ *		contiguous piece of memory. Modifier will be assumed to be
+ *		8 bytes long for a blob of type DATA_SECMEM, or 16 bytes long
+ *		for a blob of type DATA_GENMEM (see blobcolor argument).
+ * - blobbuf	Physical pointer (into external memory) of the blob to
+ *		be decapsulated. Blob must reside in a contiguous memory
+ *		segment.
+ * - outbuf	Physical pointer of the decapsulated output, possibly into
+ *		a location within a secure memory page. Must be contiguous.
+ * - secretsz	Size of encapsulated secret in bytes (not the size of the
+ *		input blob).
+ * - keycolor   Determines if decapsulated content is encrypted (BLACK_KEY)
+ *		or left as plaintext (RED_KEY).
+ * - blobcolor	Determine if encapsulated blob should be a secure memory
+ *		blob (DATA_SECMEM), with partition data embedded with key
+ *		material, or a general memory blob (DATA_GENMEM).
+ * - auth	If decapsulation path is specified by BLACK_KEY, then if
+ *		AES-CCM is requested for key covering use KEY_COVER_CCM, else
+ *		use AES-ECB (KEY_COVER_ECB).
+ *
+ * Upon completion, desc points to a buffer containing a CAAM job descriptor
+ * that decapsulates a key blob from external memory into a black (encrypted)
+ * key or red (plaintext) content.
+ *
+ * This is an example of a black key decapsulation job from a general memory
+ * blob. Notice the 16-byte key modifier in the LOAD instruction.
+ *
+ * [00] B0800008       jobhdr: stidx=0 len=8
+ * [01] 14400010           ld: ccb2-key len=16 offs=0
+ * [02] 08A63B7F               ptr->@0x08a63b7f
+ * [03] F8000010    seqoutptr: len=16
+ * [04] 01000000               out_ptr->@0x01000000
+ * [05] F000003A     seqinptr: len=58
+ * [06] 01000010               in_ptr->@0x01000010
+ * [07] 860D0004    operation: decap blob  reg=memory, black, format=normal
+ *
+ * This is an example of a red key decapsulation job for restoring a red key
+ * from a secure memory blob. Note the 8 byte modifier on the 12 byte offset
+ * in the LOAD instruction:
+ *
+ * [00] B0800008       jobhdr: stidx=0 len=8
+ * [01] 14400C08           ld: ccb2-key len=8 offs=12
+ * [02] 01000000               ptr->@0x01000000
+ * [03] F8000020    seqoutptr: len=32
+ * [04] 400000E6               out_ptr->@0x400000e6
+ * [05] F0000050     seqinptr: len=80
+ * [06] 08F0C0EA               in_ptr->@0x08f0c0ea
+ * [07] 860D0008    operation: decap blob  reg=memory, red, sec_mem,
+ *			       format=normal
+ *
+ * Note: this function only generates 32-bit pointers at present, and should
+ * be refactored using a scheme that allows both 32 and 64 bit addressing
+ */
+int cnstr_blob_decap_jobdesc(u32 **desc,
+			     caam_dma_addr_t blob, size_t blob_length,
+			     u8 blobcolor,
+			     caam_dma_addr_t keymod, size_t keymod_length,
+			     caam_dma_addr_t secret, size_t secret_length,
+			     u8 keycolor, u8 auth,  u8 trusted_key,
+			     u8 memtype)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize, idx;
+
+	/* Trusted key not supported */
+	if (trusted_key != UNTRUSTED_KEY)
+		return 0;
+
+	memset(tmpdesc, 0, sizeof(*tmpdesc) * ARRAY_SIZE(tmpdesc));
+	idx = 1;
+
+	/* Load key modifier */
+	if (memtype == DATA_SECMEM)
+		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
+				 LDST_SRCDST_BYTE_KEY |
+				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
+				 | (keymod_length & LDST_LEN_MASK);
+	else /* is general memory blob */
+		tmpdesc[idx++] = CMD_LOAD
+				| LDST_CLASS_2_CCB
+				| LDST_SRCDST_BYTE_KEY
+				| (keymod_length & LDST_LEN_MASK);
+
+	tmpdesc[idx++] = (u32)keymod;
+
+	/* Compensate BKEK + MAC tag over size of encapsulated secret */
+	tmpdesc[idx++] = CMD_SEQ_IN_PTR | blob_length;
+	tmpdesc[idx++] = (u32)blob;
+	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | secret_length;
+	tmpdesc[idx++] = (uintptr_t)secret;
+
+	/* Decapsulate from secure memory partition to black blob */
+	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_DECAP_PROTOCOL | OP_PCLID_BLOB;
+
+	if (memtype == DATA_SECMEM)
+		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;
+
+	if (auth == KEY_COVER_CCM)
+		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
+
+	if (keycolor == BLACK_KEY)
+		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;
+
+	idx++;
+	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
+	dsize = idx * sizeof(u32);
+
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "decap desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return dsize;
+}
+EXPORT_SYMBOL(cnstr_blob_decap_jobdesc);
+
+/*
+ * @brief      Create a job descriptor to load a key by address
+ *
+ * @param[out] desc        The description
+ * @param[in]  key         The key
+ * @param[in]  key_size    The key size
+ * @param[in]  key_length  The key length
+ * @param[in]  key_class   The key class
+ * @param[in]  enc         The encode
+ * @param[in]  nwb         The nwb
+ * @param[in]  ekt         The ekt
+ * @param[in]  kdest       The kdest
+ *
+ * @return     Return the number of bytes of the descriptor
+ */
+int cnstr_key_jobdesc(u32 **desc,
+		      caam_dma_addr_t key, size_t key_size, size_t key_length,
+		      u32 key_class, u32 enc,
+		      u32 nwb, u32 ekt, u32 kdest)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u32 key_option;
+
+	init_desc(tmpdesc, CMD_DESC_HDR);
+
+	key_option = key_class | enc | nwb | ekt | kdest;
+
+	if (enc)
+		append_key(tmpdesc, key, key_length, key_option);
+	else
+		append_key(tmpdesc, key, key_size, key_option);
+
+	tdesc = kmalloc(desc_bytes(tmpdesc), GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, desc_bytes(tmpdesc));
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "key desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return desc_bytes(tmpdesc);
+}
+EXPORT_SYMBOL(cnstr_key_jobdesc);
+
+/**
+ * @brief      Create a job descriptor to load an immediate key
+ *
+ * @param[out] desc        The description
+ * @param[in]  key         The key
+ * @param[in]  key_size    The key size
+ * @param[in]  key_length  The key length
+ * @param[in]  key_class   The key class
+ * @param[in]  enc         The encode
+ * @param[in]  nwb         The nwb
+ * @param[in]  ekt         The ekt
+ * @param[in]  kdest       The kdest
+ *
+ * @return     Return the number of bytes of the descriptor
+ */
+int cnstr_key_imm_jobdesc(u32 **desc,
+			  void *key, size_t key_size, size_t key_length,
+			  u32 key_class, u32 enc,
+			  u32 nwb, u32 ekt, u32 kdest)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u32 key_option;
+
+	init_desc(tmpdesc, CMD_DESC_HDR);
+
+	key_option = key_class | enc | nwb | ekt | kdest;
+
+	append_key_as_imm(tmpdesc, (void *)key, key_size, key_length,
+			  key_option);
+
+	tdesc = kmalloc(desc_bytes(tmpdesc), GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, desc_bytes(tmpdesc));
+	*desc = tdesc;
+
+	return desc_bytes(tmpdesc);
+}
+EXPORT_SYMBOL(cnstr_key_imm_jobdesc);
diff --git a/drivers/crypto/caam/caam_desc.h b/drivers/crypto/caam/caam_desc.h
new file mode 100644
index 0000000..b3d42f5
--- /dev/null
+++ b/drivers/crypto/caam/caam_desc.h
@@ -0,0 +1,117 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Shared descriptors for caam black key and blob
+ *
+ * Copyright 2016 NXP
+ */
+
+#ifndef CAAM_DESC_H
+#define CAAM_DESC_H
+
+#include <linux/types.h>
+
+#include "compat.h"
+#include "regs.h"
+
+/* Define treatment of secure memory vs. general memory blobs */
+#define DATA_GENMEM 0
+#define DATA_DMAMEM 1
+#define DATA_SECMEM 2
+
+/* Define treatment of red/black keys */
+#define RED_KEY 0 /* Clear key */
+#define BLACK_KEY 1 /* Encrypted key */
+
+/* Definition of the different type of blob */
+#define RED_BLOB 0
+#define BLACK_BLOB 1
+
+/* Define key encryption/covering options */
+#define KEY_COVER_ECB 0	/* cover key in AES-ECB */
+#define KEY_COVER_CCM 1 /* cover key with AES-CCM */
+
+/* Define the trust in the key, to select either JDKEK or TDKEK */
+#define UNTRUSTED_KEY 0
+#define TRUSTED_KEY 1
+
+/* Define space required for BKEK + MAC tag storage in any blob */
+#define BLOB_OVERHEAD (32 + 16)
+
+#define PAD_16_BYTE(_key_size) (roundup(_key_size, 16))
+
+/* An ECB black key is a multiple of 16 byte, at least the size of the key */
+#define ECB_BLACK_KEY_SIZE(_key_size) (PAD_16_BYTE(_key_size))
+
+#define PAD_8_BYTE(_key_size) (roundup(_key_size, 8))
+
+/* A CCM Black key is a multiple of 8 byte, at least the size of the key
+ * plus 6 byte for the nonce and 6 byte for the IV
+ */
+#define NONCE_SIZE 6
+#define IV_SIZE 6
+#define CCM_OVERHEAD (NONCE_SIZE + IV_SIZE)
+#define CCM_BLACK_KEY_SIZE(_key_size) (PAD_8_BYTE(_key_size) \
+							+ CCM_OVERHEAD)
+
+static inline int secret_size_in_ccm_black_key(int key_size)
+{
+	return ((key_size >= CCM_OVERHEAD) ? key_size - CCM_OVERHEAD : 0);
+}
+
+#define SECRET_SIZE_IN_CCM_BLACK_KEY(_key_size) \
+	secret_size_in_ccm_black_key(_key_size)
+
+/* A red key is unencrypted so its size is the same */
+#define RED_KEY_SIZE(_key_size) (_key_size)
+
+/* Keymod size is 8 byte for blob created in secure memory, else 16 */
+#define KEYMOD_SIZE_SM 8
+#define KEYMOD_SIZE_GM 16
+
+/* Create job descriptor to cover key */
+extern int cnstr_black_key_jobdesc(u32 **desc, caam_dma_addr_t key,
+				   size_t key_length,
+				   caam_dma_addr_t cover_key,
+				   size_t cover_key_length,
+				   u8 auth, u8 trusted_key);
+
+/* Create job descriptor to generate a random key and cover it */
+extern int cnstr_random_black_key_jobdesc(u32 **desc, size_t key_length,
+					  caam_dma_addr_t cover_key,
+					  size_t cover_key_length,
+					  u8 auth, u8 trusted_key);
+
+/* Encapsulate data in a blob */
+extern int cnstr_blob_encap_jobdesc(u32 **desc,
+				    caam_dma_addr_t secret,
+				    size_t secret_length,
+				    u8 keycolor, u8 auth,  u8 trusted_key,
+				    u8 memtype,
+				    caam_dma_addr_t keymod,
+				    size_t keymod_length,
+				    caam_dma_addr_t blob, size_t blob_length,
+				    u8 blobcolor);
+
+/* Decapsulate data from a blob */
+extern int cnstr_blob_decap_jobdesc(u32 **desc,
+				    caam_dma_addr_t blob, size_t blob_length,
+				    u8 blobcolor,
+				    caam_dma_addr_t keymod,
+				    size_t keymod_length,
+				    caam_dma_addr_t secret,
+				    size_t secret_length,
+				    u8 keycolor, u8 auth, u8 trusted_key,
+				    u8 memtype);
+
+extern int cnstr_key_jobdesc(u32 **desc,
+			     caam_dma_addr_t key, size_t key_size,
+			     size_t key_length,
+			     u32 key_class, u32 enc,
+			     u32 nwb, u32 ekt, u32 kdest);
+
+extern int cnstr_key_imm_jobdesc(u32 **desc,
+				 void *key, size_t key_size, size_t key_length,
+				 u32 key_class, u32 enc,
+				 u32 nwb, u32 ekt, u32 kdest);
+
+#endif /* CAAM_DESC_H */
diff --git a/drivers/crypto/caam/caam_key.c b/drivers/crypto/caam/caam_key.c
new file mode 100644
index 0000000..5d89c9d
--- /dev/null
+++ b/drivers/crypto/caam/caam_key.c
@@ -0,0 +1,623 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2018 NXP
+ * caam key is generated using NXP CAAM hardware block. CAAM generates the
+ * random number (used as a key) and creates its blob for the user.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/parser.h>
+#include <linux/string.h>
+#include <linux/key-type.h>
+#include <linux/rcupdate.h>
+#include <linux/completion.h>
+#include <linux/module.h>
+
+#include "desc.h"
+#include "desc_constr.h"
+#include "caam_desc.h"
+#include "caam_key.h"
+#include "caam_util.h"
+
+/* Key modifier for CAAM key blobbing */
+static const char caam_key_modifier[KEYMOD_SIZE_GM] = {
+	'C', 'A', 'A', 'M', '_', 'K', 'E', 'Y',
+	'_', 'T', 'Y', 'P', 'E', '_', 'V', '1',
+};
+
+/* Operation supported */
+enum caam_key_op {
+	OP_ERROR = -1,
+	OP_NEW_KEY,
+	OP_SET_KEY,
+	OP_LOAD_BLOB,
+};
+
+/* Tokens for the operation to do */
+static const match_table_t key_cmd_tokens = {
+	{OP_NEW_KEY, "new"},
+	{OP_SET_KEY, "set"},
+	{OP_LOAD_BLOB, "load"},
+	{OP_ERROR, NULL}
+};
+
+enum caam_key_fmt {
+	FMT_ERROR = -1,
+	FMT_ECB,
+	FMT_CCM,
+};
+
+/* Tokens for the type of encryption of the black key */
+static const char FMT_ECB_txt[] = "ecb";
+static const char FMT_CCM_txt[] = "ccm";
+
+static const match_table_t key_fmt_tokens = {
+	{FMT_ECB, FMT_ECB_txt},
+	{FMT_CCM, FMT_CCM_txt},
+	{FMT_ERROR, NULL}
+};
+
+int caam_key_tag_black_key(struct caam_key_payload *ckpayload,
+			   size_t black_key_max_len, u8 auth, u8 trusted)
+{
+	struct tag_object_conf tag;
+	enum tag_type type;
+	int ret;
+	u32 size_tagged = black_key_max_len;
+
+	if (!ckpayload)
+		return -EINVAL;
+
+	if (!is_auth(auth) || !is_trusted_key(trusted))
+		return -EINVAL;
+
+	if (auth == KEY_COVER_ECB) {
+		if (trusted == UNTRUSTED_KEY)
+			type = TAG_TYPE_BLACK_KEY_ECB;
+		else
+			type = TAG_TYPE_BLACK_KEY_ECB_TRUSTED;
+	} else {
+		if (trusted == UNTRUSTED_KEY)
+			type = TAG_TYPE_BLACK_KEY_CCM;
+		else
+			type = TAG_TYPE_BLACK_KEY_CCM_TRUSTED;
+	}
+
+	/* Prepare the tag */
+	init_tag_object_header(&tag.header, type);
+	init_blackey_conf(&tag.conf.bk_conf, ckpayload->key_len,
+			  auth == KEY_COVER_CCM,
+			  trusted == TRUSTED_KEY);
+
+	ret = set_tag_object_conf(&tag, ckpayload->black_key,
+				  ckpayload->black_key_len, &size_tagged);
+	if (ret) {
+		pr_err("Tagging fail: %d\n", ret);
+		goto exit;
+	}
+
+	/* Update the size of the black key tagged */
+	ckpayload->black_key_len = size_tagged;
+
+exit:
+	return ret;
+}
+
+static int caam_transform(enum caam_key_op key_cmd,
+			  struct caam_key_payload *ckpayload)
+{
+	int ret;
+	struct device *jrdev;
+	u8 key_cover;
+
+	/* Allocate caam job ring for operation to be performed from CAAM */
+	jrdev = caam_jr_alloc();
+	if (!jrdev) {
+		pr_info("caam_jr_alloc failed\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (ckpayload->key_fmt_val == FMT_ECB)
+		key_cover = KEY_COVER_ECB;
+	else
+		key_cover = KEY_COVER_CCM;
+
+	switch (key_cmd) {
+	case OP_LOAD_BLOB:
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "input blob: ",
+		       DUMP_PREFIX_OFFSET, 16, 4, ckpayload->blob,
+		       ckpayload->blob_len, 0);
+#endif
+		/* Decapsulate the black blob into a black key */
+		ret = caam_blob_decap(jrdev,
+				      ckpayload->blob, ckpayload->blob_len,
+				      DATA_GENMEM, BLACK_BLOB,
+				      ckpayload->key_mod,
+				      &ckpayload->key_mod_len, DATA_GENMEM,
+				      ckpayload->black_key,
+				      &ckpayload->black_key_len, DATA_GENMEM,
+				      BLACK_KEY, &ckpayload->key_len,
+				      key_cover, UNTRUSTED_KEY);
+		if (ret) {
+			pr_info("key_blob decap fail: %d\n", ret);
+			goto free_jr;
+		}
+
+		break;
+	case OP_SET_KEY:
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "input key: ",
+		       DUMP_PREFIX_OFFSET, 16, 4, ckpayload->key,
+		       ckpayload->key_len, 0);
+#endif
+
+		/* Cover the input key  */
+		ret = caam_black_key(jrdev,
+				     ckpayload->key, ckpayload->key_len,
+				     DATA_GENMEM,
+				     ckpayload->black_key,
+				     &ckpayload->black_key_len, DATA_GENMEM,
+				     key_cover, UNTRUSTED_KEY);
+		/*
+		 * Clear the input key
+		 * TODO: Make it secure to not be removed by compiler
+		 */
+		memset(ckpayload->key, 0, ckpayload->key_len);
+
+		if (ret) {
+			pr_info("key covering fail: (%d)\n", ret);
+			goto free_jr;
+		}
+
+		/* Encapsulate the key  */
+		ret = caam_blob_encap(jrdev,
+				      ckpayload->black_key,
+				      ckpayload->black_key_len, DATA_GENMEM,
+				      BLACK_KEY, ckpayload->key_len, key_cover,
+				      UNTRUSTED_KEY,
+				      ckpayload->key_mod,
+				      &ckpayload->key_mod_len, DATA_GENMEM,
+				      ckpayload->blob, &ckpayload->blob_len,
+				      DATA_GENMEM, BLACK_BLOB);
+		if (ret) {
+			pr_info("Blob encapsulation of key fail: %d\n", ret);
+			goto free_jr;
+		}
+
+		break;
+	case OP_NEW_KEY:
+		/*
+		 * We need random data to create a key however we do not
+		 * want
+		 */
+		ret = caam_random_black_key(jrdev,
+					    ckpayload->key_len,
+					    ckpayload->black_key,
+					    &ckpayload->black_key_len,
+					    DATA_GENMEM, key_cover,
+					    UNTRUSTED_KEY);
+
+		if (ret) {
+			pr_info("Random key covering fail: %d\n", ret);
+			goto free_jr;
+		}
+
+		/* Encapsulate the key  */
+		ret = caam_blob_encap(jrdev,
+				      ckpayload->black_key,
+				      ckpayload->black_key_len, DATA_GENMEM,
+				      BLACK_KEY, ckpayload->key_len, key_cover,
+				      UNTRUSTED_KEY,
+				      ckpayload->key_mod,
+				      &ckpayload->key_mod_len, DATA_GENMEM,
+				      ckpayload->blob, &ckpayload->blob_len,
+				      DATA_GENMEM, BLACK_BLOB);
+		if (ret) {
+			pr_info("Blob encapsulation of random fail: %d\n", ret);
+			goto free_jr;
+		}
+
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "black key: ",
+		       DUMP_PREFIX_OFFSET, 16, 4, ckpayload->black_key,
+		       ckpayload->black_key_len, 0);
+	print_hex_dump(KERN_ERR, "blob: ",
+		       DUMP_PREFIX_OFFSET, 16, 4, ckpayload->blob,
+		       ckpayload->blob_len, 0);
+#endif
+
+	/* Tag the black key so it can be passed to CAAM crypto API */
+	ret = caam_key_tag_black_key(ckpayload,
+				     ARRAY_SIZE(ckpayload->black_key),
+				     key_cover, UNTRUSTED_KEY);
+	if (ret) {
+		pr_info("Black key tagging fail: %d\n", ret);
+		goto free_jr;
+	}
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "tagged black key: ",
+		       DUMP_PREFIX_OFFSET, 16, 4, ckpayload->black_key,
+		       ckpayload->black_key_len, 0);
+#endif
+
+	/* Update the aliased user_key_payload */
+	ckpayload->upayload.datalen = ckpayload->black_key_len;
+	memcpy(ckpayload->upayload.data, ckpayload->black_key,
+	       ckpayload->upayload.datalen);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+out:
+	if (ret)
+		pr_err("Operation %s(%d) failed\n",
+		       key_cmd_tokens[key_cmd].pattern, key_cmd);
+
+	return ret;
+}
+
+/*
+ * parse_inputdata - parse the keyctl input data and fill in the
+ *		     payload structure for key or its blob.
+ * param[in]: data pointer to the data to be parsed for creating key.
+ * param[in]: p pointer to caam key payload structure to fill parsed data
+ * On success returns 0, otherwise -EINVAL.
+ */
+static enum caam_key_op parse_inputdata(char *data,
+					struct caam_key_payload *ckpayload)
+{
+	substring_t args[MAX_OPT_ARGS];
+	long keylen = 0;
+	int ret = 0;
+	enum caam_key_op op_to_do = OP_ERROR;
+	int key_cmd = -EINVAL;
+	int key_fmt = -EINVAL;
+	char *c = NULL;
+	const char *hex_format = ":hex:";
+	u32 hex_format_size;
+
+	c = strsep(&data, " \t");
+	if (!c) {
+		ret = -EINVAL;
+		pr_err("Failed to find 1st arg\n");
+		goto out;
+	}
+
+	/* Get the keyctl command i.e. new_key or load_blob etc */
+	key_cmd = match_token(c, key_cmd_tokens, args);
+
+	/* Skip spaces to get the 1st argument */
+	c = strsep(&data, " \t");
+	if (!c) {
+		ret = -EINVAL;
+		pr_err("Failed to find 2nd arg\n");
+		goto out;
+	}
+
+	/* Get the keyctl format i.e. ecb or ccm etc */
+	key_fmt = match_token(c, key_fmt_tokens, args);
+
+	/* Skip spaces to get second argument */
+	c = strsep(&data, " \t");
+	if (!c) {
+		ret = -EINVAL;
+		pr_err("Failed to find 3rd arg\n");
+		goto out;
+	}
+
+	switch (key_fmt) {
+	case FMT_ECB:
+		ckpayload->key_fmt_val = KEY_COVER_ECB;
+		break;
+	case FMT_CCM:
+		ckpayload->key_fmt_val = KEY_COVER_CCM;
+		break;
+	case FMT_ERROR:
+		ret = -EINVAL;
+		pr_err("Format %d not supported\n", key_fmt);
+		goto out;
+	}
+
+	/* Prepare arguments */
+	switch (key_cmd) {
+	case OP_NEW_KEY:
+		/* Second argument is key size */
+		ret = kstrtol(c, 10, &keylen);
+		if (ret < 0 || keylen < MIN_KEY_SIZE ||
+		    keylen > MAX_KEY_SIZE) {
+			ret = -EINVAL;
+			pr_err("Failed to retrieve key length\n");
+			goto out;
+		}
+
+		ckpayload->key_len = keylen;
+
+		ckpayload->black_key_len = ARRAY_SIZE(ckpayload->black_key);
+		ckpayload->blob_len = ARRAY_SIZE(ckpayload->blob);
+
+		op_to_do = OP_NEW_KEY;
+
+		break;
+	case OP_SET_KEY:
+		/* Second argument is key data for CAAM*/
+
+		/* key_len = No of characters in key/2 */
+		ckpayload->key_len = strlen(c) / 2;
+		if (ckpayload->blob_len > MAX_KEY_SIZE) {
+			ret = -EINVAL;
+			pr_err("Failed to compute key length\n");
+			goto out;
+		}
+
+		ret = hex2bin(ckpayload->key, c, ckpayload->key_len);
+		if (ret < 0) {
+			ret = -EINVAL;
+			pr_err("Failed to retrieve key data\n");
+			goto out;
+		}
+
+		ckpayload->black_key_len = ARRAY_SIZE(ckpayload->black_key);
+		ckpayload->blob_len = ARRAY_SIZE(ckpayload->blob);
+
+		op_to_do = OP_SET_KEY;
+
+		break;
+	case OP_LOAD_BLOB:
+		/* Second argument is blob data for CAAM */
+		hex_format_size = strlen(hex_format);
+
+		/* The blob is prepended by the format */
+		if (strncmp(c, hex_format, hex_format_size) != 0) {
+			ret = -EINVAL;
+			pr_err("Failed to match blob format\n");
+			goto out;
+		}
+
+		/* Advance the pointer */
+		c += hex_format_size;
+
+		/* Blob_len = No of characters in blob/2 */
+		ckpayload->blob_len = strlen(c) / 2;
+		if (ckpayload->blob_len > MAX_BLOB_SIZE) {
+			ret = -EINVAL;
+			pr_err("Failed to compute blob length\n");
+			goto out;
+		}
+
+		ret = hex2bin(ckpayload->blob, c, ckpayload->blob_len);
+		if (ret < 0) {
+			ret = -EINVAL;
+			pr_err("Failed to retrieve blob data\n");
+			goto out;
+		}
+
+		ckpayload->key_len = ARRAY_SIZE(ckpayload->key);
+		ckpayload->black_key_len = ARRAY_SIZE(ckpayload->black_key);
+
+		op_to_do = OP_LOAD_BLOB;
+
+		break;
+	case OP_ERROR:
+		ret = -EINVAL;
+		pr_err("Command %d not supported\n", key_cmd);
+		break;
+	}
+
+	ckpayload->key_mod = caam_key_modifier;
+	ckpayload->key_mod_len = ARRAY_SIZE(caam_key_modifier);
+
+out:
+	return (ret == 0) ? op_to_do : OP_ERROR;
+}
+
+static struct caam_key_payload *caam_payload_alloc(struct key *key)
+{
+	struct caam_key_payload *ckpayload = NULL;
+	int ret = 0;
+
+	ret = key_payload_reserve(key, sizeof(*ckpayload));
+	if (ret < 0) {
+		pr_err("Failed to reserve payload\n");
+		goto out;
+	}
+
+	ckpayload = kzalloc(sizeof(*ckpayload), GFP_KERNEL);
+	if (!ckpayload)
+		goto out;
+
+out:
+	return ckpayload;
+}
+
+/*
+ * caam_destroy - clear and free the key's payload
+ */
+static void caam_destroy(struct key *key)
+{
+	struct caam_key_payload *ckpayload = NULL;
+
+	/* Retrieve the payload */
+	ckpayload = dereference_key_locked(key);
+	if (!ckpayload)
+		pr_err("Fail to retrieve key payload\n");
+
+	kzfree(ckpayload);
+}
+
+/*
+ * caam_instantiate - create a new caam type key.
+ * Supports the operation to generate a new key. A random number
+ * is generated from CAAM as key data and the corresponding red blob
+ * is formed and stored as key_blob.
+ * Also supports the operation to load the blob and key is derived using
+ * that blob from CAAM.
+ * On success, return 0. Otherwise return errno.
+ */
+static int caam_instantiate(struct key *key,
+			    struct key_preparsed_payload *prep)
+{
+	struct caam_key_payload *ckpayload;
+	size_t datalen;
+	char *data = NULL;
+	int key_cmd = 0;
+	int ret = 0;
+
+	if (!key || !prep) {
+		ret = -EINVAL;
+		pr_err("Input data incorrect\n");
+		goto out;
+	}
+
+	datalen = prep->datalen;
+
+	if (datalen <= 0 || datalen > 32767) {
+		ret = -EINVAL;
+		pr_err("Payload data size incorrect\n");
+		goto out;
+	}
+
+	/* Allocate memory to get a parsable string */
+	data = kmalloc(datalen + 1, GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(data, prep->data, datalen);
+	data[datalen] = '\0';
+
+	ckpayload = caam_payload_alloc(key);
+	if (!ckpayload) {
+		pr_err("Fail to allocate payload\n");
+		ret = -ENOMEM;
+		goto free_data;
+	}
+
+	/* Initialize and fill the payload */
+	key_cmd = parse_inputdata(data, ckpayload);
+	if (key_cmd == OP_ERROR) {
+		pr_err("Fail to parse data\n");
+		ret = key_cmd;
+		goto free_payload;
+	}
+
+	/* Create the black key and/or the blob */
+	caam_transform(key_cmd, ckpayload);
+	if (ret != 0) {
+		pr_info("transform fail (%d)\n", ret);
+		goto free_payload;
+	}
+
+	/* Store the payload to the key */
+	rcu_assign_keypointer(key, ckpayload);
+
+	goto out;
+
+free_payload:
+	kzfree(ckpayload);
+
+free_data:
+	kzfree(data);
+
+out:
+	return ret;
+}
+
+/*
+ * caam_read - copy the blob data to userspace.
+ * param[in]: key pointer to key struct
+ * param[in]: buffer pointer to user data for creating key
+ * param[in]: buflen is the length of the buffer
+ * On success, return to userspace the caam key data size.
+ */
+static long caam_read(const struct key *key, char __user *buffer, size_t buflen)
+{
+	const struct caam_key_payload *ckpayload = NULL;
+	size_t size_to_copy;
+	size_t size_copied = 0;
+	unsigned long not_copied;
+	char *to = buffer;
+
+	/* Retrieve the payload */
+	ckpayload = dereference_key_locked(key);
+	if (!ckpayload) {
+		pr_err("Fail to retrieve key payload\n");
+		return -EINVAL;
+	}
+
+	/* Check all the data can be copied */
+	size_to_copy = ckpayload->blob_len;
+
+	/* If buflen == 0, the user request the size needed */
+	if (buflen == 0)
+		return size_to_copy;
+
+	/* Check the buffer */
+	if (!buffer) {
+		pr_err("Buffer not set\n");
+		return -EINVAL;
+	}
+
+	/* Check the buffer is big enough */
+	if (size_to_copy > buflen) {
+		pr_err("Buffer length too short\n");
+		return -ENOMEM;
+	}
+
+	/* Copy blob */
+	not_copied = copy_to_user(to, ckpayload->blob, ckpayload->blob_len);
+	if (not_copied != 0) {
+		pr_err("Copy of black blob failed\n");
+		return -EIO;
+	}
+	size_copied += ckpayload->blob_len;
+
+	if (size_to_copy != size_copied)
+		pr_info("Mismatch between size computed and copied\n");
+
+	return size_copied;
+}
+
+/* Description of the key type for CAAM keys */
+struct key_type key_type_caam_tk = {
+	.name = "caam_tk",
+	.instantiate = caam_instantiate,
+	.destroy = caam_destroy,
+	.read = caam_read,
+};
+EXPORT_SYMBOL_GPL(key_type_caam_tk);
+
+static int __init init_caam_key(void)
+{
+	int ret;
+
+	ret = register_key_type(&key_type_caam_tk);
+	if (ret) {
+		pr_err("Failed to register key storage %s\n",
+		       key_type_caam_tk.name);
+		return -EIO;
+	}
+
+	return ret;
+}
+
+static void __exit cleanup_caam_key(void)
+{
+	unregister_key_type(&key_type_caam_tk);
+}
+
+late_initcall(init_caam_key);
+module_exit(cleanup_caam_key);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/crypto/caam/caam_key.h b/drivers/crypto/caam/caam_key.h
new file mode 100644
index 0000000..93273ea
--- /dev/null
+++ b/drivers/crypto/caam/caam_key.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 NXP.
+ *
+ */
+
+#ifndef _KEYS_caam_TYPE_H
+#define _KEYS_caam_TYPE_H
+
+#include <linux/rcupdate.h>
+#include <linux/key-type.h>
+#include <keys/user-type.h>
+#include "caam_desc.h"
+#include "tag_object.h"
+
+extern struct key_type key_type_caam_tk;
+
+/* Minimum key size to be used is 32 bytes and maximum key size fixed
+ * is 128 bytes.
+ * Blob size to be kept is Maximum key size + blob header added by CAAM.
+ */
+
+#define MIN_KEY_SIZE                    16
+#define MAX_KEY_SIZE                    128
+
+#define MAX_BLACK_KEY_SIZE               (MAX_KEY_SIZE + CCM_OVERHEAD +\
+						TAG_OVERHEAD)
+
+#define MAX_BLOB_SIZE                   (MAX_KEY_SIZE + BLOB_OVERHEAD)
+
+struct caam_key_payload {
+	/*
+	 * The aliasing of the structure allow user to see this payload
+	 * as a user defined payload
+	 *
+	 * The structure has to be set during execution
+	 */
+	struct aliased_user_key_payload {
+		struct rcu_head	rcu;
+		unsigned short datalen;
+		char data[MAX_BLACK_KEY_SIZE];
+	} upayload;
+
+	size_t key_len;
+	unsigned char key[MAX_KEY_SIZE + 1];
+	int key_fmt_val;
+
+	size_t black_key_len;
+	unsigned char black_key[MAX_BLACK_KEY_SIZE];
+
+	size_t blob_len;
+	unsigned char blob[MAX_BLOB_SIZE];
+
+	size_t key_mod_len;
+	const void *key_mod;
+};
+
+#endif
diff --git a/drivers/crypto/caam/caam_util.c b/drivers/crypto/caam/caam_util.c
new file mode 100644
index 0000000..6ad19d5
--- /dev/null
+++ b/drivers/crypto/caam/caam_util.c
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Utility functions for CAAM
+ *
+ * Copyright 2018 NXP
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+
+#include "caam.h"
+#include "caam_util.h"
+
+/**
+ * @brief      Prepare data to be written to CAAM
+ *
+ * @details    The function performs:
+ *  - Allocation of memory compatible with DMA
+ *  - Retrieve the DMA address
+ *  - Copy @b data into @b allocated_data
+ *  - Synchronise the DMA
+ *
+ * @note       The function unprepare_write_data() must be called from cleanup
+ *
+ * @param[in]  jrdev           The jrdev
+ * @param[in]  data            The data
+ * @param[in]  size            The size
+ * @param[out] dma_addr        The dma address
+ * @param[out] allocated_data  The allocated data
+ *
+ * @return     0 on success else error code
+ */
+int prepare_write_data(struct device *jrdev, const u8 *data, size_t size,
+		       caam_dma_addr_t *dma_addr, u8 **allocated_data)
+{
+	int err = 0;
+
+	/* Allocate memory for data compatible with DMA */
+	*allocated_data = kmalloc(size, GFP_KERNEL | GFP_DMA);
+	if (!*allocated_data) {
+		err = (-ENOMEM);
+		goto exit;
+	}
+
+	/* Get DMA address */
+	*dma_addr = dma_map_single(jrdev, *allocated_data, size, DMA_TO_DEVICE);
+	if (dma_mapping_error(jrdev, *dma_addr)) {
+		dev_err(jrdev, "unable to map data: %p\n", data);
+		err = (-ENOMEM);
+		goto free_alloc;
+	}
+
+	/* Copy the data and synchronize the DMA */
+	memcpy(*allocated_data, data, size);
+	dma_sync_single_for_device(jrdev, *dma_addr, size, DMA_TO_DEVICE);
+
+	goto exit;
+
+free_alloc:
+	kfree(*allocated_data);
+
+exit:
+	return err;
+}
+EXPORT_SYMBOL(prepare_write_data);
+
+/**
+ * @brief      Unprepare the data written
+ *
+ * @details    The function performs:
+ * - Clear the temporary memory
+ * - Unmap the DMA address
+ * - Free @b allocated_data
+ *
+ * @attention  Must be called on data prepared with prepare_write_data()
+ *
+ * @param[in]  jrdev           The jrdev
+ * @param[in]  dma_addr        The dma address
+ * @param[in]  allocated_data  The allocated data
+ * @param[in]  size            The size
+ */
+void unprepare_write_data(struct device *jrdev,
+			  caam_dma_addr_t dma_addr,
+			  u8 *allocated_data, size_t size)
+{
+	/* Clear the data */
+	memset(allocated_data, 0, size);
+	dma_sync_single_for_device(jrdev, dma_addr, size, DMA_TO_DEVICE);
+
+	/* Free the resources */
+	dma_unmap_single(jrdev, dma_addr, size, DMA_TO_DEVICE);
+	kfree(allocated_data);
+}
+EXPORT_SYMBOL(unprepare_write_data);
+
+/**
+ * @brief      Prepare data to be read from CAAM
+ *
+ * @details    The function performs:
+ *  - Allocation of memory compatible with DMA
+ *  - Retrieve the DMA address
+ *
+ * @note       The function read_data_prepared() must be called prior to read
+ *             data. The function unprepare_read_data() must be called from
+ *             cleanup
+ *
+ * @param[in]  jrdev           The jrdev
+ * @param[in]  size            The size
+ * @param[out] dma_addr        The dma address
+ * @param[out] allocated_data  The allocated data
+ *
+ * @return     0 on success else error code
+ */
+int prepare_read_data(struct device *jrdev, size_t size,
+		      caam_dma_addr_t *dma_addr, u8 **allocated_data)
+{
+	int err = 0;
+
+	/* Allocate memory for data compatible with DMA */
+	*allocated_data = kmalloc(size, GFP_KERNEL | GFP_DMA);
+	if (!*allocated_data) {
+		err = (-ENOMEM);
+		goto exit;
+	}
+
+	/* Get DMA address */
+	*dma_addr = dma_map_single(jrdev, *allocated_data, size,
+				   DMA_FROM_DEVICE);
+	if (dma_mapping_error(jrdev, *dma_addr)) {
+		dev_err(jrdev, "unable to map data\n");
+		err = (-ENOMEM);
+		goto free_alloc;
+	}
+
+	goto exit;
+
+free_alloc:
+	kfree(*allocated_data);
+
+exit:
+	return err;
+}
+EXPORT_SYMBOL(prepare_read_data);
+
+/**
+ * @brief         Reads prepared data
+ *
+ * @details       The function performs:
+ *  - Synchronization of the data
+ *  - copy @b allocated_data to @b data
+ *
+ * @attention     Must be called on data prepared with prepare_read_data()
+ *
+ * @param[in]     jrdev           The jrdev
+ * @param[in,out] data            The data
+ * @param[in]     dma_addr        The dma address
+ * @param[in]     allocated_data  The allocated data
+ * @param[in]     size            The size
+ */
+void read_data_prepared(struct device *jrdev, u8 *data,
+			caam_dma_addr_t dma_addr,
+			u8 *allocated_data, size_t size)
+{
+	/* Synchronize the DMA and copy the data */
+	dma_sync_single_for_device(jrdev, dma_addr, size, DMA_FROM_DEVICE);
+	memcpy(data, allocated_data, size);
+}
+EXPORT_SYMBOL(read_data_prepared);
+
+/**
+ * @brief      Unprepare the data read
+ *
+ * @details    The function performs:
+ * - Clear the temporary memory
+ * - DMA unmapping
+ * - Free @b allocated_data
+ *
+ * @attention  Must be called on data prepared with prepare_read_data()
+ *
+ * @param      jrdev           The jrdev
+ * @param[in]  dma_addr        The dma address
+ * @param      allocated_data  The allocated data
+ * @param[in]  size            The size
+ */
+void unprepare_read_data(struct device *jrdev, caam_dma_addr_t dma_addr,
+			 u8 *allocated_data, size_t size)
+{
+	/* Clear the data */
+	memset(allocated_data, 0, size);
+	dma_sync_single_for_device(jrdev, dma_addr, size, DMA_FROM_DEVICE);
+
+	/* Free the resources */
+	dma_unmap_single(jrdev, dma_addr, size,	DMA_FROM_DEVICE);
+	kfree(allocated_data);
+}
+EXPORT_SYMBOL(unprepare_read_data);
+
+/**
+ * @brief      Gets the caam dma address of a physical address.
+ *
+ * @param      phy_address  The physical address
+ *
+ * @return     The caam dma address.
+ */
+caam_dma_addr_t get_caam_dma_addr(const void *phy_address)
+{
+	uintptr_t ptr_conv;
+	caam_dma_addr_t caam_dma_address = 0;
+
+	/* Check conversion is possible */
+	if (sizeof(caam_dma_address) < sizeof(phy_address)) {
+		/* We have to check that all bits sets in the phy_address
+		 * can be stored in caam_dma_address
+		 */
+
+		/* We generate a mask of the representable bits */
+		u64 mask = GENMASK_ULL(sizeof(caam_dma_address) * 8, 0);
+
+		/* We check that the bits not reprensentable of
+		 * phy_address are not set
+		 */
+		if ((uintptr_t)phy_address & ~mask)
+			goto exit;
+	}
+
+	/* We convert address to caam_dma_address */
+	ptr_conv = (uintptr_t)phy_address;
+	caam_dma_address = (caam_dma_addr_t)ptr_conv;
+
+exit:
+	return caam_dma_address;
+}
+EXPORT_SYMBOL(get_caam_dma_addr);
diff --git a/drivers/crypto/caam/caam_util.h b/drivers/crypto/caam/caam_util.h
new file mode 100644
index 0000000..6d27e03
--- /dev/null
+++ b/drivers/crypto/caam/caam_util.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Utility functions for CAAM exported
+ *
+ * Copyright 2018 NXP
+ */
+
+#ifndef _CAAM_UTIL_H_
+#define _CAAM_UTIL_H_
+
+#include <linux/device.h>
+
+#include "caam.h"
+#include "regs.h"
+#include "caam_desc.h"
+
+extern int prepare_write_data(struct device *jrdev, const u8 *data, size_t size,
+			      caam_dma_addr_t *dma_addr, u8 **allocated_data);
+
+extern void unprepare_write_data(struct device *jrdev,
+				 caam_dma_addr_t dma_addr,
+				 u8 *allocated_data, size_t size);
+
+extern int prepare_read_data(struct device *jrdev, size_t size,
+			     caam_dma_addr_t *dma_addr, u8 **allocated_data);
+
+extern void read_data_prepared(struct device *jrdev, u8 *data,
+			       caam_dma_addr_t dma_addr,
+			       u8 *allocated_data, size_t size);
+
+extern void unprepare_read_data(struct device *jrdev, caam_dma_addr_t dma_addr,
+				u8 *allocated_data, size_t size);
+
+extern caam_dma_addr_t get_caam_dma_addr(const void *address);
+
+extern int caam_black_key(struct device *jrdev,
+			  const void *key, size_t key_length, u8 key_memtype,
+			  void *black_key, size_t *black_key_length,
+			  u8 black_key_memtype, u8 keyauth, u8 trusted_key);
+
+extern int caam_random_black_key(struct device *jrdev,
+				 size_t key_length,
+				 void *black_key, size_t *black_key_length,
+				 u8 black_key_memtype, u8 keyauth,
+				 u8 trusted_key);
+
+extern int caam_blob_encap(struct device *jrdev,
+			   const void  *secret, size_t secret_length,
+			   u8 secret_memtype,
+			   u8 keycolor, size_t key_length_in_secret,
+			   u8 auth, u8 trusted_key,
+			   const void *keymod, size_t *keymod_length,
+			   u8 keymod_memtype,
+			   void *blob, size_t *blob_length,
+			   u8 blob_memtype, u8 blobcolor);
+
+extern int caam_blob_decap(struct device *jrdev,
+			   const void *blob, size_t blob_length,
+			   u8 blob_memtype,
+			   u8 blobcolor,
+			   const void *keymod, size_t *keymod_length,
+			   u8 keymod_memtype,
+			   void *secret, size_t *secret_length,
+			   u8 secret_memtype,
+			   u8 keycolor, size_t *key_length_in_secret,
+			   u8 auth, u8 trusted_key);
+
+/**
+ * @brief      Determines if key color is valid
+ *
+ * @param[in]  keycolor  The keycolor
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_key_color(u8 keycolor)
+{
+	return (keycolor == BLACK_KEY) || (keycolor == RED_KEY);
+}
+
+/**
+ * @brief      Determines if the memory type is valid
+ *
+ * @param[in]  memtype  The memory type
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_memory_type(u8 memtype)
+{
+	return (memtype == DATA_GENMEM) ||
+		(memtype == DATA_DMAMEM) ||
+		(memtype == DATA_SECMEM);
+}
+
+/**
+ * @brief      Determines if the blob color is valid
+ *
+ * @param[in]  blobcolor  The blob color
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_blob_color(u8 blobcolor)
+{
+	return (blobcolor == RED_BLOB) || (blobcolor == BLACK_BLOB);
+}
+
+/**
+ * @brief      Determines if the auth is valid
+ *
+ * @param[in]  auth  The authentication
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_auth(u8 auth)
+{
+	return (auth == KEY_COVER_ECB) || (auth == KEY_COVER_CCM);
+}
+
+/**
+ * @brief      Determines if trusted key value is valid
+ *
+ * @param[in]  trusted_key  The trusted key value
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_trusted_key(u8 trusted_key)
+{
+	return (trusted_key == UNTRUSTED_KEY) || (trusted_key == TRUSTED_KEY);
+}
+
+#endif /* _CAAM_UTIL_H_ */
diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h
index 9dc79b0..fbaefa7 100644
--- a/drivers/crypto/caam/desc.h
+++ b/drivers/crypto/caam/desc.h
@@ -182,6 +182,9 @@
 /* Length in bytes */
 #define KEY_LENGTH_MASK		0x000003ff
 
+/* Key can be stored in plaintext form later */
+#define KEY_PTS			0x00004000
+
 /*
  * LOAD/SEQ_LOAD/STORE/SEQ_STORE Command Constructs
  */
diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c
index 616a427..49fd2b9 100644
--- a/drivers/crypto/caam/jr.c
+++ b/drivers/crypto/caam/jr.c
@@ -9,6 +9,7 @@
 #include <linux/of_irq.h>
 #include <linux/of_address.h>
 
+#include "caam.h"
 #include "compat.h"
 #include "ctrl.h"
 #include "regs.h"
@@ -396,6 +397,50 @@ int caam_jr_enqueue(struct device *dev, u32 *desc,
 }
 EXPORT_SYMBOL(caam_jr_enqueue);
 
+/* Structure to wait for the job to complete */
+struct jr_job_result {
+	int error;
+	struct completion completion;
+};
+
+/* Callback when a job has been completed
+ * It expects the context to be a pointer on jr_job_result
+ */
+static void jr_job_done_cb(struct device *jrdev, u32 *desc, u32 err,
+			   void *context)
+{
+	struct jr_job_result *res = context;
+
+	dev_dbg(jrdev, "jobs %p done: %x", desc, err);
+	if (err)
+		caam_jr_strstatus(jrdev, err);
+
+	res->error = err; /* save off the error for postprocessing */
+
+	complete(&res->completion);	/* mark us complete */
+}
+
+/* Run a job and wait for its completion */
+int jr_run_job_and_wait_completion(struct device *jrdev, u32 *jobdesc)
+{
+	struct jr_job_result jobres = {0};
+	int rtn = 0;
+
+	init_completion(&jobres.completion);
+
+	dev_dbg(jrdev, "Enqueing job %p", jobdesc);
+	rtn = caam_jr_enqueue(jrdev, jobdesc, jr_job_done_cb, &jobres);
+	if (rtn)
+		goto exit;
+
+	wait_for_completion_interruptible(&jobres.completion);
+	rtn = jobres.error;
+
+exit:
+	return rtn;
+}
+EXPORT_SYMBOL(jr_run_job_and_wait_completion);
+
 /*
  * Init JobR independent of platform property detection
  */
diff --git a/drivers/crypto/caam/sm.h b/drivers/crypto/caam/sm.h
index 65ec9d7..43fd823 100644
--- a/drivers/crypto/caam/sm.h
+++ b/drivers/crypto/caam/sm.h
@@ -7,33 +7,19 @@
 #ifndef SM_H
 #define SM_H
 
+#include "caam_desc.h"
 
 /* Storage access permissions */
 #define SM_PERM_READ 0x01
 #define SM_PERM_WRITE 0x02
 #define SM_PERM_BLOB 0x03
 
-/* Define treatment of secure memory vs. general memory blobs */
-#define SM_SECMEM 0
-#define SM_GENMEM 1
-
-/* Define treatment of red/black keys */
-#define RED_KEY 0
-#define BLACK_KEY 1
-
-/* Define key encryption/covering options */
-#define KEY_COVER_ECB 0	/* cover key in AES-ECB */
-#define KEY_COVER_CCM 1 /* cover key with AES-CCM */
-
 /*
  * Round a key size up to an AES blocksize boundary so to allow for
  * padding out to a full block
  */
 #define AES_BLOCK_PAD(x) ((x % 16) ? ((x >> 4) + 1) << 4 : x)
 
-/* Define space required for BKEK + MAC tag storage in any blob */
-#define BLOB_OVERHEAD (32 + 16)
-
 /* Keystore maintenance functions */
 void sm_init_keystore(struct device *dev);
 u32 sm_detect_keystore_units(struct device *dev);
@@ -50,22 +36,9 @@ extern int sm_keystore_slot_load(struct device *dev, u32 unit, u32 slot,
 				 const u8 *key_data, u32 key_length);
 extern int sm_keystore_slot_read(struct device *dev, u32 unit, u32 slot,
 				 u32 key_length, u8 *key_data);
-extern int sm_keystore_cover_key(struct device *dev, u32 unit, u32 slot,
-				 u16 key_length, u8 keyauth);
-extern int sm_keystore_slot_export(struct device *dev, u32 unit, u32 slot,
-				   u8 keycolor, u8 keyauth, u8 *outbuf,
-				   u16 keylen, u8 *keymod);
-extern int sm_keystore_slot_import(struct device *dev, u32 unit, u32 slot,
-				   u8 keycolor, u8 keyauth, u8 *inbuf,
-				   u16 keylen, u8 *keymod);
-
-/* Prior functions from legacy API, deprecated */
-extern int sm_keystore_slot_encapsulate(struct device *dev, u32 unit,
-					u32 inslot, u32 outslot, u16 secretlen,
-					u8 *keymod, u16 keymodlen);
-extern int sm_keystore_slot_decapsulate(struct device *dev, u32 unit,
-					u32 inslot, u32 outslot, u16 secretlen,
-					u8 *keymod, u16 keymodlen);
+extern void *sm_keystore_get_slot_phys_addr(struct device *dev,
+					    u32 unit, u32 slot);
+extern u32 sm_keystore_get_slot_size(struct device *dev, u32 unit, u32 slot);
 
 /* Data structure to hold per-slot information */
 struct keystore_data_slot_info {
diff --git a/drivers/crypto/caam/sm_store.c b/drivers/crypto/caam/sm_store.c
index df18f1b..4886a23 100644
--- a/drivers/crypto/caam/sm_store.c
+++ b/drivers/crypto/caam/sm_store.c
@@ -31,16 +31,11 @@
 
 #include "compat.h"
 #include "regs.h"
-#include "jr.h"
-#include "desc.h"
 #include "intern.h"
-#include "error.h"
 #include "sm.h"
+#include "jr.h"
 #include <linux/of_address.h>
 
-#define SECMEM_KEYMOD_LEN 8
-#define GENMEM_KEYMOD_LEN 16
-
 #ifdef SM_DEBUG_CONT
 void sm_show_page(struct device *dev, struct sm_page_descriptor *pgdesc)
 {
@@ -57,8 +52,6 @@ void sm_show_page(struct device *dev, struct sm_page_descriptor *pgdesc)
 }
 #endif
 
-#define INITIAL_DESCSZ 16	/* size of tmp buffer for descriptor const. */
-
 static __always_inline u32 sm_send_cmd(struct caam_drv_private_sm *smpriv,
 					     struct caam_drv_private_jr *jrpriv,
 					     u32 cmd, u32 *status)
@@ -96,359 +89,6 @@ static __always_inline u32 sm_send_cmd(struct caam_drv_private_sm *smpriv,
 
 	return 0;
 }
-/*
- * Construct a black key conversion job descriptor
- *
- * This function constructs a job descriptor capable of performing
- * a key blackening operation on a plaintext secure memory resident object.
- *
- * - desc	pointer to a pointer to the descriptor generated by this
- *		function. Caller will be responsible to kfree() this
- *		descriptor after execution.
- * - key	physical pointer to the plaintext, which will also hold
- *		the result. Since encryption occurs in place, caller must
- *              ensure that the space is large enough to accommodate the
- *              blackened key
- * - keysz	size of the plaintext
- * - auth	if a CCM-covered key is required, use KEY_COVER_CCM, else
- *		use KEY_COVER_ECB.
- *
- * KEY to key1 from @key_addr LENGTH 16 BYTES;
- * FIFO STORE from key1[ecb] TO @key_addr LENGTH 16 BYTES;
- *
- * Note that this variant uses the JDKEK only; it does not accommodate the
- * trusted key encryption key at this time.
- *
- */
-static int blacken_key_jobdesc(u32 **desc, void *key, u16 keysz, bool auth)
-{
-	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
-	u16 dsize, idx;
-
-	memset(tmpdesc, 0, INITIAL_DESCSZ * sizeof(u32));
-	idx = 1;
-
-	/* Load key to class 1 key register */
-	tmpdesc[idx++] = CMD_KEY | CLASS_1 | (keysz & KEY_LENGTH_MASK);
-	tmpdesc[idx++] = (uintptr_t)key;
-
-	/* ...and write back out via FIFO store*/
-	tmpdesc[idx] = CMD_FIFO_STORE | CLASS_1 | (keysz & KEY_LENGTH_MASK);
-
-	/* plus account for ECB/CCM option in FIFO_STORE */
-	if (auth == KEY_COVER_ECB)
-		tmpdesc[idx] |= FIFOST_TYPE_KEY_KEK;
-	else
-		tmpdesc[idx] |= FIFOST_TYPE_KEY_CCM_JKEK;
-
-	idx++;
-	tmpdesc[idx++] = (uintptr_t)key;
-
-	/* finish off the job header */
-	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
-	dsize = idx * sizeof(u32);
-
-	/* now allocate execution buffer and coat it with executable */
-	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
-	if (tdesc == NULL)
-		return 0;
-
-	memcpy(tdesc, tmpdesc, dsize);
-	*desc = tdesc;
-
-	return dsize;
-}
-
-/*
- * Construct a blob encapsulation job descriptor
- *
- * This function dynamically constructs a blob encapsulation job descriptor
- * from the following arguments:
- *
- * - desc	pointer to a pointer to the descriptor generated by this
- *		function. Caller will be responsible to kfree() this
- *		descriptor after execution.
- * - keymod	Physical pointer to a key modifier, which must reside in a
- *		contiguous piece of memory. Modifier will be assumed to be
- *		8 bytes long for a blob of type SM_SECMEM, or 16 bytes long
- *		for a blob of type SM_GENMEM (see blobtype argument).
- * - secretbuf	Physical pointer to a secret, normally a black or red key,
- *		possibly residing within an accessible secure memory page,
- *		of the secret to be encapsulated to an output blob.
- * - outbuf	Physical pointer to the destination buffer to receive the
- *		encapsulated output. This buffer will need to be 48 bytes
- *		larger than the input because of the added encapsulation data.
- *		The generated descriptor will account for the increase in size,
- *		but the caller must also account for this increase in the
- *		buffer allocator.
- * - secretsz	Size of input secret, in bytes. This is limited to 65536
- *		less the size of blob overhead, since the length embeds into
- *		DECO pointer in/out instructions.
- * - keycolor   Determines if the source data is covered (black key) or
- *		plaintext (red key). RED_KEY or BLACK_KEY are defined in
- *		for this purpose.
- * - blobtype	Determine if encapsulated blob should be a secure memory
- *		blob (SM_SECMEM), with partition data embedded with key
- *		material, or a general memory blob (SM_GENMEM).
- * - auth	If BLACK_KEY source is covered via AES-CCM, specify
- *		KEY_COVER_CCM, else uses AES-ECB (KEY_COVER_ECB).
- *
- * Upon completion, desc points to a buffer containing a CAAM job
- * descriptor which encapsulates data into an externally-storable blob
- * suitable for use across power cycles.
- *
- * This is an example of a black key encapsulation job into a general memory
- * blob. Notice the 16-byte key modifier in the LOAD instruction. Also note
- * the output 48 bytes longer than the input:
- *
- * [00] B0800008       jobhdr: stidx=0 len=8
- * [01] 14400010           ld: ccb2-key len=16 offs=0
- * [02] 08144891               ptr->@0x08144891
- * [03] F800003A    seqoutptr: len=58
- * [04] 01000000               out_ptr->@0x01000000
- * [05] F000000A     seqinptr: len=10
- * [06] 09745090               in_ptr->@0x09745090
- * [07] 870D0004    operation: encap blob  reg=memory, black, format=normal
- *
- * This is an example of a red key encapsulation job for storing a red key
- * into a secure memory blob. Note the 8 byte modifier on the 12 byte offset
- * in the LOAD instruction; this accounts for blob permission storage:
- *
- * [00] B0800008       jobhdr: stidx=0 len=8
- * [01] 14400C08           ld: ccb2-key len=8 offs=12
- * [02] 087D0784               ptr->@0x087d0784
- * [03] F8000050    seqoutptr: len=80
- * [04] 09251BB2               out_ptr->@0x09251bb2
- * [05] F0000020     seqinptr: len=32
- * [06] 40000F31               in_ptr->@0x40000f31
- * [07] 870D0008    operation: encap blob  reg=memory, red, sec_mem,
- *                             format=normal
- *
- * Note: this function only generates 32-bit pointers at present, and should
- * be refactored using a scheme that allows both 32 and 64 bit addressing
- */
-
-static int blob_encap_jobdesc(u32 **desc, dma_addr_t keymod,
-			      void *secretbuf, dma_addr_t outbuf,
-			      u16 secretsz, u8 keycolor, u8 blobtype, u8 auth)
-{
-	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
-	u16 dsize, idx;
-
-	memset(tmpdesc, 0, INITIAL_DESCSZ * sizeof(u32));
-	idx = 1;
-
-	/*
-	 * Key modifier works differently for secure/general memory blobs
-	 * This accounts for the permission/protection data encapsulated
-	 * within the blob if a secure memory blob is requested
-	 */
-	if (blobtype == SM_SECMEM)
-		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
-				 LDST_SRCDST_BYTE_KEY |
-				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
-				 | (8 & LDST_LEN_MASK);
-	else /* is general memory blob */
-		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
-				 LDST_SRCDST_BYTE_KEY | (16 & LDST_LEN_MASK);
-
-	tmpdesc[idx++] = (u32)keymod;
-
-	/*
-	 * Encapsulation output must include space for blob key encryption
-	 * key and MAC tag
-	 */
-	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | (secretsz + BLOB_OVERHEAD);
-	tmpdesc[idx++] = (u32)outbuf;
-
-	/* Input data, should be somewhere in secure memory */
-	tmpdesc[idx++] = CMD_SEQ_IN_PTR | secretsz;
-	tmpdesc[idx++] = (uintptr_t)secretbuf;
-
-	/* Set blob encap, then color */
-	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_ENCAP_PROTOCOL | OP_PCLID_BLOB;
-
-	if (blobtype == SM_SECMEM)
-		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;
-
-	if (auth == KEY_COVER_CCM)
-		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
-
-	if (keycolor == BLACK_KEY)
-		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;
-
-	idx++;
-	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
-	dsize = idx * sizeof(u32);
-
-	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
-	if (tdesc == NULL)
-		return 0;
-
-	memcpy(tdesc, tmpdesc, dsize);
-	*desc = tdesc;
-	return dsize;
-}
-
-/*
- * Construct a blob decapsulation job descriptor
- *
- * This function dynamically constructs a blob decapsulation job descriptor
- * from the following arguments:
- *
- * - desc	pointer to a pointer to the descriptor generated by this
- *		function. Caller will be responsible to kfree() this
- *		descriptor after execution.
- * - keymod	Physical pointer to a key modifier, which must reside in a
- *		contiguous piece of memory. Modifier will be assumed to be
- *		8 bytes long for a blob of type SM_SECMEM, or 16 bytes long
- *		for a blob of type SM_GENMEM (see blobtype argument).
- * - blobbuf	Physical pointer (into external memory) of the blob to
- *		be decapsulated. Blob must reside in a contiguous memory
- *		segment.
- * - outbuf	Physical pointer of the decapsulated output, possibly into
- *		a location within a secure memory page. Must be contiguous.
- * - secretsz	Size of encapsulated secret in bytes (not the size of the
- *		input blob).
- * - keycolor   Determines if decapsulated content is encrypted (BLACK_KEY)
- *		or left as plaintext (RED_KEY).
- * - blobtype	Determine if encapsulated blob should be a secure memory
- *		blob (SM_SECMEM), with partition data embedded with key
- *		material, or a general memory blob (SM_GENMEM).
- * - auth	If decapsulation path is specified by BLACK_KEY, then if
- *		AES-CCM is requested for key covering use KEY_COVER_CCM, else
- *		use AES-ECB (KEY_COVER_ECB).
- *
- * Upon completion, desc points to a buffer containing a CAAM job descriptor
- * that decapsulates a key blob from external memory into a black (encrypted)
- * key or red (plaintext) content.
- *
- * This is an example of a black key decapsulation job from a general memory
- * blob. Notice the 16-byte key modifier in the LOAD instruction.
- *
- * [00] B0800008       jobhdr: stidx=0 len=8
- * [01] 14400010           ld: ccb2-key len=16 offs=0
- * [02] 08A63B7F               ptr->@0x08a63b7f
- * [03] F8000010    seqoutptr: len=16
- * [04] 01000000               out_ptr->@0x01000000
- * [05] F000003A     seqinptr: len=58
- * [06] 01000010               in_ptr->@0x01000010
- * [07] 860D0004    operation: decap blob  reg=memory, black, format=normal
- *
- * This is an example of a red key decapsulation job for restoring a red key
- * from a secure memory blob. Note the 8 byte modifier on the 12 byte offset
- * in the LOAD instruction:
- *
- * [00] B0800008       jobhdr: stidx=0 len=8
- * [01] 14400C08           ld: ccb2-key len=8 offs=12
- * [02] 01000000               ptr->@0x01000000
- * [03] F8000020    seqoutptr: len=32
- * [04] 400000E6               out_ptr->@0x400000e6
- * [05] F0000050     seqinptr: len=80
- * [06] 08F0C0EA               in_ptr->@0x08f0c0ea
- * [07] 860D0008    operation: decap blob  reg=memory, red, sec_mem,
- *			       format=normal
- *
- * Note: this function only generates 32-bit pointers at present, and should
- * be refactored using a scheme that allows both 32 and 64 bit addressing
- */
-
-static int blob_decap_jobdesc(u32 **desc, dma_addr_t keymod, dma_addr_t blobbuf,
-			      u8 *outbuf, u16 secretsz, u8 keycolor,
-			      u8 blobtype, u8 auth)
-{
-	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
-	u16 dsize, idx;
-
-	memset(tmpdesc, 0, INITIAL_DESCSZ * sizeof(u32));
-	idx = 1;
-
-	/* Load key modifier */
-	if (blobtype == SM_SECMEM)
-		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
-				 LDST_SRCDST_BYTE_KEY |
-				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
-				 | (8 & LDST_LEN_MASK);
-	else /* is general memory blob */
-		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
-				 LDST_SRCDST_BYTE_KEY | (16 & LDST_LEN_MASK);
-
-	tmpdesc[idx++] = (u32)keymod;
-
-	/* Compensate BKEK + MAC tag over size of encapsulated secret */
-	tmpdesc[idx++] = CMD_SEQ_IN_PTR | (secretsz + BLOB_OVERHEAD);
-	tmpdesc[idx++] = (u32)blobbuf;
-	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | secretsz;
-	tmpdesc[idx++] = (uintptr_t)outbuf;
-
-	/* Decapsulate from secure memory partition to black blob */
-	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_DECAP_PROTOCOL | OP_PCLID_BLOB;
-
-	if (blobtype == SM_SECMEM)
-		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;
-
-	if (auth == KEY_COVER_CCM)
-		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
-
-	if (keycolor == BLACK_KEY)
-		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;
-
-	idx++;
-	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
-	dsize = idx * sizeof(u32);
-
-	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
-	if (tdesc == NULL)
-		return 0;
-
-	memcpy(tdesc, tmpdesc, dsize);
-	*desc = tdesc;
-	return dsize;
-}
-
-/*
- * Pseudo-synchronous ring access functions for carrying out key
- * encapsulation and decapsulation
- */
-
-struct sm_key_job_result {
-	int error;
-	struct completion completion;
-};
-
-void sm_key_job_done(struct device *dev, u32 *desc, u32 err, void *context)
-{
-	struct sm_key_job_result *res = context;
-
-	if (err)
-		caam_jr_strstatus(dev, err);
-
-	res->error = err;	/* save off the error for postprocessing */
-
-	complete(&res->completion);	/* mark us complete */
-}
-
-static int sm_key_job(struct device *ksdev, u32 *jobdesc)
-{
-	struct sm_key_job_result testres = {0};
-	struct caam_drv_private_sm *kspriv;
-	int rtn = 0;
-
-	kspriv = dev_get_drvdata(ksdev);
-
-	init_completion(&testres.completion);
-
-	rtn = caam_jr_enqueue(kspriv->smringdev, jobdesc, sm_key_job_done,
-			      &testres);
-	if (rtn)
-		goto exit;
-
-	wait_for_completion_interruptible(&testres.completion);
-	rtn = testres.error;
-
-exit:
-	return rtn;
-}
 
 /*
  * Following section establishes the default methods for keystore access
@@ -835,220 +475,41 @@ int sm_keystore_slot_read(struct device *dev, u32 unit, u32 slot,
 }
 EXPORT_SYMBOL(sm_keystore_slot_read);
 
-/*
- * Blacken a clear key in a slot. Operates "in place".
- * Limited to class 1 keys at the present time
- */
-int sm_keystore_cover_key(struct device *dev, u32 unit, u32 slot,
-			  u16 key_length, u8 keyauth)
+void *sm_keystore_get_slot_phys_addr(struct device *dev, u32 unit, u32 slot)
 {
+	void *retval = NULL;
 	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
-	int retval = 0;
-	u8 __iomem *slotaddr;
-	void *slotphys;
-	u32 dsize, jstat;
-	u32 __iomem *coverdesc = NULL;
-
-	/* Get the address of the object in the slot */
-	slotaddr = (u8 *)smpriv->slot_get_address(dev, unit, slot);
-	slotphys = (u8 *)smpriv->slot_get_physical(dev, unit, slot);
-
-	dsize = blacken_key_jobdesc(&coverdesc, slotphys, key_length, keyauth);
-	if (!dsize)
-		return -ENOMEM;
-	jstat = sm_key_job(dev, coverdesc);
-	if (jstat)
-		retval = -EIO;
-
-	kfree(coverdesc);
-	return retval;
-}
-EXPORT_SYMBOL(sm_keystore_cover_key);
 
-/* Export a black/red key to a blob in external memory */
-int sm_keystore_slot_export(struct device *dev, u32 unit, u32 slot, u8 keycolor,
-			    u8 keyauth, u8 *outbuf, u16 keylen, u8 *keymod)
-{
-	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
-	int retval = 0;
-	u8 __iomem *slotaddr, *lkeymod;
-	u8 __iomem *slotphys;
-	dma_addr_t keymod_dma, outbuf_dma;
-	u32 dsize, jstat;
-	u32 __iomem *encapdesc = NULL;
-	struct device *dev_for_dma_op;
-
-	/* Use the ring as device for DMA operations */
-	dev_for_dma_op = smpriv->smringdev;
-
-	/* Get the base address(es) of the specified slot */
-	slotaddr = (u8 *)smpriv->slot_get_address(dev, unit, slot);
-	slotphys = smpriv->slot_get_physical(dev, unit, slot);
-
-	/* Allocate memory for key modifier compatible with DMA */
-	lkeymod = kmalloc(SECMEM_KEYMOD_LEN, GFP_KERNEL | GFP_DMA);
-	if (!lkeymod) {
-		retval = (-ENOMEM);
-		goto exit;
-	}
-
-	/* Get DMA address for the key modifier */
-	keymod_dma = dma_map_single(dev_for_dma_op, lkeymod,
-					SECMEM_KEYMOD_LEN, DMA_TO_DEVICE);
-	if (dma_mapping_error(dev_for_dma_op, keymod_dma)) {
-		dev_err(dev, "unable to map keymod: %p\n", lkeymod);
-		retval = (-ENOMEM);
-		goto free_keymod;
-	}
-
-	/* Copy the keymod and synchronize the DMA */
-	memcpy(lkeymod, keymod, SECMEM_KEYMOD_LEN);
-	dma_sync_single_for_device(dev_for_dma_op, keymod_dma,
-					SECMEM_KEYMOD_LEN, DMA_TO_DEVICE);
-
-	/* Get DMA address for the destination */
-	outbuf_dma = dma_map_single(dev_for_dma_op, outbuf,
-				keylen + BLOB_OVERHEAD, DMA_FROM_DEVICE);
-	if (dma_mapping_error(dev_for_dma_op, outbuf_dma)) {
-		dev_err(dev, "unable to map outbuf: %p\n", outbuf);
-		retval = (-ENOMEM);
-		goto unmap_keymod;
-	}
-
-	/* Build the encapsulation job descriptor */
-	dsize = blob_encap_jobdesc(&encapdesc, keymod_dma, slotphys, outbuf_dma,
-				   keylen, keycolor, SM_SECMEM, keyauth);
-	if (!dsize) {
-		dev_err(dev, "can't alloc an encapsulation descriptor\n");
-		retval = -ENOMEM;
-		goto unmap_outbuf;
-	}
-
-	/* Run the job */
-	jstat = sm_key_job(dev, encapdesc);
-	if (jstat) {
-		retval = (-EIO);
-		goto free_desc;
-	}
-
-	/* Synchronize the data received */
-	dma_sync_single_for_cpu(dev_for_dma_op, outbuf_dma,
-			keylen + BLOB_OVERHEAD, DMA_FROM_DEVICE);
-
-free_desc:
-	kfree(encapdesc);
-
-unmap_outbuf:
-	dma_unmap_single(dev_for_dma_op, outbuf_dma, keylen + BLOB_OVERHEAD,
-			DMA_FROM_DEVICE);
+	spin_lock(&smpriv->kslock);
 
-unmap_keymod:
-	dma_unmap_single(dev_for_dma_op, keymod_dma, SECMEM_KEYMOD_LEN,
-			DMA_TO_DEVICE);
+	if (!smpriv->slot_get_physical)
+		goto out;
 
-free_keymod:
-	kfree(lkeymod);
+	retval = smpriv->slot_get_physical(dev, unit, slot);
 
-exit:
+out:
+	spin_unlock(&smpriv->kslock);
 	return retval;
 }
-EXPORT_SYMBOL(sm_keystore_slot_export);
+EXPORT_SYMBOL(sm_keystore_get_slot_phys_addr);
 
-/* Import a black/red key from a blob residing in external memory */
-int sm_keystore_slot_import(struct device *dev, u32 unit, u32 slot, u8 keycolor,
-			    u8 keyauth, u8 *inbuf, u16 keylen, u8 *keymod)
+u32 sm_keystore_get_slot_size(struct device *dev, u32 unit, u32 slot)
 {
-	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
 	int retval = 0;
-	u8 __iomem *slotaddr, *lkeymod;
-	u8 __iomem *slotphys;
-	dma_addr_t keymod_dma, inbuf_dma;
-	u32 dsize, jstat;
-	u32 __iomem *decapdesc = NULL;
-	struct device *dev_for_dma_op;
-
-	/* Use the ring as device for DMA operations */
-	dev_for_dma_op = smpriv->smringdev;
-
-	/* Get the base address(es) of the specified slot */
-	slotaddr = (u8 *)smpriv->slot_get_address(dev, unit, slot);
-	slotphys = smpriv->slot_get_physical(dev, unit, slot);
-
-	/* Allocate memory for key modifier compatible with DMA */
-	lkeymod = kmalloc(SECMEM_KEYMOD_LEN, GFP_KERNEL | GFP_DMA);
-	if (!lkeymod) {
-		retval = (-ENOMEM);
-		goto exit;
-	}
-
-	/* Get DMA address for the key modifier */
-	keymod_dma = dma_map_single(dev_for_dma_op, lkeymod,
-					SECMEM_KEYMOD_LEN, DMA_TO_DEVICE);
-	if (dma_mapping_error(dev_for_dma_op, keymod_dma)) {
-		dev_err(dev, "unable to map keymod: %p\n", lkeymod);
-		retval = (-ENOMEM);
-		goto free_keymod;
-	}
-
-	/* Copy the keymod and synchronize the DMA */
-	memcpy(lkeymod, keymod, SECMEM_KEYMOD_LEN);
-	dma_sync_single_for_device(dev_for_dma_op, keymod_dma,
-					SECMEM_KEYMOD_LEN, DMA_TO_DEVICE);
-
-	/* Get DMA address for the input */
-	inbuf_dma = dma_map_single(dev_for_dma_op, inbuf,
-					keylen + BLOB_OVERHEAD, DMA_TO_DEVICE);
-	if (dma_mapping_error(dev_for_dma_op, inbuf_dma)) {
-		dev_err(dev, "unable to map inbuf: %p\n", (void *)inbuf_dma);
-		retval = (-ENOMEM);
-		goto unmap_keymod;
-	}
-
-	/* synchronize the DMA */
-	dma_sync_single_for_device(dev_for_dma_op, inbuf_dma,
-					keylen + BLOB_OVERHEAD, DMA_TO_DEVICE);
-
-	/* Build the encapsulation job descriptor */
-	dsize = blob_decap_jobdesc(&decapdesc, keymod_dma, inbuf_dma, slotphys,
-				   keylen, keycolor, SM_SECMEM, keyauth);
-	if (!dsize) {
-		dev_err(dev, "can't alloc a decapsulation descriptor\n");
-		retval = -ENOMEM;
-		goto unmap_inbuf;
-	}
-
-	/* Run the job */
-	jstat = sm_key_job(dev, decapdesc);
-
-	/*
-	 * May want to expand upon error meanings a bit. Any CAAM status
-	 * is reported as EIO, but we might want to look for something more
-	 * meaningful for something like an ICV error on restore, otherwise
-	 * the caller is left guessing.
-	 */
-	if (jstat) {
-		retval = (-EIO);
-		goto free_desc;
-	}
-
-free_desc:
-	kfree(decapdesc);
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
 
-unmap_inbuf:
-	dma_unmap_single(dev_for_dma_op, inbuf_dma, keylen + BLOB_OVERHEAD,
-			DMA_TO_DEVICE);
+	spin_lock(&smpriv->kslock);
 
-unmap_keymod:
-	dma_unmap_single(dev_for_dma_op, keymod_dma, SECMEM_KEYMOD_LEN,
-			DMA_TO_DEVICE);
+	if (!smpriv->slot_get_slot_size)
+		goto out;
 
-free_keymod:
-	kfree(lkeymod);
+	retval = smpriv->slot_get_slot_size(dev, unit, slot);
 
-exit:
+out:
+	spin_unlock(&smpriv->kslock);
 	return retval;
 }
-EXPORT_SYMBOL(sm_keystore_slot_import);
+EXPORT_SYMBOL(sm_keystore_get_slot_size);
 
 /*
  * Initialization/shutdown subsystem
@@ -1165,7 +626,7 @@ int caam_sm_startup(struct platform_device *pdev)
 	 * an SM instance to any ring instance).
 	 */
 	smpriv->smringdev = caam_jr_alloc();
-	if (!smpriv->smringdev) {
+	if (IS_ERR(smpriv->smringdev)) {
 		dev_err(smdev, "Device for job ring not created\n");
 		ret = -ENODEV;
 		goto unregister_smpdev;
@@ -1308,8 +769,6 @@ static void  __exit caam_sm_exit(void)
 	of_node_put(dev_node);
 
 	caam_sm_shutdown(pdev);
-
-	return;
 }
 
 static int __init caam_sm_init(void)
diff --git a/drivers/crypto/caam/sm_test.c b/drivers/crypto/caam/sm_test.c
index 99b1421..e4b1ced 100644
--- a/drivers/crypto/caam/sm_test.c
+++ b/drivers/crypto/caam/sm_test.c
@@ -27,6 +27,13 @@
 #include "error.h"
 #include "jr.h"
 #include "sm.h"
+#include "caam_desc.h"
+#include "caam_util.h"
+
+#define SECMEM_KEYMOD_LEN 8
+#define GENMEM_KEYMOD_LEN 16
+
+#define INITIAL_DESCSZ 16	/* size of tmp buffer for descriptor const. */
 
 /* Fixed known pattern for a key modifier */
 static u8 skeymod[] = {
@@ -70,9 +77,142 @@ static u8 clrkey[] = {
 	0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
 };
 
+/*
+ * Blacken a clear key in a slot. Operates "in place".
+ * Limited to class 1 keys at the present time
+ */
+static int sm_keystore_cover_key(struct device *dev, u32 unit, u32 slot,
+				 u16 key_length, u8 keyauth)
+{
+	int retval = 0;
+	struct device *jrdev;
+	void *slotphys;
+	size_t black_key_length;
+
+	if (!dev)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(dev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	black_key_length = sm_keystore_get_slot_size(dev, unit, slot);
+	if (!black_key_length) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_black_key(jrdev,
+				slotphys, key_length, DATA_SECMEM,
+				slotphys, &black_key_length, DATA_SECMEM,
+				keyauth, UNTRUSTED_KEY);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
+/* Export a black/red key to a blob in external memory */
+static int sm_keystore_slot_export(struct device *ksdev, u32 unit, u32 slot,
+				   u8 keycolor, u8 keyauth,
+				   u8 *outbuf, u16 keylen, u8 *keymod)
+{
+	struct device *jrdev;
+	int retval = 0;
+	u8 __iomem *slotphys;
+	size_t blob_len;
+	size_t keymod_len = KEYMOD_SIZE_SM;
+	u8 blob_color = (keycolor == BLACK_KEY) ? BLACK_BLOB : RED_BLOB;
+
+	if (!ksdev || !outbuf || !keymod)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(ksdev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	blob_len = sm_keystore_get_slot_size(ksdev, unit, slot);
+	if (!blob_len) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_blob_encap(jrdev,
+				 slotphys, keylen, DATA_SECMEM,
+				 keycolor, keylen,
+				 keyauth, UNTRUSTED_KEY,
+				 keymod, &keymod_len, DATA_GENMEM,
+				 outbuf, &blob_len,
+				 DATA_GENMEM, blob_color);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
+/* Import a black/red key from a blob residing in external memory */
+static int sm_keystore_slot_import(struct device *ksdev, u32 unit, u32 slot,
+				   u8 keycolor, u8 keyauth,
+				   u8 *inbuf, u16 keylen, u8 *keymod)
+{
+	struct device *jrdev;
+	int retval = 0;
+	u8 __iomem *slotphys;
+	size_t keymod_len = KEYMOD_SIZE_SM;
+	size_t key_len;
+	size_t secret_size = 0;
+	u8 blob_color = (keycolor == BLACK_KEY) ? BLACK_BLOB : RED_BLOB;
+
+	if (!ksdev || !inbuf || !keymod)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(ksdev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	key_len = sm_keystore_get_slot_size(ksdev, unit, slot);
+	if (!key_len) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_blob_decap(jrdev,
+				 inbuf, keylen + BLOB_OVERHEAD,
+				 DATA_GENMEM, blob_color,
+				 keymod, &keymod_len, DATA_GENMEM,
+				 slotphys, &key_len, DATA_SECMEM,
+				 keycolor, &secret_size,
+				 keyauth, UNTRUSTED_KEY);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
 static void key_display(struct device *dev, u8 *label, u16 size, u8 *key)
 {
-	unsigned i;
+	int i;
 
 	dev_info(dev, label);
 	for (i = 0; i < size; i += 8)
@@ -88,7 +228,7 @@ int caam_sm_example_init(struct platform_device *pdev)
 	struct caam_drv_private *ctrlpriv;
 	struct caam_drv_private_sm *kspriv;
 	u32 unit, units;
-	int rtnval = 0;
+	int rtnval = -EIO;
 	u8 clrkey8[8], clrkey16[16], clrkey24[24], clrkey32[32];
 	u8 blkkey8[AES_BLOCK_PAD(8)], blkkey16[AES_BLOCK_PAD(16)];
 	u8 blkkey24[AES_BLOCK_PAD(24)], blkkey32[AES_BLOCK_PAD(32)];
@@ -208,22 +348,22 @@ int caam_sm_example_init(struct platform_device *pdev)
 	 * Cover keys in-place
 	 */
 	if (sm_keystore_cover_key(ksdev, unit, keyslot8, 8, KEY_COVER_ECB)) {
-		dev_info(ksdev, "blkkey_ex: can't cover 64-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't cover 64-bit key\n");
 		goto dealloc;
 	}
 
 	if (sm_keystore_cover_key(ksdev, unit, keyslot16, 16, KEY_COVER_ECB)) {
-		dev_info(ksdev, "blkkey_ex: can't cover 128-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't cover 128-bit key\n");
 		goto dealloc;
 	}
 
 	if (sm_keystore_cover_key(ksdev, unit, keyslot24, 24, KEY_COVER_ECB)) {
-		dev_info(ksdev, "blkkey_ex: can't cover 192-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't cover 192-bit key\n");
 		goto dealloc;
 	}
 
 	if (sm_keystore_cover_key(ksdev, unit, keyslot32, 32, KEY_COVER_ECB)) {
-		dev_info(ksdev, "blkkey_ex: can't cover 256-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't cover 256-bit key\n");
 		goto dealloc;
 	}
 
@@ -239,46 +379,46 @@ int caam_sm_example_init(struct platform_device *pdev)
 
 	if (sm_keystore_slot_read(ksdev, unit, keyslot8, AES_BLOCK_PAD(8),
 				  blkkey8)) {
-		dev_info(ksdev, "blkkey_ex: can't read 64-bit black key\n");
+		dev_err(ksdev, "blkkey_ex: can't read 64-bit black key\n");
 		goto dealloc;
 	}
 
 	if (sm_keystore_slot_read(ksdev, unit, keyslot16, AES_BLOCK_PAD(16),
 				  blkkey16)) {
-		dev_info(ksdev, "blkkey_ex: can't read 128-bit black key\n");
+		dev_err(ksdev, "blkkey_ex: can't read 128-bit black key\n");
 		goto dealloc;
 	}
 
 	if (sm_keystore_slot_read(ksdev, unit, keyslot24, AES_BLOCK_PAD(24),
 				  blkkey24)) {
-		dev_info(ksdev, "blkkey_ex: can't read 192-bit black key\n");
+		dev_err(ksdev, "blkkey_ex: can't read 192-bit black key\n");
 		goto dealloc;
 	}
 
 	if (sm_keystore_slot_read(ksdev, unit, keyslot32, AES_BLOCK_PAD(32),
 				  blkkey32)) {
-		dev_info(ksdev, "blkkey_ex: can't read 256-bit black key\n");
+		dev_err(ksdev, "blkkey_ex: can't read 256-bit black key\n");
 		goto dealloc;
 	}
 
 
 	if (!memcmp(blkkey8, clrkey8, 8)) {
-		dev_info(ksdev, "blkkey_ex: 64-bit key cover failed\n");
+		dev_err(ksdev, "blkkey_ex: 64-bit key cover failed\n");
 		goto dealloc;
 	}
 
 	if (!memcmp(blkkey16, clrkey16, 16)) {
-		dev_info(ksdev, "blkkey_ex: 128-bit key cover failed\n");
+		dev_err(ksdev, "blkkey_ex: 128-bit key cover failed\n");
 		goto dealloc;
 	}
 
 	if (!memcmp(blkkey24, clrkey24, 24)) {
-		dev_info(ksdev, "blkkey_ex: 192-bit key cover failed\n");
+		dev_err(ksdev, "blkkey_ex: 192-bit key cover failed\n");
 		goto dealloc;
 	}
 
 	if (!memcmp(blkkey32, clrkey32, 32)) {
-		dev_info(ksdev, "blkkey_ex: 256-bit key cover failed\n");
+		dev_err(ksdev, "blkkey_ex: 256-bit key cover failed\n");
 		goto dealloc;
 	}
 
@@ -423,21 +563,22 @@ int caam_sm_example_init(struct platform_device *pdev)
 	 */
 
 	if (memcmp(rstkey16, blkkey16, AES_BLOCK_PAD(16))) {
-		dev_info(ksdev, "blkkey_ex: 128-bit restored key mismatch\n");
-		rtnval--;
+		dev_err(ksdev, "blkkey_ex: 128-bit restored key mismatch\n");
+		goto dealloc;
 	}
 
 	/* Only first AES block will match, remainder subject to padding */
 	if (memcmp(rstkey24, blkkey24, 16)) {
-		dev_info(ksdev, "blkkey_ex: 192-bit restored key mismatch\n");
-		rtnval--;
+		dev_err(ksdev, "blkkey_ex: 192-bit restored key mismatch\n");
+		goto dealloc;
 	}
 
 	if (memcmp(rstkey32, blkkey32, AES_BLOCK_PAD(32))) {
-		dev_info(ksdev, "blkkey_ex: 256-bit restored key mismatch\n");
-		rtnval--;
+		dev_err(ksdev, "blkkey_ex: 256-bit restored key mismatch\n");
+		goto dealloc;
 	}
 
+	rtnval = 0;
 
 	/* Remove keys from keystore */
 dealloc:
@@ -457,6 +598,9 @@ int caam_sm_example_init(struct platform_device *pdev)
 	/* Disconnect from keystore and leave */
 	sm_release_keystore(ksdev, unit);
 
+	if (rtnval)
+		dev_err(ksdev, "Test failed\n");
+
 	return rtnval;
 }
 EXPORT_SYMBOL(caam_sm_example_init);
@@ -483,7 +627,6 @@ void caam_sm_example_shutdown(void)
 		return;
 
 	of_node_get(dev_node);
-
 }
 
 static int __init caam_sm_test_init(void)
@@ -508,9 +651,7 @@ static int __init caam_sm_test_init(void)
 
 	of_node_put(dev_node);
 
-	caam_sm_example_init(pdev);
-
-	return 0;
+	return caam_sm_example_init(pdev);
 }
 
 
diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index c60d29d..287e525 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -35,6 +35,7 @@
 #include <crypto/authenc.h>
 #include <linux/rtnetlink.h> /* for struct rtattr and RTA macros only */
 #include <keys/user-type.h>
+#include <linux/key-type.h>
 
 #include <linux/device-mapper.h>
 
@@ -1337,6 +1338,7 @@ static blk_status_t crypt_convert(struct crypt_config *cc,
 		 * The request was queued by a crypto driver
 		 * but the driver request queue is full, let's wait.
 		 */
+		case -EINPROGRESS:
 		case -EBUSY:
 			wait_for_completion(&ctx->restart);
 			reinit_completion(&ctx->restart);
@@ -1345,7 +1347,7 @@ static blk_status_t crypt_convert(struct crypt_config *cc,
 		 * The request is queued and processed asynchronously,
 		 * completion function kcryptd_async_done() will be called.
 		 */
-		case -EINPROGRESS:
+		//case -EINPROGRESS:
 			ctx->r.req = NULL;
 			ctx->cc_sector += sector_step;
 			tag_offset++;
@@ -1786,15 +1788,8 @@ static void kcryptd_async_done(struct crypto_async_request *async_req,
 	struct dm_crypt_io *io = container_of(ctx, struct dm_crypt_io, ctx);
 	struct crypt_config *cc = io->cc;
 
-	/*
-	 * A request from crypto driver backlog is going to be processed now,
-	 * finish the completion and continue in crypt_convert().
-	 * (Callback will be called for the second time for this request.)
-	 */
-	if (error == -EINPROGRESS) {
-		complete(&ctx->restart);
+	if (error == -EINPROGRESS)
 		return;
-	}
 
 	if (!error && cc->iv_gen_ops && cc->iv_gen_ops->post)
 		error = cc->iv_gen_ops->post(cc, org_iv_of_dmreq(cc, dmreq), dmreq);
@@ -1809,12 +1804,15 @@ static void kcryptd_async_done(struct crypto_async_request *async_req,
 	crypt_free_req(cc, req_of_dmreq(cc, dmreq), io->base_bio);
 
 	if (!atomic_dec_and_test(&ctx->cc_pending))
-		return;
+		goto done;
 
 	if (bio_data_dir(io->base_bio) == READ)
 		kcryptd_crypt_read_done(io);
 	else
 		kcryptd_crypt_write_io_submit(io, 1);
+done:
+	if (!completion_done(&ctx->restart))
+		complete(&ctx->restart);
 }
 
 static void kcryptd_crypt(struct work_struct *work)
@@ -2005,10 +2003,11 @@ static bool contains_whitespace(const char *str)
 
 static int crypt_set_keyring_key(struct crypt_config *cc, const char *key_string)
 {
-	char *new_key_string, *key_desc;
+	char *new_key_string, *key_desc, bkup;
 	int ret;
 	struct key *key;
 	const struct user_key_payload *ukp;
+	struct key_type *type;
 
 	/*
 	 * Reject key_string with whitespace. dm core currently lacks code for
@@ -2024,17 +2023,24 @@ static int crypt_set_keyring_key(struct crypt_config *cc, const char *key_string
 	if (!key_desc || key_desc == key_string || !strlen(key_desc + 1))
 		return -EINVAL;
 
-	if (strncmp(key_string, "logon:", key_desc - key_string + 1) &&
-	    strncmp(key_string, "user:", key_desc - key_string + 1))
-		return -EINVAL;
-
 	new_key_string = kstrdup(key_string, GFP_KERNEL);
 	if (!new_key_string)
 		return -ENOMEM;
 
-	key = request_key(key_string[0] == 'l' ? &key_type_logon : &key_type_user,
-			  key_desc + 1, NULL);
+	/* Shorten new_key_string to key type only */
+	bkup = new_key_string[key_desc - key_string];
+	new_key_string[key_desc - key_string] = '\0';
+
+	type = key_type_lookup(new_key_string);
+	if (!type)
+		return -ENOENT;
+
+	/* Restore full name for key */
+	new_key_string[key_desc - key_string] = bkup;
+
+	key = request_key(type, key_desc + 1, NULL);
 	if (IS_ERR(key)) {
+		key_type_put(type);
 		kzfree(new_key_string);
 		return PTR_ERR(key);
 	}
@@ -2045,6 +2051,7 @@ static int crypt_set_keyring_key(struct crypt_config *cc, const char *key_string
 	if (!ukp) {
 		up_read(&key->sem);
 		key_put(key);
+		key_type_put(type);
 		kzfree(new_key_string);
 		return -EKEYREVOKED;
 	}
@@ -2052,6 +2059,7 @@ static int crypt_set_keyring_key(struct crypt_config *cc, const char *key_string
 	if (cc->key_size != ukp->datalen) {
 		up_read(&key->sem);
 		key_put(key);
+		key_type_put(type);
 		kzfree(new_key_string);
 		return -EINVAL;
 	}
@@ -2060,6 +2068,7 @@ static int crypt_set_keyring_key(struct crypt_config *cc, const char *key_string
 
 	up_read(&key->sem);
 	key_put(key);
+	key_type_put(type);
 
 	/* clear the flag since following operations may invalidate previously valid key */
 	clear_bit(DM_CRYPT_KEY_VALID, &cc->flags);
diff --git a/include/linux/key-type.h b/include/linux/key-type.h
index 9520fc3..92697e6 100644
--- a/include/linux/key-type.h
+++ b/include/linux/key-type.h
@@ -165,6 +165,9 @@ extern struct key_type key_type_keyring;
 extern int register_key_type(struct key_type *ktype);
 extern void unregister_key_type(struct key_type *ktype);
 
+extern struct key_type *key_type_lookup(const char *type);
+extern void key_type_put(struct key_type *ktype);
+
 extern int key_payload_reserve(struct key *key, size_t datalen);
 extern int key_instantiate_and_link(struct key *key,
 				    const void *data,
-- 
2.7.4

