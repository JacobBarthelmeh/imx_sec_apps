From 000ff8cf3c10ed91a51f149a44e3f1225ee0b650 Mon Sep 17 00:00:00 2001
From: Marouene Boubakri <marouene.boubakri@nxp.com>
Date: Wed, 12 Jun 2019 10:30:06 +0200
Subject: [PATCH] caam black key blob feature

---
 arch/arm/configs/imx_v6_v7_defconfig |   8 +
 arch/arm/configs/imx_v7_defconfig    |   4 +
 arch/arm64/configs/defconfig         |   5 +
 drivers/crypto/caam/Kconfig          |  45 +-
 drivers/crypto/caam/Makefile         |   5 +
 drivers/crypto/caam/black_keys.c     | 317 ++++++++++++++
 drivers/crypto/caam/blob.c           | 510 +++++++++++++++++++++
 drivers/crypto/caam/caam.h           |  41 ++
 drivers/crypto/caam/caam_desc.c      | 548 +++++++++++++++++++++++
 drivers/crypto/caam/caam_desc.h      | 117 +++++
 drivers/crypto/caam/caam_util.c      | 233 ++++++++++
 drivers/crypto/caam/caam_util.h      | 130 ++++++
 drivers/crypto/caam/desc.h           |   3 +
 drivers/crypto/caam/jr.c             |  45 ++
 drivers/crypto/caam/key_blob.c       | 829 +++++++++++++++++++++++++++++++++++
 drivers/crypto/caam/key_blob.h       |  40 ++
 drivers/crypto/caam/sm.h             |  35 +-
 drivers/crypto/caam/sm_store.c       | 598 +------------------------
 drivers/crypto/caam/sm_test.c        | 237 ++++++++--
 19 files changed, 3096 insertions(+), 654 deletions(-)
 create mode 100644 drivers/crypto/caam/black_keys.c
 create mode 100644 drivers/crypto/caam/blob.c
 create mode 100644 drivers/crypto/caam/caam.h
 create mode 100644 drivers/crypto/caam/caam_desc.c
 create mode 100644 drivers/crypto/caam/caam_desc.h
 create mode 100644 drivers/crypto/caam/caam_util.c
 create mode 100644 drivers/crypto/caam/caam_util.h
 create mode 100644 drivers/crypto/caam/key_blob.c
 create mode 100644 drivers/crypto/caam/key_blob.h

diff --git a/arch/arm/configs/imx_v6_v7_defconfig b/arch/arm/configs/imx_v6_v7_defconfig
index 32acac9..f13e1b7 100644
--- a/arch/arm/configs/imx_v6_v7_defconfig
+++ b/arch/arm/configs/imx_v6_v7_defconfig
@@ -405,6 +405,14 @@ CONFIG_PROVE_LOCKING=y
 # CONFIG_ARM_UNWIND is not set
 CONFIG_SECURITYFS=y
 CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_DESC=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLOB=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_KEY_BLOB=y
 CONFIG_CRYPTO_DEV_SAHARA=y
 CONFIG_CRC_CCITT=m
 CONFIG_CRC_T10DIF=y
diff --git a/arch/arm/configs/imx_v7_defconfig b/arch/arm/configs/imx_v7_defconfig
index 7842b84..e12c90c 100644
--- a/arch/arm/configs/imx_v7_defconfig
+++ b/arch/arm/configs/imx_v7_defconfig
@@ -451,6 +451,10 @@ CONFIG_CRYPTO_DEV_FSL_CAAM=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_DESC=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLOB=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_KEY_BLOB=y
 CONFIG_CRYPTO_DEV_MXS_DCP=y
 CONFIG_CRC_CCITT=m
 CONFIG_CRC_T10DIF=y
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 211e517..45f6af7 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -809,6 +809,11 @@ CONFIG_CRYPTO_DEV_FSL_CAAM=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_DESC=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLOB=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_KEY_BLOB=y
 CONFIG_ARM64_CRYPTO=y
 CONFIG_CRYPTO_SHA512_ARM64=m
 CONFIG_CRYPTO_SHA1_ARM64_CE=y
diff --git a/drivers/crypto/caam/Kconfig b/drivers/crypto/caam/Kconfig
index 056a745..385185d 100644
--- a/drivers/crypto/caam/Kconfig
+++ b/drivers/crypto/caam/Kconfig
@@ -198,7 +198,7 @@ config CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE

 config CRYPTO_DEV_FSL_CAAM_SM_TEST
 	tristate "CAAM Secure Memory - Keystore Test/Example (EXPERIMENTAL)"
-	depends on CRYPTO_DEV_FSL_CAAM_SM
+	depends on CRYPTO_DEV_FSL_CAAM_SM && CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY && CRYPTO_DEV_FSL_CAAM_UTIL_BLOB
 	default n
 	help
 	  Example thread to exercise the Keystore API and to verify that
@@ -224,3 +224,46 @@ config CRYPTO_DEV_FSL_CAAM_DEBUG
 config CRYPTO_DEV_FSL_CAAM_CRYPTO_API_DESC
 	def_tristate (CRYPTO_DEV_FSL_CAAM_CRYPTO_API || \
 		      CRYPTO_DEV_FSL_CAAM_CRYPTO_API_QI)
+
+
+config CRYPTO_DEV_FSL_CAAM_DESC
+	bool "Add descriptor constructor for common operation"
+	default n
+	help
+	  Selecting this will add generic descriptor constructor. These
+	  descriptor constructor can help to produce a valid descriptor which
+	  can be provided to CAAM. The constructor available are for example:
+	  covering of key, encapsulation and decapsulation of blobs
+
+config CRYPTO_DEV_FSL_CAAM_UTIL
+	def_bool (CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY || \
+		      CRYPTO_DEV_FSL_CAAM_UTIL_BLOB)
+
+config CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY
+	bool "Enable utility function to cover keys"
+	default n
+	depends on CRYPTO_DEV_FSL_CAAM_DESC && CRYPTO_DEV_FSL_CAAM_JR
+	help
+	  Selecting this will add utility functions to easily create red and
+	  black keys using the CAAM and test their loading by the CAAM.
+	  Using these functions reduce the code needed to do these operations.
+	  The utility functions does not handle batch of operations hence are
+	  not optimal for performance.
+
+config CRYPTO_DEV_FSL_CAAM_UTIL_BLOB
+	bool "Enable utility function to create blobs"
+	default n
+	depends on CRYPTO_DEV_FSL_CAAM_DESC && CRYPTO_DEV_FSL_CAAM_JR
+	help
+	  Selecting this will add utility functions to easily encapsulate or
+	  decapsulate red and black blobs.
+	  Using these functions reduce the code needed to do these operations.
+	  The utility functions does not handle batch of operations hence are
+	  not optimal for performance.
+
+config CRYPTO_DEV_FSL_CAAM_KEY_BLOB
+	bool "Enable black key blob encryption/decryption demo"
+	default n
+	depends on CRYPTO_DEV_FSL_CAAM_JR
+	help
+	  Selecting this will add the demo functionality
diff --git a/drivers/crypto/caam/Makefile b/drivers/crypto/caam/Makefile
index fc058f6..4298ae2 100644
--- a/drivers/crypto/caam/Makefile
+++ b/drivers/crypto/caam/Makefile
@@ -18,6 +18,11 @@ obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SM) += sm_store.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST) += sm_test.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO) += secvio.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_ECDSA_API) += caam_ecdsa.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_DESC) += caam_desc.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL) += caam_util.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLACK_KEY) += black_keys.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_UTIL_BLOB) += blob.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_KEY_BLOB) += key_blob.o

 caam-objs := ctrl.o
 caam_jr-objs := jr.o key_gen.o error.o inst_rng.o
diff --git a/drivers/crypto/caam/black_keys.c b/drivers/crypto/caam/black_keys.c
new file mode 100644
index 0000000..ed619cb
--- /dev/null
+++ b/drivers/crypto/caam/black_keys.c
@@ -0,0 +1,317 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Key covering function for CAAM
+ *
+ * Copyright 2018 NXP
+ */
+
+#include "caam.h"
+#include "desc.h"
+#include "caam_desc.h"
+#include "caam_util.h"
+#include "desc_constr.h"
+
+/**
+ * @brief         Cover a key and create a black key
+ *
+ * @details       Details:
+ * - If @b memtype is setted to @b DATA_SECMEM, the key to cover is read
+ *   directly by the CAAM from Secure Memeory without intermediate copy. The
+ *   value of @b key must be a physical address in secure memory.
+ * - The parameter @b black_key_length is used to check the output memory can
+ *   store the covered key and inform the user of the size of the covered key.
+ *
+ * @attention     Limited to class 1 keys at the present time
+ *
+ * @attention     The input and output data are copied to temporary arrays
+ *                except for @b key if @b memtype is @b DATA_SECMEM.
+ *
+ * @param[in]     jrdev              The jrdev
+ * @param[in]     key                The key
+ * @param[in]     key_length         The key length
+ * @param[in]     key_memtype        The memtype
+ * @param[out]    black_key          The black key
+ * @param[in,out] black_key_length   The black key length
+ * @param[in]     black_key_memtype  The black key memtype
+ * @param[in]     keyauth            The keyauth
+ * @param[in]     trusted_key        The trusted key
+ *
+ * @return        0 if no error, otherwise error code
+ */
+int caam_black_key(struct device *jrdev,
+		   const void *key, size_t key_length, u8 key_memtype,
+		   void *black_key, size_t *black_key_length,
+		   u8 black_key_memtype, u8 keyauth, u8 trusted_key)
+{
+	int retval = 0;
+	u32 dsize, jstat;
+	u32 __iomem *coverdesc = NULL;
+	size_t black_key_length_req = 0;
+
+	u8 *temp_key = NULL;
+	caam_dma_addr_t key_dma;
+	u8 *temp_black_key = NULL;
+	caam_dma_addr_t black_key_dma;
+
+	/* Check input */
+	if (!jrdev)
+		return -EINVAL;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s input: [key: %p(%zu) black_key: %p(%zu), auth: %x]",
+		 __func__, key, key_length,
+		 black_key, *black_key_length, keyauth);
+#endif
+
+	/* Trusted key not supported */
+	if (trusted_key == TRUSTED_KEY)
+		return -EINVAL;
+
+	if (!key || !black_key)
+		return -EINVAL;
+
+	if (!is_memory_type(key_memtype) ||
+	    !is_memory_type(black_key_memtype) ||
+	    !is_auth(keyauth) ||
+	    !is_trusted_key(trusted_key))
+		return -EINVAL;
+
+	/* Advanced tests */
+	if (keyauth == KEY_COVER_ECB) {
+		black_key_length_req = ECB_BLACK_KEY_SIZE(key_length);
+		if (*black_key_length < black_key_length_req) {
+			*black_key_length = black_key_length_req;
+			return -EINVAL;
+		}
+	} else if (keyauth == KEY_COVER_CCM) {
+		black_key_length_req = CCM_BLACK_KEY_SIZE(key_length);
+		if (*black_key_length < black_key_length_req) {
+			*black_key_length = black_key_length_req;
+			return -EINVAL;
+		}
+	}
+	*black_key_length = key_length;
+
+	if (black_key_memtype == DATA_SECMEM) {
+		black_key_dma = get_caam_dma_addr(black_key);
+		if (black_key_dma == 0)
+			return -EINVAL;
+	}
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s processing: [key: %p(%zu) black_key: %p(%zu)",
+		 __func__, key, key_length, black_key, *black_key_length);
+	dev_info(jrdev, "req:%zu, auth: 0x%x]", black_key_length_req, keyauth);
+#endif
+
+	if (key_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, key, key_length,
+				       &key_dma, &temp_key)) {
+			dev_err(jrdev, "unable to prepare key: %p\n", key);
+			retval = -ENOMEM;
+			goto exit;
+		}
+	} else {
+		key_dma = get_caam_dma_addr(key);
+		if (key_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (black_key_memtype == DATA_GENMEM) {
+		if (prepare_read_data(jrdev, black_key_length_req,
+				      &black_key_dma, &temp_black_key)) {
+			dev_err(jrdev, "unable to prepare cover key\n");
+			retval = -ENOMEM;
+			goto unprepare_key;
+		}
+	} else {
+		black_key_dma = get_caam_dma_addr(black_key);
+		if (black_key_dma == 0)
+			return -ENOMEM;
+	}
+
+	dsize = cnstr_black_key_jobdesc(&coverdesc, key_dma, key_length,
+					black_key_dma, *black_key_length,
+					keyauth, trusted_key);
+	if (!dsize) {
+		dev_err(jrdev, "failed to construct the cover descriptor:\n");
+		retval = -ENOMEM;
+		goto unprepare_black_key;
+	}
+
+	jstat = jr_run_job_and_wait_completion(jrdev, coverdesc);
+	if (jstat) {
+		dev_err(jrdev, "Covering job failed\n");
+		retval = -EIO;
+		goto free_desc;
+	}
+
+	if (black_key_memtype == DATA_GENMEM) {
+		read_data_prepared(jrdev, black_key, black_key_dma,
+				   temp_black_key, black_key_length_req);
+	}
+
+	/* Update with correct size */
+	*black_key_length = black_key_length_req;
+
+free_desc:
+	kfree(coverdesc);
+
+unprepare_black_key:
+	if (black_key_memtype == DATA_GENMEM)
+		unprepare_read_data(jrdev, black_key_dma, temp_black_key,
+				    black_key_length_req);
+
+unprepare_key:
+	if (key_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, key_dma, temp_key, key_length);
+
+exit:
+	return retval;
+}
+EXPORT_SYMBOL(caam_black_key);
+
+int caam_random_black_key(struct device *jrdev,
+			  size_t key_length,
+			  void *black_key, size_t *black_key_length,
+			  u8 black_key_memtype, u8 keyauth, u8 trusted_key)
+{
+	int retval = 0;
+	u32 jstat;
+	u32 __iomem *coverdesc = NULL;
+	size_t black_key_length_req = 0;
+
+	u8 *temp_black_key = NULL;
+	caam_dma_addr_t black_key_dma;
+
+	/* Check job ring */
+	if (!jrdev)
+		return -EINVAL;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s input: [key: (%zu) black_key: %p(%zu), auth: %x]",
+		 __func__, key_length,
+		 black_key, *black_key_length, keyauth);
+#endif
+
+	/* Advanced tests */
+	if (keyauth == KEY_COVER_ECB)
+		black_key_length_req = ECB_BLACK_KEY_SIZE(key_length);
+	else if (keyauth == KEY_COVER_CCM)
+		black_key_length_req = CCM_BLACK_KEY_SIZE(key_length);
+
+	if (*black_key_length < black_key_length_req) {
+		*black_key_length = black_key_length_req;
+		return -EINVAL;
+	}
+	*black_key_length = key_length;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s processing: [key: (%zu) black_key: %p(%zu)",
+		 __func__, key_length, black_key, *black_key_length);
+	dev_info(jrdev, "req:%zu, auth: 0x%x]", black_key_length_req, keyauth);
+#endif
+
+	if (prepare_read_data(jrdev, black_key_length_req,
+			      &black_key_dma, &temp_black_key)) {
+		dev_err(jrdev, "unable to prepare covered random key\n");
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	retval = cnstr_random_black_key_jobdesc(&coverdesc, key_length,
+						black_key_dma,
+						*black_key_length,
+						keyauth, trusted_key);
+	if (retval) {
+		dev_err(jrdev,
+			"failed to construct the cover random descriptor\n");
+		goto unprepare_black_key;
+	}
+
+	jstat = jr_run_job_and_wait_completion(jrdev, coverdesc);
+	if (jstat) {
+		dev_err(jrdev, "Covering random job failed\n");
+		retval = -EIO;
+		goto free_desc;
+	}
+
+	read_data_prepared(jrdev, black_key, black_key_dma,
+			   temp_black_key, black_key_length_req);
+
+	*black_key_length = black_key_length_req;
+
+	retval = 0;
+
+free_desc:
+	kfree(coverdesc);
+
+unprepare_black_key:
+	unprepare_read_data(jrdev, black_key_dma, temp_black_key,
+			    black_key_length_req);
+
+exit:
+	return retval;
+}
+EXPORT_SYMBOL(caam_random_black_key);
+
+/* Test of black key generation depending on secret size */
+
+#include <linux/module.h>
+
+#define MAX_INPUT_SIZE 64
+
+static char input[MAX_INPUT_SIZE];
+static char output[MAX_INPUT_SIZE + CCM_OVERHEAD];
+
+int create_black_key_size_n(struct device *jrdev, size_t n, u8 auth)
+{
+	int ret;
+	size_t output_size = sizeof(output);
+
+	ret = caam_black_key(jrdev,
+			     input, n, DATA_GENMEM,
+			     output, &output_size,
+			     DATA_GENMEM, auth, UNTRUSTED_KEY);
+	if (ret)
+		pr_err("Creation of black key size: %zd, auth: %d -> %d",
+		       n, auth, ret);
+
+	return (ret) ? 1 : 0;
+}
+
+int bk_test(void)
+{
+	int nb_errors = 0;
+	int i;
+	struct device *jrdev;
+
+	jrdev = caam_jr_alloc();
+	if (!jrdev)
+		return -ENOMEM;
+
+	for (i = 1; i <= MAX_INPUT_SIZE; i++) {
+		pr_info("Size %d\n", i);
+		nb_errors += create_black_key_size_n(jrdev, i, KEY_COVER_ECB);
+		nb_errors += create_black_key_size_n(jrdev, i, KEY_COVER_CCM);
+	}
+
+	pr_info("Nb errors: %d\n", nb_errors);
+
+	return nb_errors;
+}
+
+int bk_init(void)
+{
+#ifdef DEBUG
+	return bk_test();
+#endif
+	return 0;
+}
+
+void bk_exit(void)
+{
+}
+
+module_init(bk_init)
+module_exit(bk_exit)
diff --git a/drivers/crypto/caam/blob.c b/drivers/crypto/caam/blob.c
new file mode 100644
index 0000000..8994dc8
--- /dev/null
+++ b/drivers/crypto/caam/blob.c
@@ -0,0 +1,510 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Blob encapsulation/decapsulation functions for CAAM
+ *
+ * Copyright 2018 NXP
+ */
+
+#include "caam.h"
+#include "desc.h"
+#include "caam_desc.h"
+#include "caam_util.h"
+
+/**
+ * @brief         Perform the encapsulation of a secret in a blob
+ *
+ * @details       Details:
+ * - If @b memtype is setted to @b DATA_SECMEM, the secret to encapsulate is
+ *   read directly by the CAAM from Secure Memeory without intermediate copy.
+ *   The value of @b secret must be a physical address in secure memory.
+ *
+ * - The parameter @b keymod_length is used to check the size of the key
+ *   modifier is long enough, else the function will fail with the appropriate
+ *   size set.
+ *
+ * - The parameter @b blob_length is used to check the size of the output for
+ *   the blob is long enough, else the function will fail with the appropriate
+ *   size set.
+ *
+ * - The parameter @b key_length_in_secret is used to indicate the real size of
+ *   the key to encapsulate in the case it is a black key.
+ *
+ * @attention     The input and output data are copied to temporary arrays
+ *                except for @b secret if @b memtype is @b DATA_SECMEM.
+ *
+ * @param[in]     jrdev                 The jrdev
+ * @param[in]     secret                The secret
+ * @param[in]     secret_length         The secret length
+ * @param[in]     secret_memtype        The secret memtype
+ * @param[in]     keycolor              The keycolor
+ * @param[in]     key_length_in_secret  The key length in secret, if the secret
+ *                                      to encapsulate is a covered key (black
+ *                                      key), the original size of the key must
+ *                                      be provided.
+ * @param[in]     auth                  The auth
+ * @param[in]     trusted_key           The trusted key
+ * @param[in]     keymod                The keymod
+ * @param[in,out] keymod_length         The keymod length
+ * @param[in]     keymod_memtype        The keymod memtype
+ * @param[out]    blob                  The blob
+ * @param[in,out] blob_length           The blob length
+ * @param[in]     blob_memtype          The memtype
+ * @param[in]     blobcolor             The blobcolor
+ *
+ * @return        0 if no error, otherwise error code
+ */
+int caam_blob_encap(struct device *jrdev,
+		    const void  *secret, size_t secret_length,
+		    u8 secret_memtype,
+		    u8 keycolor, size_t key_length_in_secret,
+		    u8 auth, u8 trusted_key,
+		    const void *keymod, size_t *keymod_length,
+		    u8 keymod_memtype,
+		    void *blob, size_t *blob_length,
+		    u8 blob_memtype, u8 blobcolor)
+{
+	int retval = 0;
+	u32 dsize, jstat;
+	u32 __iomem *blob_encap = NULL;
+	size_t secret_length_for_cnstr = 0;
+
+	u8 *temp_secret = NULL;
+	caam_dma_addr_t secret_dma;
+	u8 *temp_keymod = NULL;
+	caam_dma_addr_t keymod_dma;
+	u8 *temp_blob = NULL;
+	caam_dma_addr_t blob_dma;
+
+	/*
+	 * basic checks
+	 */
+
+	/* Check job ring */
+	if (!jrdev)
+		return -EINVAL;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s input:[secret: %p(%zu) color:%x auth:%x, memtype:%x",
+		 __func__, secret, secret_length, keycolor, auth,
+		 secret_memtype);
+	dev_info(jrdev, ", keymod: %p(%zu), memtype:%x",
+		 keymod, *keymod_length, keymod_memtype);
+	dev_info(jrdev, "blob: %p(%zu), memtype:%x color: %x]",
+		 blob, *blob_length, blob_memtype, blobcolor);
+#endif
+
+	/* Check input buffers */
+	if (!secret || !keymod || !blob)
+		return -EINVAL;
+
+	/* Check values */
+	if (!is_memory_type(secret_memtype) ||
+	    !is_key_color(keycolor) ||
+	    !is_memory_type(keymod_memtype) ||
+	    !is_memory_type(blob_memtype) ||
+	    !is_blob_color(blobcolor))
+		return -EINVAL;
+
+	if (keycolor == BLACK_KEY) {
+		if (!is_auth(auth) || !is_trusted_key(trusted_key))
+			return -EINVAL;
+
+		/* Trusted key not supported */
+		if (trusted_key == TRUSTED_KEY)
+			return -EINVAL;
+	} else {
+		auth = KEY_COVER_ECB; // No value for auth for red keys
+	}
+
+	/*
+	 * Advanced checks
+	 */
+
+	/* Check the keymod is long enough */
+	if (secret_memtype == DATA_SECMEM) {
+		if (*keymod_length < KEYMOD_SIZE_SM) {
+			*keymod_length = KEYMOD_SIZE_SM;
+			return -EINVAL;
+		}
+		*keymod_length = KEYMOD_SIZE_SM;
+	} else {
+		if (*keymod_length < KEYMOD_SIZE_GM) {
+			*keymod_length = KEYMOD_SIZE_GM;
+			return -EINVAL;
+		}
+		*keymod_length = KEYMOD_SIZE_GM;
+	}
+
+	/* A black key cannot be stored in a red blob */
+	if (keycolor == BLACK_KEY && blobcolor == RED_BLOB)
+		return -EINVAL;
+
+	/* A red key can only be put in a black blob if it comes from secure
+	 * memory
+	 */
+	if (keycolor == RED_KEY && blobcolor == BLACK_BLOB)
+		if (secret_memtype != DATA_SECMEM)
+			return -EINVAL;
+
+	/* adapt the size of the black key */
+	secret_length_for_cnstr = secret_length;
+	if (keycolor == BLACK_KEY)
+		secret_length_for_cnstr = key_length_in_secret;
+
+	/* Check the blob can be stored */
+	if ((secret_length_for_cnstr + BLOB_OVERHEAD) > *blob_length) {
+		*blob_length = (secret_length_for_cnstr + BLOB_OVERHEAD);
+		return -EINVAL;
+	}
+	*blob_length = secret_length_for_cnstr + BLOB_OVERHEAD;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s processing: [secret: %p(%zu) cnstr:%zu",
+		 __func__,
+		 secret, secret_length, secret_length_for_cnstr);
+	dev_info(jrdev, " color:%x auth:%x, memtype:%x,",
+		 keycolor, auth, secret_memtype);
+	dev_info(jrdev, ", keymod: %p(%zu), memtype:%x",
+		 keymod, *keymod_length, keymod_memtype);
+	dev_info(jrdev, "blob: %p(%zu), memtype:%x color: %x]",
+		 blob, *blob_length, blob_memtype, blobcolor);
+#endif
+
+	if (secret_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, secret, secret_length,
+				       &secret_dma, &temp_secret)) {
+			dev_err(jrdev, "unable to prepare secret: %p\n",
+				secret);
+			retval = -ENOMEM;
+			goto exit;
+		}
+	} else {
+		secret_dma = get_caam_dma_addr(secret);
+		if (secret_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (keymod_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, keymod, *keymod_length,
+				       &keymod_dma, &temp_keymod)) {
+			dev_err(jrdev, "unable to prepare keymod: %p\n",
+				keymod);
+			retval = -ENOMEM;
+			goto unprepare_secret;
+		}
+	} else {
+		keymod_dma = get_caam_dma_addr(secret);
+		if (secret_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (blob_memtype == DATA_GENMEM) {
+		if (prepare_read_data(jrdev, *blob_length, &blob_dma,
+				      &temp_blob)) {
+			dev_err(jrdev, "unable to prepare blob\n");
+			retval = -ENOMEM;
+			goto unprepare_keymod;
+		}
+	} else {
+		blob_dma = get_caam_dma_addr(secret);
+		if (secret_dma == 0)
+			return -ENOMEM;
+	}
+
+	dsize = cnstr_blob_encap_jobdesc(&blob_encap,
+					 secret_dma, secret_length_for_cnstr,
+					 keycolor, auth, trusted_key,
+					 secret_memtype,
+					 keymod_dma, *keymod_length,
+					 blob_dma, *blob_length, blobcolor);
+	if (!dsize) {
+		dev_err(jrdev, "failed to construct the encap descriptor:\n");
+		retval = -ENOMEM;
+		goto unprepare_blob;
+	}
+
+	jstat = jr_run_job_and_wait_completion(jrdev, blob_encap);
+	if (jstat) {
+		dev_err(jrdev, "Encapsulation job failed\n");
+		retval = -EIO;
+		goto free_desc;
+	}
+
+	if (blob_memtype == DATA_GENMEM)
+		read_data_prepared(jrdev, blob, blob_dma, temp_blob,
+				   *blob_length);
+
+free_desc:
+	kfree(blob_encap);
+
+unprepare_blob:
+	if (blob_memtype == DATA_GENMEM)
+		unprepare_read_data(jrdev, blob_dma, temp_blob, *blob_length);
+
+unprepare_keymod:
+	if (keymod_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, keymod_dma, temp_keymod,
+				     *keymod_length);
+
+unprepare_secret:
+	if (secret_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, secret_dma, temp_secret,
+				     secret_length);
+
+exit:
+	return retval;
+}
+EXPORT_SYMBOL(caam_blob_encap);
+
+/**
+ * @brief         Perform the decapsulation of a secret from a blob
+ *
+ * @details       Details:
+ * - If @b memtype is setted to @b DATA_SECMEM, the secret to decapsulate is
+ *   written directly by the CAAM to Secure Memeory without intermediate copy.
+ *   The value of @b secret must be a physical address in secure memory.
+ *
+ * - If @b memtype is setted to @b DATA_SECMEM, it is possible to retrieve data
+ *   or key from a black blob without the output to be covered.
+ *
+ * - The parameter @b keymod_length is used to check the size of the key
+ *   modifier is long enough, else the function will fail with the appropriate
+ *   size set.
+ *
+ * - The parameter @b secret_length is used to check the size of the output
+ *   memory is long enough, else the function will fail with the appropriate
+ *   size set.
+ *
+ * - The parameter @b key_length_in_secret is used to indicate the user of the
+ *   real size of the data encapsulated in the blob which is useful in case of
+ *   decapsulation of black keys.
+ *
+ * @attention     The input and output data are copied to temporary arrays
+ *                except for @b secret if @b memtype is @b DATA_SECMEM.
+ *
+ * @param[in]     jrdev                 The jrdev
+ * @param[in]     blob                  The blob
+ * @param[in]     blob_length           The blob length
+ * @param[in]     blob_memtype          The memtype
+ * @param[in]     blobcolor             The blobcolor
+ * @param[in]     keymod                The keymod
+ * @param[in,out] keymod_length         The keymod length
+ * @param[in]     keymod_memtype        The keymod memtype
+ * @param[in]     secret                The secret
+ * @param[in,out] secret_length         The secret length
+ * @param[in]     secret_memtype        The secret memtype
+ * @param[in]     keycolor              The keycolor
+ * @param[out]    key_length_in_secret  The key length in secret
+ * @param[in]     auth                  The auth
+ * @param[in]     trusted_key           The trusted key
+ *
+ * @return        0 if no error, otherwise error code
+ */
+int caam_blob_decap(struct device *jrdev,
+		    const void *blob, size_t blob_length, u8 blob_memtype,
+		    u8 blobcolor,
+		    const void *keymod, size_t *keymod_length,
+		    u8 keymod_memtype,
+		    void *secret, size_t *secret_length, u8 secret_memtype,
+		    u8 keycolor, size_t *key_length_in_secret,
+		    u8 auth, u8 trusted_key)
+{
+	int retval = 0;
+	u32 dsize, jstat;
+	u32 __iomem *blob_decap = NULL;
+	size_t secret_length_for_cnstr;
+	size_t secret_length_req;
+
+	u8 *temp_secret = NULL;
+	caam_dma_addr_t secret_dma;
+	u8 *temp_keymod = NULL;
+	caam_dma_addr_t keymod_dma;
+	u8 *temp_blob = NULL;
+	caam_dma_addr_t blob_dma;
+
+	/*
+	 * basic checks
+	 */
+
+	/* Check job ring */
+	if (!jrdev)
+		return -EINVAL;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s input: [blob: %p(%zu), memtype:%x ,blob color: %x",
+		 __func__,
+		 blob, blob_length, blob_memtype, blobcolor);
+	dev_info(jrdev, " keymod: %p(%zu), memtype:%x",
+		 keymod, *keymod_length, keymod_memtype);
+	dev_info(jrdev, " secret: %p(%zu) color:%x auth:%x, memtype:%x]",
+		 secret, *secret_length, keycolor, auth, secret_memtype);
+#endif
+
+	/* Check input buffers */
+	if (!secret || !keymod || !blob)
+		return -EINVAL;
+
+	/* Check values */
+	if (!is_key_color(keycolor) ||
+	    !is_memory_type(blob_memtype) ||
+	    !is_blob_color(blobcolor) ||
+	    !is_memory_type(keymod_memtype) ||
+	    !is_memory_type(secret_memtype))
+		return -EINVAL;
+
+	if (keycolor == BLACK_KEY) {
+		if (!is_auth(auth) || !is_trusted_key(trusted_key))
+			return -EINVAL;
+
+		/* Trusted key not supported */
+		if (trusted_key == TRUSTED_KEY)
+			return -EINVAL;
+	} else {
+		auth = KEY_COVER_ECB; // No value for auth for red keys
+	}
+
+	/*
+	 * Advanced checks
+	 */
+
+	/* Check keymod size depending on memory type */
+	if (secret_memtype == DATA_SECMEM) {
+		if (*keymod_length < KEYMOD_SIZE_SM) {
+			*keymod_length = KEYMOD_SIZE_SM;
+			return -EINVAL;
+		}
+		*keymod_length = KEYMOD_SIZE_SM;
+	} else {
+		if (*keymod_length < KEYMOD_SIZE_GM) {
+			*keymod_length = KEYMOD_SIZE_GM;
+			return -EINVAL;
+		}
+		*keymod_length = KEYMOD_SIZE_GM;
+	}
+
+	/* Check the user want a black key if it is a black blob */
+	if (blobcolor != BLACK_BLOB && keycolor == BLACK_KEY)
+		return -EINVAL;
+
+	/* Check the blob is valid */
+	if (blob_length <= BLOB_OVERHEAD)
+		return -EINVAL;
+
+	*key_length_in_secret = blob_length - BLOB_OVERHEAD;
+	secret_length_req = *key_length_in_secret;
+	secret_length_for_cnstr = *key_length_in_secret;
+
+	/* Compute the size of of the output array required to stock the
+	 * secret
+	 */
+	if (keycolor == BLACK_KEY) {
+		if (auth == KEY_COVER_CCM)
+			secret_length_req =
+					CCM_BLACK_KEY_SIZE(secret_length_req);
+		else
+			secret_length_req =
+					ECB_BLACK_KEY_SIZE(secret_length_req);
+	}
+
+	/* Chech the secret can be stored */
+	if (*secret_length < secret_length_req) {
+		*secret_length = secret_length_req;
+		return -EINVAL;
+	}
+	*secret_length = secret_length_req;
+
+#ifdef DEBUG
+	dev_info(jrdev, "%s processing: [blob: %p(%zu), memtype:%x ,blob color: %x,",
+		 __func__,
+		 blob, blob_length, blob_memtype, blobcolor);
+	dev_info(jrdev, " keymod: %p(%zu), memtype:%x, secret: %p(%zu) cnstr:%zu",
+		 keymod, *keymod_length, keymod_memtype,
+		 secret, *secret_length, secret_length_for_cnstr);
+	dev_info(jrdev, " color:%x auth:%x, memtype:%x]",
+		 keycolor, auth, secret_memtype);
+#endif
+
+	if (blob_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, blob, blob_length,
+				       &blob_dma, &temp_blob)) {
+			dev_err(jrdev, "unable to prepare blob: %p\n", blob);
+			retval = -ENOMEM;
+			goto exit;
+		}
+	} else {
+		blob_dma = get_caam_dma_addr(blob);
+		if (blob_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (keymod_memtype == DATA_GENMEM) {
+		if (prepare_write_data(jrdev, keymod, *keymod_length,
+				       &keymod_dma, &temp_keymod)) {
+			dev_err(jrdev, "unable to prepare keymod: %p\n",
+				keymod);
+			retval = -ENOMEM;
+			goto unprepare_blob;
+		}
+	} else {
+		keymod_dma = get_caam_dma_addr(keymod);
+		if (keymod_dma == 0)
+			return -ENOMEM;
+	}
+
+	if (secret_memtype == DATA_GENMEM) {
+		if (prepare_read_data(jrdev, *secret_length,
+				      &secret_dma, &temp_secret)) {
+			dev_err(jrdev, "unable to prepare secret\n");
+			retval = -ENOMEM;
+			goto unprepare_keymod;
+		}
+	} else {
+		secret_dma = get_caam_dma_addr(secret);
+		if (secret_dma == 0)
+			return -ENOMEM;
+	}
+
+	dsize = cnstr_blob_decap_jobdesc(&blob_decap,
+					 blob_dma, blob_length, blobcolor,
+					 keymod_dma, *keymod_length,
+					 secret_dma, secret_length_for_cnstr,
+					 keycolor, auth, trusted_key,
+					 secret_memtype);
+	if (!dsize) {
+		dev_err(jrdev, "failed to construct the encap descriptor:\n");
+		retval = -ENOMEM;
+		goto unprepare_secret;
+	}
+
+	jstat = jr_run_job_and_wait_completion(jrdev, blob_decap);
+	if (jstat) {
+		dev_err(jrdev, "Decapsulation job failed\n");
+		retval = -EIO;
+		goto free_desc;
+	}
+
+	if (secret_memtype == DATA_GENMEM)
+		read_data_prepared(jrdev, secret, secret_dma, temp_secret,
+				   *secret_length);
+
+free_desc:
+	kfree(blob_decap);
+
+unprepare_secret:
+	if (secret_memtype == DATA_GENMEM)
+		unprepare_read_data(jrdev, secret_dma, temp_secret,
+				    *secret_length);
+
+unprepare_keymod:
+	if (keymod_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, keymod_dma, temp_keymod,
+				     *keymod_length);
+
+unprepare_blob:
+	if (blob_memtype == DATA_GENMEM)
+		unprepare_write_data(jrdev, blob_dma, temp_blob, blob_length);
+
+exit:
+	return retval;
+}
+EXPORT_SYMBOL(caam_blob_decap);
diff --git a/drivers/crypto/caam/caam.h b/drivers/crypto/caam/caam.h
new file mode 100644
index 0000000..e2e56c0
--- /dev/null
+++ b/drivers/crypto/caam/caam.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2018 NXP
+ */
+
+#ifndef _CAAM_H_
+#define _CAAM_H_
+
+#include <linux/types.h>
+
+/* Retrieve a reference on a CAAM JR */
+struct device *caam_jr_alloc(void);
+
+/* Release a reference on a CAAM JR */
+void caam_jr_free(struct device *jrdev);
+
+/* Enqueue a job to be processed
+ *
+ * The function cbk will be called when the job is completed with:
+ *  - jrdev the device used for enqueing
+ *  - desc the descriptor processed
+ *  - status the status of the processing: 0 if completed with no error,
+ *    another value if there was an error. The error can be decoded with
+ *    caam_jr_strstatus
+ *  - areq pointer on user specific data
+ */
+int caam_jr_enqueue(struct device *jrdev, u32 *desc,
+		    void (*cbk)(struct device *jrdev, u32 *desc,
+				u32 status, void *areq),
+		    void *areq);
+
+/* Print a description of status
+ * status is the error code passed to the callback when enqueing a job with
+ * caam_jr_enqueue
+ */
+void caam_jr_strstatus(struct device *jrdev, u32 status);
+
+/* Enqueue a job and wait for its completion */
+int jr_run_job_and_wait_completion(struct device *jrdev, u32 *jobdesc);
+
+#endif /* _CAAM_H_ */
diff --git a/drivers/crypto/caam/caam_desc.c b/drivers/crypto/caam/caam_desc.c
new file mode 100644
index 0000000..efae678
--- /dev/null
+++ b/drivers/crypto/caam/caam_desc.c
@@ -0,0 +1,548 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Descriptors for CAAM:
+ *  - red/black key
+ *  - encapsulation/decapsulation in blob
+ *
+ * Copyright 2018 NXP
+ */
+
+#include "caam.h"
+#include "desc.h"
+#include "caam_desc.h"
+#include "desc_constr.h"
+
+#define INITIAL_DESCSZ 16	/* size of tmp buffer for descriptor const. */
+
+/*
+ * Construct a black key conversion job descriptor
+ *
+ * This function constructs a job descriptor capable of performing
+ * a key blackening operation on a plaintext secure memory resident object.
+ *
+ * - desc	pointer to a pointer to the descriptor generated by this
+ *		function. Caller will be responsible to kfree() this
+ *		descriptor after execution.
+ * - key	physical pointer to the plaintext, which will also hold
+ *		the result. Since encryption occurs in place, caller must
+ *              ensure that the space is large enough to accommodate the
+ *              blackened key
+ * - keysz	size of the plaintext
+ * - auth	if a CCM-covered key is required, use KEY_COVER_CCM, else
+ *		use KEY_COVER_ECB.
+ *
+ * Cleanup: The descriptor must be freed
+ */
+int cnstr_black_key_jobdesc(u32 **desc, caam_dma_addr_t key, size_t key_length,
+			    caam_dma_addr_t cover_key, size_t cover_key_length,
+			    u8 auth, u8 trusted_key)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize, idx;
+	u32 key_length_for_desc = key_length;
+
+	/* Trusted key not supported */
+	if (trusted_key != UNTRUSTED_KEY)
+		return 0;
+
+	memset(tmpdesc, 0, ARRAY_SIZE(tmpdesc) * sizeof(u32));
+	idx = 1;
+
+	/*
+	 * KEY commands seems limited to 32 bytes, so we should use the load
+	 * command instead which can load up to 64 bytes.
+	 * The size must also be loaded.
+	 *
+	 * TODO: The KEY command indicate it should be able to load key bigger
+	 * than 32bytes but it doesn't work in practice
+	 *
+	 * TODO: The LOAD command indicate it should be able to load up to 96
+	 * byte keys it doesn't work in practice ans is limited to 64 bytes
+	 */
+
+	/* Load key to class 1 key register */
+	tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_1_CCB | LDST_SRCDST_BYTE_KEY |
+			 key_length_for_desc;
+	tmpdesc[idx++] = (uintptr_t)key;
+	/* Load the size of the key */
+	tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_1_CCB | LDST_IMM |
+			 LDST_SRCDST_WORD_KEYSZ_REG |
+			 sizeof(key_length_for_desc);
+	tmpdesc[idx++] = key_length_for_desc;
+
+	/* ...and write back out via FIFO store*/
+	tmpdesc[idx] = CMD_FIFO_STORE | CLASS_1 |
+		       (cover_key_length & KEY_LENGTH_MASK);
+
+	/* plus account for ECB/CCM option in FIFO_STORE */
+	if (auth == KEY_COVER_ECB)
+		tmpdesc[idx] |= FIFOST_TYPE_KEY_KEK;
+	else
+		tmpdesc[idx] |= FIFOST_TYPE_KEY_CCM_JKEK;
+
+	idx++;
+	tmpdesc[idx++] = (uintptr_t)cover_key;
+
+	/* finish off the job header */
+	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
+	dsize = idx * sizeof(u32);
+
+	/* now allocate execution buffer and coat it with executable */
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "cover desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return dsize;
+}
+EXPORT_SYMBOL(cnstr_black_key_jobdesc);
+
+/*
+ * Construct a black key using RNG job descriptor
+ *
+ * This function constructs a job descriptor capable of performing
+ * a key blackening operation on RNG generated.
+ *
+ * - desc	pointer to a pointer to the descriptor generated by this
+ *		function. Caller will be responsible to kfree() this
+ *		descriptor after execution.
+ * - key	physical pointer to the plaintext, which will also hold
+ *		the result. Since encryption occurs in place, caller must
+ *              ensure that the space is large enough to accommodate the
+ *              blackened key
+ * - keysz	size of the plaintext
+ * - auth	if a CCM-covered key is required, use KEY_COVER_CCM, else
+ *		use KEY_COVER_ECB.
+ *
+ * Cleanup: The descriptor must be freed
+ */
+int cnstr_random_black_key_jobdesc(u32 **desc,
+				   size_t key_length,
+				   caam_dma_addr_t cover_key,
+				   size_t cover_key_length,
+				   u8 auth, u8 trusted_key)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize;
+	u32 bk_store;
+
+	memset(tmpdesc, 0, ARRAY_SIZE(tmpdesc) * sizeof(u32));
+
+	init_job_desc(tmpdesc, CMD_DESC_HDR);
+
+	/* Prepare RNG */
+	append_operation(tmpdesc, OP_ALG_ALGSEL_RNG | OP_TYPE_CLASS1_ALG);
+
+	/* Generate RNG and left it in output data fifo */
+	append_cmd(tmpdesc, CMD_FIFO_STORE | FIFOST_TYPE_RNGFIFO | key_length);
+
+	/* Copy RNG from outfifo to class 1 Key register */
+	append_move(tmpdesc, MOVE_SRC_OUTFIFO | MOVE_DEST_CLASS1KEY |
+			MOVE_WAITCOMP | (key_length & MOVE_LEN_MASK));
+
+	/* Write the size of the key moved */
+	append_load_imm_u32(tmpdesc, key_length, LDST_CLASS_1_CCB |
+			    LDST_SRCDST_WORD_KEYSZ_REG | LDST_IMM);
+
+	bk_store = CLASS_1;
+	if (auth == KEY_COVER_ECB)
+		bk_store |= FIFOST_TYPE_KEY_KEK;
+	else
+		bk_store |= FIFOST_TYPE_KEY_CCM_JKEK;
+
+	/* Fifo store to save the key as black key in memory */
+	append_fifo_store(tmpdesc, cover_key, cover_key_length, bk_store);
+
+	dsize = desc_bytes(&tmpdesc);
+
+	/* now allocate execution buffer and coat it with executable */
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return -ENOMEM;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "cover random desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_random_black_key_jobdesc);
+
+/*
+ * Construct a blob encapsulation job descriptor
+ *
+ * This function dynamically constructs a blob encapsulation job descriptor
+ * from the following arguments:
+ *
+ * - desc	pointer to a pointer to the descriptor generated by this
+ *		function. Caller will be responsible to kfree() this
+ *		descriptor after execution.
+ * - keymod	Physical pointer to a key modifier, which must reside in a
+ *		contiguous piece of memory. Modifier will be assumed to be
+ *		8 bytes long for a blob of type DATA_SECMEM, or 16 bytes long
+ *		for a blob of type DATA_GENMEM (see blobcolor argument).
+ * - secretbuf	Physical pointer to a secret, normally a black or red key,
+ *		possibly residing within an accessible secure memory page,
+ *		of the secret to be encapsulated to an output blob.
+ * - outbuf	Physical pointer to the destination buffer to receive the
+ *		encapsulated output. This buffer will need to be 48 bytes
+ *		larger than the input because of the added encapsulation data.
+ *		The generated descriptor will account for the increase in size,
+ *		but the caller must also account for this increase in the
+ *		buffer allocator.
+ * - secretsz	Size of input secret, in bytes. This is limited to 65536
+ *		less the size of blob overhead, since the length embeds into
+ *		DECO pointer in/out instructions.
+ * - keycolor   Determines if the source data is covered (black key) or
+ *		plaintext (red key). RED_KEY or BLACK_KEY are defined in
+ *		for this purpose.
+ * - blobcolor	Determine if encapsulated blob should be a secure memory
+ *		blob (DATA_SECMEM), with partition data embedded with key
+ *		material, or a general memory blob (DATA_GENMEM).
+ * - auth	If BLACK_KEY source is covered via AES-CCM, specify
+ *		KEY_COVER_CCM, else uses AES-ECB (KEY_COVER_ECB).
+ *
+ * Upon completion, desc points to a buffer containing a CAAM job
+ * descriptor which encapsulates data into an externally-storable blob
+ * suitable for use across power cycles.
+ *
+ * This is an example of a black key encapsulation job into a general memory
+ * blob. Notice the 16-byte key modifier in the LOAD instruction. Also note
+ * the output 48 bytes longer than the input:
+ *
+ * [00] B0800008       jobhdr: stidx=0 len=8
+ * [01] 14400010           ld: ccb2-key len=16 offs=0
+ * [02] 08144891               ptr->@0x08144891
+ * [03] F800003A    seqoutptr: len=58
+ * [04] 01000000               out_ptr->@0x01000000
+ * [05] F000000A     seqinptr: len=10
+ * [06] 09745090               in_ptr->@0x09745090
+ * [07] 870D0004    operation: encap blob  reg=memory, black, format=normal
+ *
+ * This is an example of a red key encapsulation job for storing a red key
+ * into a secure memory blob. Note the 8 byte modifier on the 12 byte offset
+ * in the LOAD instruction; this accounts for blob permission storage:
+ *
+ * [00] B0800008       jobhdr: stidx=0 len=8
+ * [01] 14400C08           ld: ccb2-key len=8 offs=12
+ * [02] 087D0784               ptr->@0x087d0784
+ * [03] F8000050    seqoutptr: len=80
+ * [04] 09251BB2               out_ptr->@0x09251bb2
+ * [05] F0000020     seqinptr: len=32
+ * [06] 40000F31               in_ptr->@0x40000f31
+ * [07] 870D0008    operation: encap blob  reg=memory, red, sec_mem,
+ *                             format=normal
+ *
+ * Note: this function only generates 32-bit pointers at present, and should
+ * be refactored using a scheme that allows both 32 and 64 bit addressing
+ */
+int cnstr_blob_encap_jobdesc(u32 **desc,
+			     caam_dma_addr_t secret, size_t secret_length,
+			     u8 keycolor, u8 auth, u8 trusted_key,
+			     u8 memtype,
+			     caam_dma_addr_t keymod, size_t keymod_length,
+			     caam_dma_addr_t blob, size_t blob_length,
+			     u8 blobcolor)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize, idx;
+
+	/* Trusted key not supported */
+	if (trusted_key != UNTRUSTED_KEY)
+		return 0;
+
+	memset(tmpdesc, 0, ARRAY_SIZE(tmpdesc) * sizeof(u32));
+	idx = 1;
+
+	/*
+	 * Key modifier works differently for secure/general memory blobs
+	 * This accounts for the permission/protection data encapsulated
+	 * within the blob if a secure memory blob is requested
+	 */
+	if (memtype == DATA_SECMEM)
+		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
+				 LDST_SRCDST_BYTE_KEY |
+				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
+				 | (keymod_length & LDST_LEN_MASK);
+	else /* is general memory blob */
+		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB
+				 | LDST_SRCDST_BYTE_KEY
+				 | (keymod_length & LDST_LEN_MASK);
+
+	tmpdesc[idx++] = (u32)keymod;
+
+	/*
+	 * Encapsulation output must include space for blob key encryption
+	 * key and MAC tag
+	 */
+	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | (secret_length + BLOB_OVERHEAD);
+	tmpdesc[idx++] = (u32)blob;
+
+	/* Input data, should be somewhere in secure memory */
+	tmpdesc[idx++] = CMD_SEQ_IN_PTR | secret_length;
+	tmpdesc[idx++] = (uintptr_t)secret;
+
+	/* Set blob encap, then color */
+	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_ENCAP_PROTOCOL | OP_PCLID_BLOB;
+
+	if (memtype == DATA_SECMEM)
+		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;
+
+	if (auth == KEY_COVER_CCM)
+		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
+
+	/* An input black key cannot be stored in a red blob */
+	if (keycolor == BLACK_KEY)
+		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;
+
+	idx++;
+	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
+	dsize = idx * sizeof(u32);
+
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "encap desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return dsize;
+}
+EXPORT_SYMBOL(cnstr_blob_encap_jobdesc);
+
+/*
+ * Construct a blob decapsulation job descriptor
+ *
+ * This function dynamically constructs a blob decapsulation job descriptor
+ * from the following arguments:
+ *
+ * - desc	pointer to a pointer to the descriptor generated by this
+ *		function. Caller will be responsible to kfree() this
+ *		descriptor after execution.
+ * - keymod	Physical pointer to a key modifier, which must reside in a
+ *		contiguous piece of memory. Modifier will be assumed to be
+ *		8 bytes long for a blob of type DATA_SECMEM, or 16 bytes long
+ *		for a blob of type DATA_GENMEM (see blobcolor argument).
+ * - blobbuf	Physical pointer (into external memory) of the blob to
+ *		be decapsulated. Blob must reside in a contiguous memory
+ *		segment.
+ * - outbuf	Physical pointer of the decapsulated output, possibly into
+ *		a location within a secure memory page. Must be contiguous.
+ * - secretsz	Size of encapsulated secret in bytes (not the size of the
+ *		input blob).
+ * - keycolor   Determines if decapsulated content is encrypted (BLACK_KEY)
+ *		or left as plaintext (RED_KEY).
+ * - blobcolor	Determine if encapsulated blob should be a secure memory
+ *		blob (DATA_SECMEM), with partition data embedded with key
+ *		material, or a general memory blob (DATA_GENMEM).
+ * - auth	If decapsulation path is specified by BLACK_KEY, then if
+ *		AES-CCM is requested for key covering use KEY_COVER_CCM, else
+ *		use AES-ECB (KEY_COVER_ECB).
+ *
+ * Upon completion, desc points to a buffer containing a CAAM job descriptor
+ * that decapsulates a key blob from external memory into a black (encrypted)
+ * key or red (plaintext) content.
+ *
+ * This is an example of a black key decapsulation job from a general memory
+ * blob. Notice the 16-byte key modifier in the LOAD instruction.
+ *
+ * [00] B0800008       jobhdr: stidx=0 len=8
+ * [01] 14400010           ld: ccb2-key len=16 offs=0
+ * [02] 08A63B7F               ptr->@0x08a63b7f
+ * [03] F8000010    seqoutptr: len=16
+ * [04] 01000000               out_ptr->@0x01000000
+ * [05] F000003A     seqinptr: len=58
+ * [06] 01000010               in_ptr->@0x01000010
+ * [07] 860D0004    operation: decap blob  reg=memory, black, format=normal
+ *
+ * This is an example of a red key decapsulation job for restoring a red key
+ * from a secure memory blob. Note the 8 byte modifier on the 12 byte offset
+ * in the LOAD instruction:
+ *
+ * [00] B0800008       jobhdr: stidx=0 len=8
+ * [01] 14400C08           ld: ccb2-key len=8 offs=12
+ * [02] 01000000               ptr->@0x01000000
+ * [03] F8000020    seqoutptr: len=32
+ * [04] 400000E6               out_ptr->@0x400000e6
+ * [05] F0000050     seqinptr: len=80
+ * [06] 08F0C0EA               in_ptr->@0x08f0c0ea
+ * [07] 860D0008    operation: decap blob  reg=memory, red, sec_mem,
+ *			       format=normal
+ *
+ * Note: this function only generates 32-bit pointers at present, and should
+ * be refactored using a scheme that allows both 32 and 64 bit addressing
+ */
+int cnstr_blob_decap_jobdesc(u32 **desc,
+			     caam_dma_addr_t blob, size_t blob_length,
+			     u8 blobcolor,
+			     caam_dma_addr_t keymod, size_t keymod_length,
+			     caam_dma_addr_t secret, size_t secret_length,
+			     u8 keycolor, u8 auth,  u8 trusted_key,
+			     u8 memtype)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize, idx;
+
+	/* Trusted key not supported */
+	if (trusted_key != UNTRUSTED_KEY)
+		return 0;
+
+	memset(tmpdesc, 0, ARRAY_SIZE(tmpdesc) * sizeof(u32));
+	idx = 1;
+
+	/* Load key modifier */
+	if (memtype == DATA_SECMEM)
+		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
+				 LDST_SRCDST_BYTE_KEY |
+				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
+				 | (keymod_length & LDST_LEN_MASK);
+	else /* is general memory blob */
+		tmpdesc[idx++] = CMD_LOAD
+				| LDST_CLASS_2_CCB
+				| LDST_SRCDST_BYTE_KEY
+				| (keymod_length & LDST_LEN_MASK);
+
+	tmpdesc[idx++] = (u32)keymod;
+
+	/* Compensate BKEK + MAC tag over size of encapsulated secret */
+	tmpdesc[idx++] = CMD_SEQ_IN_PTR | blob_length;
+	tmpdesc[idx++] = (u32)blob;
+	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | secret_length;
+	tmpdesc[idx++] = (uintptr_t)secret;
+
+	/* Decapsulate from secure memory partition to black blob */
+	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_DECAP_PROTOCOL | OP_PCLID_BLOB;
+
+	if (memtype == DATA_SECMEM)
+		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;
+
+	if (auth == KEY_COVER_CCM)
+		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
+
+	if (keycolor == BLACK_KEY)
+		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;
+
+	idx++;
+	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
+	dsize = idx * sizeof(u32);
+
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "decap desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return dsize;
+}
+EXPORT_SYMBOL(cnstr_blob_decap_jobdesc);
+
+/*
+ * @brief      Create a job descriptor to load a key by address
+ *
+ * @param[out] desc        The description
+ * @param[in]  key         The key
+ * @param[in]  key_size    The key size
+ * @param[in]  key_length  The key length
+ * @param[in]  key_class   The key class
+ * @param[in]  enc         The encode
+ * @param[in]  nwb         The nwb
+ * @param[in]  ekt         The ekt
+ * @param[in]  kdest       The kdest
+ *
+ * @return     Return the number of bytes of the descriptor
+ */
+int cnstr_key_jobdesc(u32 **desc,
+		      caam_dma_addr_t key, size_t key_size, size_t key_length,
+		      u32 key_class, u32 enc,
+		      u32 nwb, u32 ekt, u32 kdest)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u32 key_option;
+
+	init_desc(tmpdesc, CMD_DESC_HDR);
+
+	key_option = key_class | enc | nwb | ekt | kdest;
+
+	if (enc)
+		append_key(tmpdesc, key, key_length, key_option);
+	else
+		append_key(tmpdesc, key, key_size, key_option);
+
+	tdesc = kmalloc(desc_bytes(tmpdesc), GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, desc_bytes(tmpdesc));
+	*desc = tdesc;
+
+#ifdef DEBUG
+	print_hex_dump(KERN_ERR, "key desc:",
+		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
+#endif
+
+	return desc_bytes(tmpdesc);
+}
+EXPORT_SYMBOL(cnstr_key_jobdesc);
+
+/**
+ * @brief      Create a job descriptor to load an immediate key
+ *
+ * @param[out] desc        The description
+ * @param[in]  key         The key
+ * @param[in]  key_size    The key size
+ * @param[in]  key_length  The key length
+ * @param[in]  key_class   The key class
+ * @param[in]  enc         The encode
+ * @param[in]  nwb         The nwb
+ * @param[in]  ekt         The ekt
+ * @param[in]  kdest       The kdest
+ *
+ * @return     Return the number of bytes of the descriptor
+ */
+int cnstr_key_imm_jobdesc(u32 **desc,
+			  void *key, size_t key_size, size_t key_length,
+			  u32 key_class, u32 enc,
+			  u32 nwb, u32 ekt, u32 kdest)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u32 key_option;
+
+	init_desc(tmpdesc, CMD_DESC_HDR);
+
+	key_option = key_class | enc | nwb | ekt | kdest;
+
+	append_key_as_imm(tmpdesc, (void *)key, key_size, key_length,
+			  key_option);
+
+	tdesc = kmalloc(desc_bytes(tmpdesc), GFP_KERNEL | GFP_DMA);
+	if (!tdesc)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, desc_bytes(tmpdesc));
+	*desc = tdesc;
+
+	return desc_bytes(tmpdesc);
+}
+EXPORT_SYMBOL(cnstr_key_imm_jobdesc);
diff --git a/drivers/crypto/caam/caam_desc.h b/drivers/crypto/caam/caam_desc.h
new file mode 100644
index 0000000..b3d42f5
--- /dev/null
+++ b/drivers/crypto/caam/caam_desc.h
@@ -0,0 +1,117 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Shared descriptors for caam black key and blob
+ *
+ * Copyright 2016 NXP
+ */
+
+#ifndef CAAM_DESC_H
+#define CAAM_DESC_H
+
+#include <linux/types.h>
+
+#include "compat.h"
+#include "regs.h"
+
+/* Define treatment of secure memory vs. general memory blobs */
+#define DATA_GENMEM 0
+#define DATA_DMAMEM 1
+#define DATA_SECMEM 2
+
+/* Define treatment of red/black keys */
+#define RED_KEY 0 /* Clear key */
+#define BLACK_KEY 1 /* Encrypted key */
+
+/* Definition of the different type of blob */
+#define RED_BLOB 0
+#define BLACK_BLOB 1
+
+/* Define key encryption/covering options */
+#define KEY_COVER_ECB 0	/* cover key in AES-ECB */
+#define KEY_COVER_CCM 1 /* cover key with AES-CCM */
+
+/* Define the trust in the key, to select either JDKEK or TDKEK */
+#define UNTRUSTED_KEY 0
+#define TRUSTED_KEY 1
+
+/* Define space required for BKEK + MAC tag storage in any blob */
+#define BLOB_OVERHEAD (32 + 16)
+
+#define PAD_16_BYTE(_key_size) (roundup(_key_size, 16))
+
+/* An ECB black key is a multiple of 16 byte, at least the size of the key */
+#define ECB_BLACK_KEY_SIZE(_key_size) (PAD_16_BYTE(_key_size))
+
+#define PAD_8_BYTE(_key_size) (roundup(_key_size, 8))
+
+/* A CCM Black key is a multiple of 8 byte, at least the size of the key
+ * plus 6 byte for the nonce and 6 byte for the IV
+ */
+#define NONCE_SIZE 6
+#define IV_SIZE 6
+#define CCM_OVERHEAD (NONCE_SIZE + IV_SIZE)
+#define CCM_BLACK_KEY_SIZE(_key_size) (PAD_8_BYTE(_key_size) \
+							+ CCM_OVERHEAD)
+
+static inline int secret_size_in_ccm_black_key(int key_size)
+{
+	return ((key_size >= CCM_OVERHEAD) ? key_size - CCM_OVERHEAD : 0);
+}
+
+#define SECRET_SIZE_IN_CCM_BLACK_KEY(_key_size) \
+	secret_size_in_ccm_black_key(_key_size)
+
+/* A red key is unencrypted so its size is the same */
+#define RED_KEY_SIZE(_key_size) (_key_size)
+
+/* Keymod size is 8 byte for blob created in secure memory, else 16 */
+#define KEYMOD_SIZE_SM 8
+#define KEYMOD_SIZE_GM 16
+
+/* Create job descriptor to cover key */
+extern int cnstr_black_key_jobdesc(u32 **desc, caam_dma_addr_t key,
+				   size_t key_length,
+				   caam_dma_addr_t cover_key,
+				   size_t cover_key_length,
+				   u8 auth, u8 trusted_key);
+
+/* Create job descriptor to generate a random key and cover it */
+extern int cnstr_random_black_key_jobdesc(u32 **desc, size_t key_length,
+					  caam_dma_addr_t cover_key,
+					  size_t cover_key_length,
+					  u8 auth, u8 trusted_key);
+
+/* Encapsulate data in a blob */
+extern int cnstr_blob_encap_jobdesc(u32 **desc,
+				    caam_dma_addr_t secret,
+				    size_t secret_length,
+				    u8 keycolor, u8 auth,  u8 trusted_key,
+				    u8 memtype,
+				    caam_dma_addr_t keymod,
+				    size_t keymod_length,
+				    caam_dma_addr_t blob, size_t blob_length,
+				    u8 blobcolor);
+
+/* Decapsulate data from a blob */
+extern int cnstr_blob_decap_jobdesc(u32 **desc,
+				    caam_dma_addr_t blob, size_t blob_length,
+				    u8 blobcolor,
+				    caam_dma_addr_t keymod,
+				    size_t keymod_length,
+				    caam_dma_addr_t secret,
+				    size_t secret_length,
+				    u8 keycolor, u8 auth, u8 trusted_key,
+				    u8 memtype);
+
+extern int cnstr_key_jobdesc(u32 **desc,
+			     caam_dma_addr_t key, size_t key_size,
+			     size_t key_length,
+			     u32 key_class, u32 enc,
+			     u32 nwb, u32 ekt, u32 kdest);
+
+extern int cnstr_key_imm_jobdesc(u32 **desc,
+				 void *key, size_t key_size, size_t key_length,
+				 u32 key_class, u32 enc,
+				 u32 nwb, u32 ekt, u32 kdest);
+
+#endif /* CAAM_DESC_H */
diff --git a/drivers/crypto/caam/caam_util.c b/drivers/crypto/caam/caam_util.c
new file mode 100644
index 0000000..6ad19d5
--- /dev/null
+++ b/drivers/crypto/caam/caam_util.c
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Utility functions for CAAM
+ *
+ * Copyright 2018 NXP
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+
+#include "caam.h"
+#include "caam_util.h"
+
+/**
+ * @brief      Prepare data to be written to CAAM
+ *
+ * @details    The function performs:
+ *  - Allocation of memory compatible with DMA
+ *  - Retrieve the DMA address
+ *  - Copy @b data into @b allocated_data
+ *  - Synchronise the DMA
+ *
+ * @note       The function unprepare_write_data() must be called from cleanup
+ *
+ * @param[in]  jrdev           The jrdev
+ * @param[in]  data            The data
+ * @param[in]  size            The size
+ * @param[out] dma_addr        The dma address
+ * @param[out] allocated_data  The allocated data
+ *
+ * @return     0 on success else error code
+ */
+int prepare_write_data(struct device *jrdev, const u8 *data, size_t size,
+		       caam_dma_addr_t *dma_addr, u8 **allocated_data)
+{
+	int err = 0;
+
+	/* Allocate memory for data compatible with DMA */
+	*allocated_data = kmalloc(size, GFP_KERNEL | GFP_DMA);
+	if (!*allocated_data) {
+		err = (-ENOMEM);
+		goto exit;
+	}
+
+	/* Get DMA address */
+	*dma_addr = dma_map_single(jrdev, *allocated_data, size, DMA_TO_DEVICE);
+	if (dma_mapping_error(jrdev, *dma_addr)) {
+		dev_err(jrdev, "unable to map data: %p\n", data);
+		err = (-ENOMEM);
+		goto free_alloc;
+	}
+
+	/* Copy the data and synchronize the DMA */
+	memcpy(*allocated_data, data, size);
+	dma_sync_single_for_device(jrdev, *dma_addr, size, DMA_TO_DEVICE);
+
+	goto exit;
+
+free_alloc:
+	kfree(*allocated_data);
+
+exit:
+	return err;
+}
+EXPORT_SYMBOL(prepare_write_data);
+
+/**
+ * @brief      Unprepare the data written
+ *
+ * @details    The function performs:
+ * - Clear the temporary memory
+ * - Unmap the DMA address
+ * - Free @b allocated_data
+ *
+ * @attention  Must be called on data prepared with prepare_write_data()
+ *
+ * @param[in]  jrdev           The jrdev
+ * @param[in]  dma_addr        The dma address
+ * @param[in]  allocated_data  The allocated data
+ * @param[in]  size            The size
+ */
+void unprepare_write_data(struct device *jrdev,
+			  caam_dma_addr_t dma_addr,
+			  u8 *allocated_data, size_t size)
+{
+	/* Clear the data */
+	memset(allocated_data, 0, size);
+	dma_sync_single_for_device(jrdev, dma_addr, size, DMA_TO_DEVICE);
+
+	/* Free the resources */
+	dma_unmap_single(jrdev, dma_addr, size, DMA_TO_DEVICE);
+	kfree(allocated_data);
+}
+EXPORT_SYMBOL(unprepare_write_data);
+
+/**
+ * @brief      Prepare data to be read from CAAM
+ *
+ * @details    The function performs:
+ *  - Allocation of memory compatible with DMA
+ *  - Retrieve the DMA address
+ *
+ * @note       The function read_data_prepared() must be called prior to read
+ *             data. The function unprepare_read_data() must be called from
+ *             cleanup
+ *
+ * @param[in]  jrdev           The jrdev
+ * @param[in]  size            The size
+ * @param[out] dma_addr        The dma address
+ * @param[out] allocated_data  The allocated data
+ *
+ * @return     0 on success else error code
+ */
+int prepare_read_data(struct device *jrdev, size_t size,
+		      caam_dma_addr_t *dma_addr, u8 **allocated_data)
+{
+	int err = 0;
+
+	/* Allocate memory for data compatible with DMA */
+	*allocated_data = kmalloc(size, GFP_KERNEL | GFP_DMA);
+	if (!*allocated_data) {
+		err = (-ENOMEM);
+		goto exit;
+	}
+
+	/* Get DMA address */
+	*dma_addr = dma_map_single(jrdev, *allocated_data, size,
+				   DMA_FROM_DEVICE);
+	if (dma_mapping_error(jrdev, *dma_addr)) {
+		dev_err(jrdev, "unable to map data\n");
+		err = (-ENOMEM);
+		goto free_alloc;
+	}
+
+	goto exit;
+
+free_alloc:
+	kfree(*allocated_data);
+
+exit:
+	return err;
+}
+EXPORT_SYMBOL(prepare_read_data);
+
+/**
+ * @brief         Reads prepared data
+ *
+ * @details       The function performs:
+ *  - Synchronization of the data
+ *  - copy @b allocated_data to @b data
+ *
+ * @attention     Must be called on data prepared with prepare_read_data()
+ *
+ * @param[in]     jrdev           The jrdev
+ * @param[in,out] data            The data
+ * @param[in]     dma_addr        The dma address
+ * @param[in]     allocated_data  The allocated data
+ * @param[in]     size            The size
+ */
+void read_data_prepared(struct device *jrdev, u8 *data,
+			caam_dma_addr_t dma_addr,
+			u8 *allocated_data, size_t size)
+{
+	/* Synchronize the DMA and copy the data */
+	dma_sync_single_for_device(jrdev, dma_addr, size, DMA_FROM_DEVICE);
+	memcpy(data, allocated_data, size);
+}
+EXPORT_SYMBOL(read_data_prepared);
+
+/**
+ * @brief      Unprepare the data read
+ *
+ * @details    The function performs:
+ * - Clear the temporary memory
+ * - DMA unmapping
+ * - Free @b allocated_data
+ *
+ * @attention  Must be called on data prepared with prepare_read_data()
+ *
+ * @param      jrdev           The jrdev
+ * @param[in]  dma_addr        The dma address
+ * @param      allocated_data  The allocated data
+ * @param[in]  size            The size
+ */
+void unprepare_read_data(struct device *jrdev, caam_dma_addr_t dma_addr,
+			 u8 *allocated_data, size_t size)
+{
+	/* Clear the data */
+	memset(allocated_data, 0, size);
+	dma_sync_single_for_device(jrdev, dma_addr, size, DMA_FROM_DEVICE);
+
+	/* Free the resources */
+	dma_unmap_single(jrdev, dma_addr, size,	DMA_FROM_DEVICE);
+	kfree(allocated_data);
+}
+EXPORT_SYMBOL(unprepare_read_data);
+
+/**
+ * @brief      Gets the caam dma address of a physical address.
+ *
+ * @param      phy_address  The physical address
+ *
+ * @return     The caam dma address.
+ */
+caam_dma_addr_t get_caam_dma_addr(const void *phy_address)
+{
+	uintptr_t ptr_conv;
+	caam_dma_addr_t caam_dma_address = 0;
+
+	/* Check conversion is possible */
+	if (sizeof(caam_dma_address) < sizeof(phy_address)) {
+		/* We have to check that all bits sets in the phy_address
+		 * can be stored in caam_dma_address
+		 */
+
+		/* We generate a mask of the representable bits */
+		u64 mask = GENMASK_ULL(sizeof(caam_dma_address) * 8, 0);
+
+		/* We check that the bits not reprensentable of
+		 * phy_address are not set
+		 */
+		if ((uintptr_t)phy_address & ~mask)
+			goto exit;
+	}
+
+	/* We convert address to caam_dma_address */
+	ptr_conv = (uintptr_t)phy_address;
+	caam_dma_address = (caam_dma_addr_t)ptr_conv;
+
+exit:
+	return caam_dma_address;
+}
+EXPORT_SYMBOL(get_caam_dma_addr);
diff --git a/drivers/crypto/caam/caam_util.h b/drivers/crypto/caam/caam_util.h
new file mode 100644
index 0000000..6d27e03
--- /dev/null
+++ b/drivers/crypto/caam/caam_util.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Utility functions for CAAM exported
+ *
+ * Copyright 2018 NXP
+ */
+
+#ifndef _CAAM_UTIL_H_
+#define _CAAM_UTIL_H_
+
+#include <linux/device.h>
+
+#include "caam.h"
+#include "regs.h"
+#include "caam_desc.h"
+
+extern int prepare_write_data(struct device *jrdev, const u8 *data, size_t size,
+			      caam_dma_addr_t *dma_addr, u8 **allocated_data);
+
+extern void unprepare_write_data(struct device *jrdev,
+				 caam_dma_addr_t dma_addr,
+				 u8 *allocated_data, size_t size);
+
+extern int prepare_read_data(struct device *jrdev, size_t size,
+			     caam_dma_addr_t *dma_addr, u8 **allocated_data);
+
+extern void read_data_prepared(struct device *jrdev, u8 *data,
+			       caam_dma_addr_t dma_addr,
+			       u8 *allocated_data, size_t size);
+
+extern void unprepare_read_data(struct device *jrdev, caam_dma_addr_t dma_addr,
+				u8 *allocated_data, size_t size);
+
+extern caam_dma_addr_t get_caam_dma_addr(const void *address);
+
+extern int caam_black_key(struct device *jrdev,
+			  const void *key, size_t key_length, u8 key_memtype,
+			  void *black_key, size_t *black_key_length,
+			  u8 black_key_memtype, u8 keyauth, u8 trusted_key);
+
+extern int caam_random_black_key(struct device *jrdev,
+				 size_t key_length,
+				 void *black_key, size_t *black_key_length,
+				 u8 black_key_memtype, u8 keyauth,
+				 u8 trusted_key);
+
+extern int caam_blob_encap(struct device *jrdev,
+			   const void  *secret, size_t secret_length,
+			   u8 secret_memtype,
+			   u8 keycolor, size_t key_length_in_secret,
+			   u8 auth, u8 trusted_key,
+			   const void *keymod, size_t *keymod_length,
+			   u8 keymod_memtype,
+			   void *blob, size_t *blob_length,
+			   u8 blob_memtype, u8 blobcolor);
+
+extern int caam_blob_decap(struct device *jrdev,
+			   const void *blob, size_t blob_length,
+			   u8 blob_memtype,
+			   u8 blobcolor,
+			   const void *keymod, size_t *keymod_length,
+			   u8 keymod_memtype,
+			   void *secret, size_t *secret_length,
+			   u8 secret_memtype,
+			   u8 keycolor, size_t *key_length_in_secret,
+			   u8 auth, u8 trusted_key);
+
+/**
+ * @brief      Determines if key color is valid
+ *
+ * @param[in]  keycolor  The keycolor
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_key_color(u8 keycolor)
+{
+	return (keycolor == BLACK_KEY) || (keycolor == RED_KEY);
+}
+
+/**
+ * @brief      Determines if the memory type is valid
+ *
+ * @param[in]  memtype  The memory type
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_memory_type(u8 memtype)
+{
+	return (memtype == DATA_GENMEM) ||
+		(memtype == DATA_DMAMEM) ||
+		(memtype == DATA_SECMEM);
+}
+
+/**
+ * @brief      Determines if the blob color is valid
+ *
+ * @param[in]  blobcolor  The blob color
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_blob_color(u8 blobcolor)
+{
+	return (blobcolor == RED_BLOB) || (blobcolor == BLACK_BLOB);
+}
+
+/**
+ * @brief      Determines if the auth is valid
+ *
+ * @param[in]  auth  The authentication
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_auth(u8 auth)
+{
+	return (auth == KEY_COVER_ECB) || (auth == KEY_COVER_CCM);
+}
+
+/**
+ * @brief      Determines if trusted key value is valid
+ *
+ * @param[in]  trusted_key  The trusted key value
+ *
+ * @return     True if valid, False otherwise.
+ */
+static inline bool is_trusted_key(u8 trusted_key)
+{
+	return (trusted_key == UNTRUSTED_KEY) || (trusted_key == TRUSTED_KEY);
+}
+
+#endif /* _CAAM_UTIL_H_ */
diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h
index 9dc79b0..fbaefa7 100644
--- a/drivers/crypto/caam/desc.h
+++ b/drivers/crypto/caam/desc.h
@@ -182,6 +182,9 @@
 /* Length in bytes */
 #define KEY_LENGTH_MASK		0x000003ff

+/* Key can be stored in plaintext form later */
+#define KEY_PTS			0x00004000
+
 /*
  * LOAD/SEQ_LOAD/STORE/SEQ_STORE Command Constructs
  */
diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c
index 616a427..49fd2b9 100644
--- a/drivers/crypto/caam/jr.c
+++ b/drivers/crypto/caam/jr.c
@@ -9,6 +9,7 @@
 #include <linux/of_irq.h>
 #include <linux/of_address.h>

+#include "caam.h"
 #include "compat.h"
 #include "ctrl.h"
 #include "regs.h"
@@ -396,6 +397,50 @@ int caam_jr_enqueue(struct device *dev, u32 *desc,
 }
 EXPORT_SYMBOL(caam_jr_enqueue);

+/* Structure to wait for the job to complete */
+struct jr_job_result {
+	int error;
+	struct completion completion;
+};
+
+/* Callback when a job has been completed
+ * It expects the context to be a pointer on jr_job_result
+ */
+static void jr_job_done_cb(struct device *jrdev, u32 *desc, u32 err,
+			   void *context)
+{
+	struct jr_job_result *res = context;
+
+	dev_dbg(jrdev, "jobs %p done: %x", desc, err);
+	if (err)
+		caam_jr_strstatus(jrdev, err);
+
+	res->error = err; /* save off the error for postprocessing */
+
+	complete(&res->completion);	/* mark us complete */
+}
+
+/* Run a job and wait for its completion */
+int jr_run_job_and_wait_completion(struct device *jrdev, u32 *jobdesc)
+{
+	struct jr_job_result jobres = {0};
+	int rtn = 0;
+
+	init_completion(&jobres.completion);
+
+	dev_dbg(jrdev, "Enqueing job %p", jobdesc);
+	rtn = caam_jr_enqueue(jrdev, jobdesc, jr_job_done_cb, &jobres);
+	if (rtn)
+		goto exit;
+
+	wait_for_completion_interruptible(&jobres.completion);
+	rtn = jobres.error;
+
+exit:
+	return rtn;
+}
+EXPORT_SYMBOL(jr_run_job_and_wait_completion);
+
 /*
  * Init JobR independent of platform property detection
  */
diff --git a/drivers/crypto/caam/key_blob.c b/drivers/crypto/caam/key_blob.c
new file mode 100644
index 0000000..6f0a9ed
--- /dev/null
+++ b/drivers/crypto/caam/key_blob.c
@@ -0,0 +1,829 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "compat.h"
+#include "intern.h"
+#include "sm.h"
+#include "key_blob.h"
+#include "desc.h"
+#include "jr.h"
+#include "caam_desc.h"
+#include "caam_util.h"
+
+#include "linux/printk.h"
+
+#define KEY_MAX_LENGTH (512 - BLOB_OVERHEAD)
+#define KEY_CCM_OVERHEAD 12
+
+#define KEY_COLOR_RED	0x0
+#define KEY_COLOR_BLACK	0x1
+
+static struct kobject *kb_kobj;
+static struct kobj_attribute *kb_kattr;
+static struct attribute_group *kb_attr_group;
+
+static int kb_major;
+static struct class *kb_class;
+
+#define DATA_SIZE		16
+static u8 data[] = {
+	0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
+};
+
+static u8 skeymod[] = {
+	0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,
+	0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00
+};
+
+kb_addr_t kb_addr;
+kb_addr_t kb_addr_user;
+
+/*
+ * Blacken a clear key in a slot. Operates "in place".
+ * Limited to class 1 keys at the present time
+ */
+static int sm_keystore_cover_key(struct device *dev, u32 unit, u32 slot,
+				 u16 key_length, u8 keyauth)
+{
+	int retval = 0;
+	struct device *jrdev;
+	void *slotphys;
+	size_t black_key_length;
+
+	if (!dev)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(dev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	black_key_length = sm_keystore_get_slot_size(dev, unit, slot);
+	if (!black_key_length) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_black_key(jrdev,
+				slotphys, key_length, DATA_SECMEM,
+				slotphys, &black_key_length, DATA_SECMEM,
+				keyauth, UNTRUSTED_KEY);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
+/* Export a black/red key to a blob in external memory */
+static int sm_keystore_slot_export(struct device *ksdev, u32 unit, u32 slot,
+				   u8 keycolor, u8 keyauth,
+				   u8 *outbuf, u16 keylen, u8 *keymod)
+{
+	struct device *jrdev;
+	int retval = 0;
+	u8 __iomem *slotphys;
+	size_t blob_len;
+	size_t keymod_len = KEYMOD_SIZE_SM;
+	u8 blob_color = (keycolor == BLACK_KEY) ? BLACK_BLOB : RED_BLOB;
+
+	if (!ksdev || !outbuf || !keymod)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(ksdev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	blob_len = sm_keystore_get_slot_size(ksdev, unit, slot);
+	if (!blob_len) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_blob_encap(jrdev,
+				 slotphys, keylen, DATA_SECMEM,
+				 keycolor, keylen,
+				 keyauth, UNTRUSTED_KEY,
+				 keymod, &keymod_len, DATA_GENMEM,
+				 outbuf, &blob_len,
+				 DATA_GENMEM, blob_color);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
+/* Import a black/red key from a blob residing in external memory */
+static int sm_keystore_slot_import(struct device *ksdev, u32 unit, u32 slot,
+				   u8 keycolor, u8 keyauth,
+				   u8 *inbuf, u16 keylen, u8 *keymod)
+{
+	struct device *jrdev;
+	int retval = 0;
+	u8 __iomem *slotphys;
+	size_t keymod_len = KEYMOD_SIZE_SM;
+	size_t key_len;
+	size_t secret_size = 0;
+	u8 blob_color = (keycolor == BLACK_KEY) ? BLACK_BLOB : RED_BLOB;
+
+	if (!ksdev || !inbuf || !keymod)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(ksdev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	key_len = sm_keystore_get_slot_size(ksdev, unit, slot);
+	if (!key_len) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_blob_decap(jrdev,
+				 inbuf, keylen + BLOB_OVERHEAD,
+				 DATA_GENMEM, blob_color,
+				 keymod, &keymod_len, DATA_GENMEM,
+				 slotphys, &key_len, DATA_SECMEM,
+				 keycolor, &secret_size,
+				 keyauth, UNTRUSTED_KEY);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
+static int aes_cipher(struct device *ksdev, u8* key, u16 keysz, u8* indata, u8* outdata, u16 sz, u32 operation, u32 keymode)
+{
+	struct caam_drv_private_sm *kspriv = dev_get_drvdata(ksdev);
+	struct device *jrdev = kspriv->smringdev;
+	int ret = 0;
+	u32 jstat;
+
+	dma_addr_t key_dma;
+	dma_addr_t indata_dma;
+	dma_addr_t outdata_dma;
+
+	u32 __iomem *desc;
+
+	desc = (u32*)kzalloc(MAX_CAAM_DESCSIZE * sizeof(u32), GFP_KERNEL | GFP_DMA);
+	if(!desc)
+		return -ENOMEM;
+
+	key_dma = dma_map_single(jrdev, key, keysz, DMA_TO_DEVICE);
+	dma_sync_single_for_device(jrdev, key_dma, keysz, DMA_TO_DEVICE);
+
+	indata_dma = dma_map_single(jrdev, indata, sz, DMA_TO_DEVICE);
+	dma_sync_single_for_device(jrdev, indata_dma, sz, DMA_TO_DEVICE);
+
+	outdata_dma = dma_map_single(jrdev, outdata, sz, DMA_FROM_DEVICE);
+
+	desc[1] = CMD_KEY | CLASS_1 | (keysz & KEY_LENGTH_MASK) | keymode;
+	desc[2] = (u32)key_dma;
+	desc[3] = CMD_OPERATION | OP_TYPE_CLASS1_ALG | OP_ALG_AAI_ECB | OP_ALG_ALGSEL_AES | operation;
+	desc[4] = CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 | FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1 | sz;
+	desc[5] = (u32)indata_dma;
+	desc[6] = CMD_FIFO_STORE | FIFOST_TYPE_MESSAGE_DATA | sz;
+	desc[7] = (u32)outdata_dma;
+	desc[0] = CMD_DESC_HDR | HDR_ONE | (8 & HDR_DESCLEN_MASK);
+
+	jstat = jr_run_job_and_wait_completion(jrdev, desc);
+	if (jstat) {
+		dev_err(jrdev, "Encrypt/Decrypt job failed\n");
+		ret = -EIO;
+		goto free_desc;
+	}
+
+	dma_sync_single_for_cpu(jrdev, outdata_dma, sz, DMA_FROM_DEVICE);
+
+	dma_unmap_single(jrdev, key_dma, keysz, DMA_TO_DEVICE);
+	dma_unmap_single(jrdev, indata_dma, sz, DMA_TO_DEVICE);
+	dma_unmap_single(jrdev, outdata_dma, sz, DMA_FROM_DEVICE);
+
+free_desc:
+	kfree(desc);
+
+	return ret;
+}
+
+static ssize_t kb_encap(u32 key_len, u32 key_color, u32 key_cover)
+{
+	int ret = 0;
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+	struct device *ctrldev, *ksdev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_sm *kspriv;
+	u32 units, unit, keyslot;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	ctrldev = &pdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+	ksdev = ctrlpriv->smdev;
+	kspriv = dev_get_drvdata(ksdev);
+	if (kspriv == NULL)
+		return -ENODEV;
+
+	units = sm_detect_keystore_units(ksdev);
+
+	if (units < 2)
+		return -ENODEV;
+
+	unit = 1;
+	sm_establish_keystore(ksdev, unit);
+
+	if (copy_from_user(kb_addr.key_addr, kb_addr_user.key_addr, key_len))
+		return -EFAULT;
+
+	if (key_cover == KEY_COVER_CCM) {
+		sm_keystore_slot_alloc(ksdev, unit, key_len + KEY_CCM_OVERHEAD, &keyslot);
+		sm_keystore_slot_load(ksdev, unit, keyslot, kb_addr.key_addr, key_len + KEY_CCM_OVERHEAD);
+		sm_keystore_slot_export(ksdev, unit, keyslot, key_color, key_cover, kb_addr.blob_addr, key_len, skeymod);
+	} else {
+		sm_keystore_slot_alloc(ksdev, unit, key_len, &keyslot);
+		sm_keystore_slot_load(ksdev, unit, keyslot, kb_addr.key_addr, key_len);
+		sm_keystore_slot_export(ksdev, unit, keyslot, key_color, key_cover, kb_addr.blob_addr, key_len, skeymod);
+	}
+
+	if (copy_to_user(kb_addr_user.blob_addr, kb_addr.blob_addr, key_len + BLOB_OVERHEAD))
+		return -EFAULT;
+
+	sm_keystore_slot_dealloc(ksdev, unit, keyslot);
+	sm_release_keystore(ksdev, unit);
+
+	return ret;
+}
+
+static ssize_t kb_decap(u32 blob_len, u32 key_color, u32 key_cover)
+{
+	int ret = 0;
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+	struct device *ctrldev, *ksdev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_sm *kspriv;
+	u32 units, unit, keyslot;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	ctrldev = &pdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+	ksdev = ctrlpriv->smdev;
+	kspriv = dev_get_drvdata(ksdev);
+	if (kspriv == NULL)
+		return -ENODEV;
+
+	units = sm_detect_keystore_units(ksdev);
+
+	if (units < 2)
+		return -ENODEV;
+
+	unit = 1;
+
+	sm_establish_keystore(ksdev, unit);
+
+	if (copy_from_user(kb_addr.blob_addr, kb_addr_user.blob_addr, blob_len))
+		return -EFAULT;
+
+	if (key_cover == KEY_COVER_CCM) {
+		sm_keystore_slot_alloc(ksdev, unit, blob_len - BLOB_OVERHEAD + KEY_CCM_OVERHEAD, &keyslot);
+		sm_keystore_slot_import(ksdev, unit, keyslot, key_color, key_cover, kb_addr.blob_addr, blob_len - BLOB_OVERHEAD, skeymod);
+		sm_keystore_slot_read(ksdev, unit, keyslot, blob_len - BLOB_OVERHEAD + KEY_CCM_OVERHEAD, kb_addr.key_addr);
+	} else {
+		sm_keystore_slot_alloc(ksdev, unit, blob_len - BLOB_OVERHEAD, &keyslot);
+		sm_keystore_slot_import(ksdev, unit, keyslot, key_color, key_cover, kb_addr.blob_addr, blob_len - BLOB_OVERHEAD, skeymod);
+		sm_keystore_slot_read(ksdev, unit, keyslot, blob_len - BLOB_OVERHEAD, kb_addr.key_addr);
+	}
+
+	if (copy_to_user(kb_addr_user.key_addr, kb_addr.key_addr, blob_len - BLOB_OVERHEAD))
+		return -EFAULT;
+
+	sm_keystore_slot_dealloc(ksdev, unit, keyslot);
+	sm_release_keystore(ksdev, unit);
+
+	return ret;
+}
+
+static ssize_t kb_encr(kb_operation_t *op)
+{
+	int ret = 0;
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+	struct device *ctrldev, *ksdev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_sm *kspriv;
+	u32 units, unit, keyslot;
+	u32 blob_len, key_color, key_cover;
+	u8 __iomem *key, *plaindata, *cipherdata;
+
+	blob_len = op->blob_len;
+	key_color = op->key_color;
+	key_cover = op->key_cover;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	ctrldev = &pdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+	ksdev = ctrlpriv->smdev;
+	kspriv = dev_get_drvdata(ksdev);
+	if (kspriv == NULL)
+		return -ENODEV;
+
+	units = sm_detect_keystore_units(ksdev);
+
+	if (units < 2)
+		return -ENODEV;
+
+	unit = 1;
+
+	plaindata = kzalloc(DATA_SIZE, GFP_KERNEL | GFP_DMA);
+	cipherdata = kzalloc(DATA_SIZE, GFP_KERNEL | GFP_DMA);
+
+	if (copy_from_user(kb_addr.blob_addr, kb_addr_user.blob_addr, blob_len))
+		return -EFAULT;
+
+	sm_establish_keystore(ksdev, unit);
+	sm_keystore_slot_alloc(ksdev, unit, blob_len - BLOB_OVERHEAD, &keyslot);
+	sm_keystore_slot_import(ksdev, unit, keyslot, key_color, key_cover, kb_addr.blob_addr, blob_len - BLOB_OVERHEAD, skeymod);
+
+	key = kzalloc(blob_len - BLOB_OVERHEAD, GFP_KERNEL | GFP_DMA);
+	memcpy(key, (u8 *)kspriv->slot_get_address(ksdev, unit, keyslot), blob_len - BLOB_OVERHEAD);
+
+	memcpy(plaindata, op->buffer, DATA_SIZE);
+
+	if (key_color == KEY_COLOR_BLACK)
+		aes_cipher(ksdev, key, blob_len - BLOB_OVERHEAD, plaindata, cipherdata, DATA_SIZE, OP_ALG_ENCRYPT, KEY_ENC);
+	else if (key_color == KEY_COLOR_RED)
+		aes_cipher(ksdev, key, blob_len - BLOB_OVERHEAD, plaindata, cipherdata, DATA_SIZE, OP_ALG_ENCRYPT, 0);
+	else {
+		ret = -1;
+		goto out_free;
+	}
+
+	memcpy(op->buffer, cipherdata, DATA_SIZE);
+
+out_free:
+	kfree(key);
+	kfree(plaindata);
+	kfree(cipherdata);
+	sm_keystore_slot_dealloc(ksdev, unit, keyslot);
+	sm_release_keystore(ksdev, unit);
+
+	return ret;
+}
+
+static ssize_t kb_decr(kb_operation_t *op)
+{
+	int ret = 0;
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+	struct device *ctrldev, *ksdev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_sm *kspriv;
+	u32 units, unit, keyslot;
+	u32 blob_len, key_color, key_cover;
+	u8 __iomem *key, *plaindata, *cipherdata;
+
+	blob_len = op->blob_len;
+	key_color = op->key_color;
+	key_cover = op->key_cover;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	ctrldev = &pdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+	ksdev = ctrlpriv->smdev;
+	kspriv = dev_get_drvdata(ksdev);
+	if (kspriv == NULL)
+		return -ENODEV;
+
+	units = sm_detect_keystore_units(ksdev);
+
+	if (units < 2)
+		return -ENODEV;
+
+	unit = 1;
+
+	plaindata = kzalloc(DATA_SIZE, GFP_KERNEL | GFP_DMA);
+	cipherdata = kzalloc(DATA_SIZE, GFP_KERNEL | GFP_DMA);
+
+	if (copy_from_user(kb_addr.blob_addr, kb_addr_user.blob_addr, blob_len))
+		return -EFAULT;
+
+	sm_establish_keystore(ksdev, unit);
+	sm_keystore_slot_alloc(ksdev, unit, blob_len - BLOB_OVERHEAD, &keyslot);
+	sm_keystore_slot_import(ksdev, unit, keyslot, key_color, key_cover, kb_addr.blob_addr, blob_len - BLOB_OVERHEAD, skeymod);
+
+	key = kzalloc(blob_len - BLOB_OVERHEAD, GFP_KERNEL | GFP_DMA);
+	memcpy(key, (u8 *)kspriv->slot_get_address(ksdev, unit, keyslot), blob_len - BLOB_OVERHEAD);
+
+	memcpy(cipherdata, op->buffer, DATA_SIZE);
+
+	if (key_color == KEY_COLOR_BLACK)
+		aes_cipher(ksdev, key, blob_len - BLOB_OVERHEAD, cipherdata, plaindata, DATA_SIZE, OP_ALG_DECRYPT, KEY_ENC);
+	else if (key_color == KEY_COLOR_RED)
+		aes_cipher(ksdev, key, blob_len - BLOB_OVERHEAD, cipherdata, plaindata, DATA_SIZE, OP_ALG_DECRYPT, 0);
+	else{
+		ret = -1;
+		goto out_free;
+	}
+
+	memcpy(op->buffer, plaindata, DATA_SIZE);
+
+out_free:
+	kfree(key);
+	kfree(plaindata);
+	kfree(cipherdata);
+	sm_keystore_slot_dealloc(ksdev, unit, keyslot);
+	sm_release_keystore(ksdev, unit);
+
+	return ret;
+}
+
+static ssize_t kb_encap_mfg(struct kobject *kobj, struct kobj_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct file *filp;
+	int ret = 0;
+	u32 key_len;
+	unsigned long value;
+
+	ret = kstrtoul(buf, 16, &value);
+	if (ret < 0)
+		return -EINVAL;
+
+	if (value == 1)
+		filp = filp_open("/device/key.bin", O_RDONLY, 0);
+	else
+		return -EINVAL;
+
+	if (IS_ERR(filp)) {
+		printk("key file open failed\n");
+		return -ENOENT;
+	}
+
+	memset(kb_addr.key_addr, 0, KEY_MAX_LENGTH);
+	memset(kb_addr.blob_addr, 0, KEY_MAX_LENGTH + BLOB_OVERHEAD);
+
+	key_len = kernel_read(filp, 0, kb_addr.key_addr, KEY_MAX_LENGTH);
+
+	filp_close(filp, NULL);
+
+	if (key_len < 0) {
+		printk("key file read failed\n");
+		return -EIO;
+	}
+
+	kb_encap(key_len, RED_KEY, KEY_COVER_ECB);
+
+	if (value == 1)
+		filp = filp_open("/device/key_blob", O_WRONLY | O_CREAT | O_TRUNC, 0644);
+	else
+		return -EINVAL;
+
+	if (IS_ERR(filp)) {
+		printk("blob file open failed\n");
+		return -ENOENT;
+	}
+
+	if (kernel_write(filp, kb_addr.blob_addr, key_len + BLOB_OVERHEAD, 0) < 0) {
+		printk("blob file write failed\n");
+		ret = -EIO;
+	}
+
+	filp_close(filp, NULL);
+
+	return ret ? 0 : count;
+}
+
+static ssize_t kb_decap_mfg(struct kobject *kobj, struct kobj_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct file *filp;
+	int ret = 0;
+	u32 blob_len;
+	unsigned long value;
+
+	ret = kstrtoul(buf, 16, &value);
+	if (ret < 0)
+		return -EINVAL;
+
+	if (value == 1)
+		filp = filp_open("/device/key_blob", O_RDONLY, 0);
+	else
+		return -EINVAL;
+
+	if (IS_ERR(filp)) {
+		printk("blob file open failed\n");
+		return -ENOENT;
+	}
+
+	memset(kb_addr.key_addr, 0, KEY_MAX_LENGTH);
+	memset(kb_addr.blob_addr, 0, KEY_MAX_LENGTH + BLOB_OVERHEAD);
+
+	blob_len = kernel_read(filp, 0, kb_addr.blob_addr, KEY_MAX_LENGTH + BLOB_OVERHEAD);
+
+	filp_close(filp, NULL);
+
+	if (blob_len < 0) {
+		printk("blob file read failed\n");
+		return -EIO;
+	}
+
+	kb_decap(blob_len, RED_KEY, KEY_COVER_ECB);
+
+	if (value == 1)
+		filp = filp_open("/device/key.bin", O_WRONLY | O_CREAT | O_TRUNC, 0644);
+	else
+		return -EINVAL;
+
+	if (IS_ERR(filp)) {
+		printk("key file open failed\n");
+		return -ENOENT;
+	}
+
+	if (kernel_write(filp, kb_addr.key_addr, blob_len - BLOB_OVERHEAD, 0) < 0) {
+		printk("key file write failed\n");
+		ret = -EIO;
+	}
+
+	filp_close(filp, NULL);
+
+	return ret ? 0 : count;
+}
+
+static long kb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int errval = 0;
+
+	switch (cmd) {
+		case KB_IOCTL_ENCAP:
+		{
+			kb_parameter_t kb;
+
+			if (copy_from_user(&kb, (kb_parameter_t *)arg, sizeof(kb_parameter_t)))
+				return -EFAULT;
+			kb_encap(kb.key_len, kb.key_color, kb.key_cover);
+			break;
+		}
+		case KB_IOCTL_DECAP:
+	    {
+			kb_parameter_t kb;
+
+			if (copy_from_user(&kb, (kb_parameter_t *)arg, sizeof(kb_parameter_t)))
+				return -EFAULT;
+			kb_decap(kb.blob_len, kb.key_color, kb.key_cover);
+			break;
+	    }
+		case KB_IOCTL_SEND_VRT_ADDR:
+		{
+			if (copy_from_user(&kb_addr_user, (kb_addr_t *)arg, sizeof(kb_addr_t)))
+				return -EFAULT;
+			break;
+		}
+		case KB_IOCTL_ENCR:
+		{
+			kb_operation_t op;
+
+			if (copy_from_user(&op, (kb_operation_t *)arg, sizeof(kb_operation_t)))
+				return -EFAULT;
+			op.returned = kb_encr(&op);
+
+			if (copy_to_user((kb_operation_t *)arg, &op, sizeof(kb_operation_t)))
+				return -EFAULT;
+			break;
+		}
+		case KB_IOCTL_DECR:
+		{
+			kb_operation_t op;
+
+			if (copy_from_user(&op, (kb_operation_t *)arg, sizeof(kb_operation_t)))
+				return -EFAULT;
+			op.returned = kb_decr(&op);
+
+			if (copy_to_user((kb_operation_t *)arg, &op, sizeof(kb_operation_t)))
+				return -EFAULT;
+			break;
+		}
+		default:
+		    break;
+	}
+
+	return errval;
+}
+
+static int kb_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		printk(KERN_ERR
+				"mmap failed!\n");
+		return -ENOBUFS;
+	}
+	return 0;
+}
+
+static int kb_open(struct inode *inode, struct file *file)
+{
+	int errval = 0;
+
+	return errval;
+}
+
+static int kb_release(struct inode *inode, struct file *file)
+{
+	int errval = 0;
+
+	return errval;
+}
+
+static const struct file_operations kb_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = kb_ioctl,
+	.mmap = kb_mmap,
+	.open = kb_open,
+	.release = kb_release,
+};
+
+static int __init key_blob_init(void)
+{
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+
+	struct attribute **attrs;
+	int ret;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	of_node_get(dev_node);
+
+	kb_addr.key_addr = devm_kzalloc(&pdev->dev, KEY_MAX_LENGTH, GFP_KERNEL | GFP_DMA);
+	if (!kb_addr.key_addr)
+		return -ENOMEM;
+	kb_addr.blob_addr = devm_kzalloc(&pdev->dev, KEY_MAX_LENGTH + BLOB_OVERHEAD, GFP_KERNEL | GFP_DMA);
+	if (!kb_addr.blob_addr)
+		return -ENOMEM;
+
+	/* The last one is NULL, which is used to detect the end */
+	attrs = devm_kzalloc(&pdev->dev, 3 * sizeof(*attrs),
+			     GFP_KERNEL);
+	kb_kattr = devm_kzalloc(&pdev->dev, 2 * sizeof(*kb_kattr),
+				 GFP_KERNEL);
+	kb_attr_group = devm_kzalloc(&pdev->dev, sizeof(*kb_attr_group),
+				      GFP_KERNEL);
+	if (!attrs || !kb_kattr || !kb_attr_group)
+		return -ENOMEM;
+
+	sysfs_attr_init(kb_kattr[0].attr);
+	kb_kattr[0].attr.name = "encap";
+	kb_kattr[0].attr.mode = 0600;
+	kb_kattr[0].show = NULL;
+	kb_kattr[0].store = kb_encap_mfg;
+	attrs[0] = &kb_kattr[0].attr;
+
+	sysfs_attr_init(kb_kattr[1].attr);
+	kb_kattr[1].attr.name = "decap";
+	kb_kattr[1].attr.mode = 0600;
+	kb_kattr[1].show = NULL;
+	kb_kattr[1].store = kb_decap_mfg;
+	attrs[1] = &kb_kattr[1].attr;
+
+	kb_attr_group->attrs = attrs;
+
+	kb_kobj = kobject_create_and_add("kb", NULL);
+	if (!kb_kobj) {
+		dev_err(&pdev->dev, "failed to add kobject\n");
+		return -ENOMEM;
+	}
+
+	ret = sysfs_create_group(kb_kobj, kb_attr_group);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to create sysfs group: %d\n", ret);
+		kobject_put(kb_kobj);
+		return ret;
+	}
+
+	kb_major = register_chrdev(0, "kb", &kb_fops);
+	if (kb_major < 0) {
+		printk("KB: Unable to register driver\n");
+		return -ENODEV;
+	}
+	kb_class = class_create(THIS_MODULE, "kb");
+	if (IS_ERR(kb_class)) {
+		printk("KB: Unable to create class\n");
+		unregister_chrdev(kb_major, "kb");
+		return PTR_ERR(kb_class);
+	}
+	device_create(kb_class, NULL, MKDEV(kb_major, 0), NULL, "kb");
+
+	return 0;
+}
+
+static void __exit key_blob_exit(void)
+{
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return;
+
+	of_node_put(dev_node);
+
+	devm_kfree(&pdev->dev, kb_addr.key_addr);
+	devm_kfree(&pdev->dev, kb_addr.blob_addr);
+
+	sysfs_remove_group(kb_kobj, kb_attr_group);
+	kobject_put(kb_kobj);
+
+	device_destroy(kb_class, MKDEV(kb_major, 0));
+	class_destroy(kb_class);
+	unregister_chrdev(kb_major, "kb");
+
+	return;
+}
+
+module_init(key_blob_init);
+module_exit(key_blob_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FSL CAAM KEY BLOB");
+MODULE_AUTHOR("Freescale Semiconductor - MCU");
diff --git a/drivers/crypto/caam/key_blob.h b/drivers/crypto/caam/key_blob.h
new file mode 100644
index 0000000..ceb14d1
--- /dev/null
+++ b/drivers/crypto/caam/key_blob.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef KEY_BLOB_H
+#define KEY_BLOB_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+typedef struct {
+	uint32_t key_len;
+	uint32_t key_color;
+	uint32_t key_cover;
+	uint32_t blob_len;
+}kb_parameter_t;
+
+typedef struct {
+	uint32_t key_len;
+	uint32_t key_color;
+	uint32_t key_cover;
+	uint32_t blob_len;
+	uint8_t buffer[16];
+	uint8_t returned;
+}kb_operation_t;
+
+typedef struct {
+	uint8_t *key_addr;
+	uint8_t *blob_addr;
+}kb_addr_t;
+
+#define KB_IOCTL_ENCAP			_IOWR('K', 0, kb_parameter_t)
+#define KB_IOCTL_DECAP			_IOWR('K', 1, kb_parameter_t)
+#define KB_IOCTL_SEND_VRT_ADDR	_IOR('K', 2, kb_addr_t)
+#define KB_IOCTL_ENCR           _IOWR('K', 3, kb_operation_t)
+#define KB_IOCTL_DECR           _IOWR('K', 4, kb_operation_t)
+
+#endif /* KEY_BLOB_H */
diff --git a/drivers/crypto/caam/sm.h b/drivers/crypto/caam/sm.h
index 65ec9d7..43fd823 100644
--- a/drivers/crypto/caam/sm.h
+++ b/drivers/crypto/caam/sm.h
@@ -7,33 +7,19 @@
 #ifndef SM_H
 #define SM_H

+#include "caam_desc.h"

 /* Storage access permissions */
 #define SM_PERM_READ 0x01
 #define SM_PERM_WRITE 0x02
 #define SM_PERM_BLOB 0x03

-/* Define treatment of secure memory vs. general memory blobs */
-#define SM_SECMEM 0
-#define SM_GENMEM 1
-
-/* Define treatment of red/black keys */
-#define RED_KEY 0
-#define BLACK_KEY 1
-
-/* Define key encryption/covering options */
-#define KEY_COVER_ECB 0	/* cover key in AES-ECB */
-#define KEY_COVER_CCM 1 /* cover key with AES-CCM */
-
 /*
  * Round a key size up to an AES blocksize boundary so to allow for
  * padding out to a full block
  */
 #define AES_BLOCK_PAD(x) ((x % 16) ? ((x >> 4) + 1) << 4 : x)

-/* Define space required for BKEK + MAC tag storage in any blob */
-#define BLOB_OVERHEAD (32 + 16)
-
 /* Keystore maintenance functions */
 void sm_init_keystore(struct device *dev);
 u32 sm_detect_keystore_units(struct device *dev);
@@ -50,22 +36,9 @@ extern int sm_keystore_slot_load(struct device *dev, u32 unit, u32 slot,
 				 const u8 *key_data, u32 key_length);
 extern int sm_keystore_slot_read(struct device *dev, u32 unit, u32 slot,
 				 u32 key_length, u8 *key_data);
-extern int sm_keystore_cover_key(struct device *dev, u32 unit, u32 slot,
-				 u16 key_length, u8 keyauth);
-extern int sm_keystore_slot_export(struct device *dev, u32 unit, u32 slot,
-				   u8 keycolor, u8 keyauth, u8 *outbuf,
-				   u16 keylen, u8 *keymod);
-extern int sm_keystore_slot_import(struct device *dev, u32 unit, u32 slot,
-				   u8 keycolor, u8 keyauth, u8 *inbuf,
-				   u16 keylen, u8 *keymod);
-
-/* Prior functions from legacy API, deprecated */
-extern int sm_keystore_slot_encapsulate(struct device *dev, u32 unit,
-					u32 inslot, u32 outslot, u16 secretlen,
-					u8 *keymod, u16 keymodlen);
-extern int sm_keystore_slot_decapsulate(struct device *dev, u32 unit,
-					u32 inslot, u32 outslot, u16 secretlen,
-					u8 *keymod, u16 keymodlen);
+extern void *sm_keystore_get_slot_phys_addr(struct device *dev,
+					    u32 unit, u32 slot);
+extern u32 sm_keystore_get_slot_size(struct device *dev, u32 unit, u32 slot);

 /* Data structure to hold per-slot information */
 struct keystore_data_slot_info {
diff --git a/drivers/crypto/caam/sm_store.c b/drivers/crypto/caam/sm_store.c
index df18f1b..b7f38a1 100644
--- a/drivers/crypto/caam/sm_store.c
+++ b/drivers/crypto/caam/sm_store.c
@@ -31,16 +31,11 @@

 #include "compat.h"
 #include "regs.h"
-#include "jr.h"
-#include "desc.h"
 #include "intern.h"
-#include "error.h"
 #include "sm.h"
+#include "jr.h"
 #include <linux/of_address.h>

-#define SECMEM_KEYMOD_LEN 8
-#define GENMEM_KEYMOD_LEN 16
-
 #ifdef SM_DEBUG_CONT
 void sm_show_page(struct device *dev, struct sm_page_descriptor *pgdesc)
 {
@@ -57,8 +52,6 @@ void sm_show_page(struct device *dev, struct sm_page_descriptor *pgdesc)
 }
 #endif

-#define INITIAL_DESCSZ 16	/* size of tmp buffer for descriptor const. */
-
 static __always_inline u32 sm_send_cmd(struct caam_drv_private_sm *smpriv,
 					     struct caam_drv_private_jr *jrpriv,
 					     u32 cmd, u32 *status)
@@ -96,359 +89,6 @@ static __always_inline u32 sm_send_cmd(struct caam_drv_private_sm *smpriv,

 	return 0;
 }
-/*
- * Construct a black key conversion job descriptor
- *
- * This function constructs a job descriptor capable of performing
- * a key blackening operation on a plaintext secure memory resident object.
- *
- * - desc	pointer to a pointer to the descriptor generated by this
- *		function. Caller will be responsible to kfree() this
- *		descriptor after execution.
- * - key	physical pointer to the plaintext, which will also hold
- *		the result. Since encryption occurs in place, caller must
- *              ensure that the space is large enough to accommodate the
- *              blackened key
- * - keysz	size of the plaintext
- * - auth	if a CCM-covered key is required, use KEY_COVER_CCM, else
- *		use KEY_COVER_ECB.
- *
- * KEY to key1 from @key_addr LENGTH 16 BYTES;
- * FIFO STORE from key1[ecb] TO @key_addr LENGTH 16 BYTES;
- *
- * Note that this variant uses the JDKEK only; it does not accommodate the
- * trusted key encryption key at this time.
- *
- */
-static int blacken_key_jobdesc(u32 **desc, void *key, u16 keysz, bool auth)
-{
-	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
-	u16 dsize, idx;
-
-	memset(tmpdesc, 0, INITIAL_DESCSZ * sizeof(u32));
-	idx = 1;
-
-	/* Load key to class 1 key register */
-	tmpdesc[idx++] = CMD_KEY | CLASS_1 | (keysz & KEY_LENGTH_MASK);
-	tmpdesc[idx++] = (uintptr_t)key;
-
-	/* ...and write back out via FIFO store*/
-	tmpdesc[idx] = CMD_FIFO_STORE | CLASS_1 | (keysz & KEY_LENGTH_MASK);
-
-	/* plus account for ECB/CCM option in FIFO_STORE */
-	if (auth == KEY_COVER_ECB)
-		tmpdesc[idx] |= FIFOST_TYPE_KEY_KEK;
-	else
-		tmpdesc[idx] |= FIFOST_TYPE_KEY_CCM_JKEK;
-
-	idx++;
-	tmpdesc[idx++] = (uintptr_t)key;
-
-	/* finish off the job header */
-	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
-	dsize = idx * sizeof(u32);
-
-	/* now allocate execution buffer and coat it with executable */
-	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
-	if (tdesc == NULL)
-		return 0;
-
-	memcpy(tdesc, tmpdesc, dsize);
-	*desc = tdesc;
-
-	return dsize;
-}
-
-/*
- * Construct a blob encapsulation job descriptor
- *
- * This function dynamically constructs a blob encapsulation job descriptor
- * from the following arguments:
- *
- * - desc	pointer to a pointer to the descriptor generated by this
- *		function. Caller will be responsible to kfree() this
- *		descriptor after execution.
- * - keymod	Physical pointer to a key modifier, which must reside in a
- *		contiguous piece of memory. Modifier will be assumed to be
- *		8 bytes long for a blob of type SM_SECMEM, or 16 bytes long
- *		for a blob of type SM_GENMEM (see blobtype argument).
- * - secretbuf	Physical pointer to a secret, normally a black or red key,
- *		possibly residing within an accessible secure memory page,
- *		of the secret to be encapsulated to an output blob.
- * - outbuf	Physical pointer to the destination buffer to receive the
- *		encapsulated output. This buffer will need to be 48 bytes
- *		larger than the input because of the added encapsulation data.
- *		The generated descriptor will account for the increase in size,
- *		but the caller must also account for this increase in the
- *		buffer allocator.
- * - secretsz	Size of input secret, in bytes. This is limited to 65536
- *		less the size of blob overhead, since the length embeds into
- *		DECO pointer in/out instructions.
- * - keycolor   Determines if the source data is covered (black key) or
- *		plaintext (red key). RED_KEY or BLACK_KEY are defined in
- *		for this purpose.
- * - blobtype	Determine if encapsulated blob should be a secure memory
- *		blob (SM_SECMEM), with partition data embedded with key
- *		material, or a general memory blob (SM_GENMEM).
- * - auth	If BLACK_KEY source is covered via AES-CCM, specify
- *		KEY_COVER_CCM, else uses AES-ECB (KEY_COVER_ECB).
- *
- * Upon completion, desc points to a buffer containing a CAAM job
- * descriptor which encapsulates data into an externally-storable blob
- * suitable for use across power cycles.
- *
- * This is an example of a black key encapsulation job into a general memory
- * blob. Notice the 16-byte key modifier in the LOAD instruction. Also note
- * the output 48 bytes longer than the input:
- *
- * [00] B0800008       jobhdr: stidx=0 len=8
- * [01] 14400010           ld: ccb2-key len=16 offs=0
- * [02] 08144891               ptr->@0x08144891
- * [03] F800003A    seqoutptr: len=58
- * [04] 01000000               out_ptr->@0x01000000
- * [05] F000000A     seqinptr: len=10
- * [06] 09745090               in_ptr->@0x09745090
- * [07] 870D0004    operation: encap blob  reg=memory, black, format=normal
- *
- * This is an example of a red key encapsulation job for storing a red key
- * into a secure memory blob. Note the 8 byte modifier on the 12 byte offset
- * in the LOAD instruction; this accounts for blob permission storage:
- *
- * [00] B0800008       jobhdr: stidx=0 len=8
- * [01] 14400C08           ld: ccb2-key len=8 offs=12
- * [02] 087D0784               ptr->@0x087d0784
- * [03] F8000050    seqoutptr: len=80
- * [04] 09251BB2               out_ptr->@0x09251bb2
- * [05] F0000020     seqinptr: len=32
- * [06] 40000F31               in_ptr->@0x40000f31
- * [07] 870D0008    operation: encap blob  reg=memory, red, sec_mem,
- *                             format=normal
- *
- * Note: this function only generates 32-bit pointers at present, and should
- * be refactored using a scheme that allows both 32 and 64 bit addressing
- */
-
-static int blob_encap_jobdesc(u32 **desc, dma_addr_t keymod,
-			      void *secretbuf, dma_addr_t outbuf,
-			      u16 secretsz, u8 keycolor, u8 blobtype, u8 auth)
-{
-	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
-	u16 dsize, idx;
-
-	memset(tmpdesc, 0, INITIAL_DESCSZ * sizeof(u32));
-	idx = 1;
-
-	/*
-	 * Key modifier works differently for secure/general memory blobs
-	 * This accounts for the permission/protection data encapsulated
-	 * within the blob if a secure memory blob is requested
-	 */
-	if (blobtype == SM_SECMEM)
-		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
-				 LDST_SRCDST_BYTE_KEY |
-				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
-				 | (8 & LDST_LEN_MASK);
-	else /* is general memory blob */
-		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
-				 LDST_SRCDST_BYTE_KEY | (16 & LDST_LEN_MASK);
-
-	tmpdesc[idx++] = (u32)keymod;
-
-	/*
-	 * Encapsulation output must include space for blob key encryption
-	 * key and MAC tag
-	 */
-	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | (secretsz + BLOB_OVERHEAD);
-	tmpdesc[idx++] = (u32)outbuf;
-
-	/* Input data, should be somewhere in secure memory */
-	tmpdesc[idx++] = CMD_SEQ_IN_PTR | secretsz;
-	tmpdesc[idx++] = (uintptr_t)secretbuf;
-
-	/* Set blob encap, then color */
-	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_ENCAP_PROTOCOL | OP_PCLID_BLOB;
-
-	if (blobtype == SM_SECMEM)
-		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;
-
-	if (auth == KEY_COVER_CCM)
-		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
-
-	if (keycolor == BLACK_KEY)
-		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;
-
-	idx++;
-	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
-	dsize = idx * sizeof(u32);
-
-	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
-	if (tdesc == NULL)
-		return 0;
-
-	memcpy(tdesc, tmpdesc, dsize);
-	*desc = tdesc;
-	return dsize;
-}
-
-/*
- * Construct a blob decapsulation job descriptor
- *
- * This function dynamically constructs a blob decapsulation job descriptor
- * from the following arguments:
- *
- * - desc	pointer to a pointer to the descriptor generated by this
- *		function. Caller will be responsible to kfree() this
- *		descriptor after execution.
- * - keymod	Physical pointer to a key modifier, which must reside in a
- *		contiguous piece of memory. Modifier will be assumed to be
- *		8 bytes long for a blob of type SM_SECMEM, or 16 bytes long
- *		for a blob of type SM_GENMEM (see blobtype argument).
- * - blobbuf	Physical pointer (into external memory) of the blob to
- *		be decapsulated. Blob must reside in a contiguous memory
- *		segment.
- * - outbuf	Physical pointer of the decapsulated output, possibly into
- *		a location within a secure memory page. Must be contiguous.
- * - secretsz	Size of encapsulated secret in bytes (not the size of the
- *		input blob).
- * - keycolor   Determines if decapsulated content is encrypted (BLACK_KEY)
- *		or left as plaintext (RED_KEY).
- * - blobtype	Determine if encapsulated blob should be a secure memory
- *		blob (SM_SECMEM), with partition data embedded with key
- *		material, or a general memory blob (SM_GENMEM).
- * - auth	If decapsulation path is specified by BLACK_KEY, then if
- *		AES-CCM is requested for key covering use KEY_COVER_CCM, else
- *		use AES-ECB (KEY_COVER_ECB).
- *
- * Upon completion, desc points to a buffer containing a CAAM job descriptor
- * that decapsulates a key blob from external memory into a black (encrypted)
- * key or red (plaintext) content.
- *
- * This is an example of a black key decapsulation job from a general memory
- * blob. Notice the 16-byte key modifier in the LOAD instruction.
- *
- * [00] B0800008       jobhdr: stidx=0 len=8
- * [01] 14400010           ld: ccb2-key len=16 offs=0
- * [02] 08A63B7F               ptr->@0x08a63b7f
- * [03] F8000010    seqoutptr: len=16
- * [04] 01000000               out_ptr->@0x01000000
- * [05] F000003A     seqinptr: len=58
- * [06] 01000010               in_ptr->@0x01000010
- * [07] 860D0004    operation: decap blob  reg=memory, black, format=normal
- *
- * This is an example of a red key decapsulation job for restoring a red key
- * from a secure memory blob. Note the 8 byte modifier on the 12 byte offset
- * in the LOAD instruction:
- *
- * [00] B0800008       jobhdr: stidx=0 len=8
- * [01] 14400C08           ld: ccb2-key len=8 offs=12
- * [02] 01000000               ptr->@0x01000000
- * [03] F8000020    seqoutptr: len=32
- * [04] 400000E6               out_ptr->@0x400000e6
- * [05] F0000050     seqinptr: len=80
- * [06] 08F0C0EA               in_ptr->@0x08f0c0ea
- * [07] 860D0008    operation: decap blob  reg=memory, red, sec_mem,
- *			       format=normal
- *
- * Note: this function only generates 32-bit pointers at present, and should
- * be refactored using a scheme that allows both 32 and 64 bit addressing
- */
-
-static int blob_decap_jobdesc(u32 **desc, dma_addr_t keymod, dma_addr_t blobbuf,
-			      u8 *outbuf, u16 secretsz, u8 keycolor,
-			      u8 blobtype, u8 auth)
-{
-	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
-	u16 dsize, idx;
-
-	memset(tmpdesc, 0, INITIAL_DESCSZ * sizeof(u32));
-	idx = 1;
-
-	/* Load key modifier */
-	if (blobtype == SM_SECMEM)
-		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
-				 LDST_SRCDST_BYTE_KEY |
-				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
-				 | (8 & LDST_LEN_MASK);
-	else /* is general memory blob */
-		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
-				 LDST_SRCDST_BYTE_KEY | (16 & LDST_LEN_MASK);
-
-	tmpdesc[idx++] = (u32)keymod;
-
-	/* Compensate BKEK + MAC tag over size of encapsulated secret */
-	tmpdesc[idx++] = CMD_SEQ_IN_PTR | (secretsz + BLOB_OVERHEAD);
-	tmpdesc[idx++] = (u32)blobbuf;
-	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | secretsz;
-	tmpdesc[idx++] = (uintptr_t)outbuf;
-
-	/* Decapsulate from secure memory partition to black blob */
-	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_DECAP_PROTOCOL | OP_PCLID_BLOB;
-
-	if (blobtype == SM_SECMEM)
-		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;
-
-	if (auth == KEY_COVER_CCM)
-		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
-
-	if (keycolor == BLACK_KEY)
-		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;
-
-	idx++;
-	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
-	dsize = idx * sizeof(u32);
-
-	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
-	if (tdesc == NULL)
-		return 0;
-
-	memcpy(tdesc, tmpdesc, dsize);
-	*desc = tdesc;
-	return dsize;
-}
-
-/*
- * Pseudo-synchronous ring access functions for carrying out key
- * encapsulation and decapsulation
- */
-
-struct sm_key_job_result {
-	int error;
-	struct completion completion;
-};
-
-void sm_key_job_done(struct device *dev, u32 *desc, u32 err, void *context)
-{
-	struct sm_key_job_result *res = context;
-
-	if (err)
-		caam_jr_strstatus(dev, err);
-
-	res->error = err;	/* save off the error for postprocessing */
-
-	complete(&res->completion);	/* mark us complete */
-}
-
-static int sm_key_job(struct device *ksdev, u32 *jobdesc)
-{
-	struct sm_key_job_result testres = {0};
-	struct caam_drv_private_sm *kspriv;
-	int rtn = 0;
-
-	kspriv = dev_get_drvdata(ksdev);
-
-	init_completion(&testres.completion);
-
-	rtn = caam_jr_enqueue(kspriv->smringdev, jobdesc, sm_key_job_done,
-			      &testres);
-	if (rtn)
-		goto exit;
-
-	wait_for_completion_interruptible(&testres.completion);
-	rtn = testres.error;
-
-exit:
-	return rtn;
-}

 /*
  * Following section establishes the default methods for keystore access
@@ -602,7 +242,6 @@ u32 slot_get_slot_size(struct device *dev, u32 unit, u32 slot)
 int kso_init_data(struct device *dev, u32 unit)
 {
 	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
-	int retval = -EINVAL;
 	struct keystore_data *keystore_data = NULL;
 	u32 slot_count;
 	u32 keystore_data_size;
@@ -622,10 +261,8 @@ int kso_init_data(struct device *dev, u32 unit)

 	keystore_data = kzalloc(keystore_data_size, GFP_KERNEL);

-	if (keystore_data == NULL) {
-		retval = -ENOSPC;
-		goto out;
-	}
+	if (!keystore_data)
+		return -ENOMEM;

 #ifdef SM_DEBUG
 	dev_info(dev, "kso_init_data: keystore data size = %d\n",
@@ -646,15 +283,7 @@ int kso_init_data(struct device *dev, u32 unit)
 	smpriv->pagedesc[unit].ksdata->phys_address =
 		smpriv->pagedesc[unit].pg_phys;

-	retval = 0;
-
-out:
-	if (retval != 0)
-		if (keystore_data != NULL)
-			kfree(keystore_data);
-
-
-	return retval;
+	return 0;
 }

 void kso_cleanup_data(struct device *dev, u32 unit)
@@ -835,220 +464,41 @@ int sm_keystore_slot_read(struct device *dev, u32 unit, u32 slot,
 }
 EXPORT_SYMBOL(sm_keystore_slot_read);

-/*
- * Blacken a clear key in a slot. Operates "in place".
- * Limited to class 1 keys at the present time
- */
-int sm_keystore_cover_key(struct device *dev, u32 unit, u32 slot,
-			  u16 key_length, u8 keyauth)
-{
-	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
-	int retval = 0;
-	u8 __iomem *slotaddr;
-	void *slotphys;
-	u32 dsize, jstat;
-	u32 __iomem *coverdesc = NULL;
-
-	/* Get the address of the object in the slot */
-	slotaddr = (u8 *)smpriv->slot_get_address(dev, unit, slot);
-	slotphys = (u8 *)smpriv->slot_get_physical(dev, unit, slot);
-
-	dsize = blacken_key_jobdesc(&coverdesc, slotphys, key_length, keyauth);
-	if (!dsize)
-		return -ENOMEM;
-	jstat = sm_key_job(dev, coverdesc);
-	if (jstat)
-		retval = -EIO;
-
-	kfree(coverdesc);
-	return retval;
-}
-EXPORT_SYMBOL(sm_keystore_cover_key);
-
-/* Export a black/red key to a blob in external memory */
-int sm_keystore_slot_export(struct device *dev, u32 unit, u32 slot, u8 keycolor,
-			    u8 keyauth, u8 *outbuf, u16 keylen, u8 *keymod)
+void *sm_keystore_get_slot_phys_addr(struct device *dev, u32 unit, u32 slot)
 {
+	void *retval = NULL;
 	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
-	int retval = 0;
-	u8 __iomem *slotaddr, *lkeymod;
-	u8 __iomem *slotphys;
-	dma_addr_t keymod_dma, outbuf_dma;
-	u32 dsize, jstat;
-	u32 __iomem *encapdesc = NULL;
-	struct device *dev_for_dma_op;
-
-	/* Use the ring as device for DMA operations */
-	dev_for_dma_op = smpriv->smringdev;
-
-	/* Get the base address(es) of the specified slot */
-	slotaddr = (u8 *)smpriv->slot_get_address(dev, unit, slot);
-	slotphys = smpriv->slot_get_physical(dev, unit, slot);
-
-	/* Allocate memory for key modifier compatible with DMA */
-	lkeymod = kmalloc(SECMEM_KEYMOD_LEN, GFP_KERNEL | GFP_DMA);
-	if (!lkeymod) {
-		retval = (-ENOMEM);
-		goto exit;
-	}
-
-	/* Get DMA address for the key modifier */
-	keymod_dma = dma_map_single(dev_for_dma_op, lkeymod,
-					SECMEM_KEYMOD_LEN, DMA_TO_DEVICE);
-	if (dma_mapping_error(dev_for_dma_op, keymod_dma)) {
-		dev_err(dev, "unable to map keymod: %p\n", lkeymod);
-		retval = (-ENOMEM);
-		goto free_keymod;
-	}
-
-	/* Copy the keymod and synchronize the DMA */
-	memcpy(lkeymod, keymod, SECMEM_KEYMOD_LEN);
-	dma_sync_single_for_device(dev_for_dma_op, keymod_dma,
-					SECMEM_KEYMOD_LEN, DMA_TO_DEVICE);
-
-	/* Get DMA address for the destination */
-	outbuf_dma = dma_map_single(dev_for_dma_op, outbuf,
-				keylen + BLOB_OVERHEAD, DMA_FROM_DEVICE);
-	if (dma_mapping_error(dev_for_dma_op, outbuf_dma)) {
-		dev_err(dev, "unable to map outbuf: %p\n", outbuf);
-		retval = (-ENOMEM);
-		goto unmap_keymod;
-	}
-
-	/* Build the encapsulation job descriptor */
-	dsize = blob_encap_jobdesc(&encapdesc, keymod_dma, slotphys, outbuf_dma,
-				   keylen, keycolor, SM_SECMEM, keyauth);
-	if (!dsize) {
-		dev_err(dev, "can't alloc an encapsulation descriptor\n");
-		retval = -ENOMEM;
-		goto unmap_outbuf;
-	}
-
-	/* Run the job */
-	jstat = sm_key_job(dev, encapdesc);
-	if (jstat) {
-		retval = (-EIO);
-		goto free_desc;
-	}

-	/* Synchronize the data received */
-	dma_sync_single_for_cpu(dev_for_dma_op, outbuf_dma,
-			keylen + BLOB_OVERHEAD, DMA_FROM_DEVICE);
-
-free_desc:
-	kfree(encapdesc);
-
-unmap_outbuf:
-	dma_unmap_single(dev_for_dma_op, outbuf_dma, keylen + BLOB_OVERHEAD,
-			DMA_FROM_DEVICE);
+	spin_lock(&smpriv->kslock);

-unmap_keymod:
-	dma_unmap_single(dev_for_dma_op, keymod_dma, SECMEM_KEYMOD_LEN,
-			DMA_TO_DEVICE);
+	if (!smpriv->slot_get_physical)
+		goto out;

-free_keymod:
-	kfree(lkeymod);
+	retval = smpriv->slot_get_physical(dev, unit, slot);

-exit:
+out:
+	spin_unlock(&smpriv->kslock);
 	return retval;
 }
-EXPORT_SYMBOL(sm_keystore_slot_export);
+EXPORT_SYMBOL(sm_keystore_get_slot_phys_addr);

-/* Import a black/red key from a blob residing in external memory */
-int sm_keystore_slot_import(struct device *dev, u32 unit, u32 slot, u8 keycolor,
-			    u8 keyauth, u8 *inbuf, u16 keylen, u8 *keymod)
+u32 sm_keystore_get_slot_size(struct device *dev, u32 unit, u32 slot)
 {
-	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
 	int retval = 0;
-	u8 __iomem *slotaddr, *lkeymod;
-	u8 __iomem *slotphys;
-	dma_addr_t keymod_dma, inbuf_dma;
-	u32 dsize, jstat;
-	u32 __iomem *decapdesc = NULL;
-	struct device *dev_for_dma_op;
-
-	/* Use the ring as device for DMA operations */
-	dev_for_dma_op = smpriv->smringdev;
-
-	/* Get the base address(es) of the specified slot */
-	slotaddr = (u8 *)smpriv->slot_get_address(dev, unit, slot);
-	slotphys = smpriv->slot_get_physical(dev, unit, slot);
-
-	/* Allocate memory for key modifier compatible with DMA */
-	lkeymod = kmalloc(SECMEM_KEYMOD_LEN, GFP_KERNEL | GFP_DMA);
-	if (!lkeymod) {
-		retval = (-ENOMEM);
-		goto exit;
-	}
-
-	/* Get DMA address for the key modifier */
-	keymod_dma = dma_map_single(dev_for_dma_op, lkeymod,
-					SECMEM_KEYMOD_LEN, DMA_TO_DEVICE);
-	if (dma_mapping_error(dev_for_dma_op, keymod_dma)) {
-		dev_err(dev, "unable to map keymod: %p\n", lkeymod);
-		retval = (-ENOMEM);
-		goto free_keymod;
-	}
-
-	/* Copy the keymod and synchronize the DMA */
-	memcpy(lkeymod, keymod, SECMEM_KEYMOD_LEN);
-	dma_sync_single_for_device(dev_for_dma_op, keymod_dma,
-					SECMEM_KEYMOD_LEN, DMA_TO_DEVICE);
-
-	/* Get DMA address for the input */
-	inbuf_dma = dma_map_single(dev_for_dma_op, inbuf,
-					keylen + BLOB_OVERHEAD, DMA_TO_DEVICE);
-	if (dma_mapping_error(dev_for_dma_op, inbuf_dma)) {
-		dev_err(dev, "unable to map inbuf: %p\n", (void *)inbuf_dma);
-		retval = (-ENOMEM);
-		goto unmap_keymod;
-	}
-
-	/* synchronize the DMA */
-	dma_sync_single_for_device(dev_for_dma_op, inbuf_dma,
-					keylen + BLOB_OVERHEAD, DMA_TO_DEVICE);
-
-	/* Build the encapsulation job descriptor */
-	dsize = blob_decap_jobdesc(&decapdesc, keymod_dma, inbuf_dma, slotphys,
-				   keylen, keycolor, SM_SECMEM, keyauth);
-	if (!dsize) {
-		dev_err(dev, "can't alloc a decapsulation descriptor\n");
-		retval = -ENOMEM;
-		goto unmap_inbuf;
-	}
-
-	/* Run the job */
-	jstat = sm_key_job(dev, decapdesc);
-
-	/*
-	 * May want to expand upon error meanings a bit. Any CAAM status
-	 * is reported as EIO, but we might want to look for something more
-	 * meaningful for something like an ICV error on restore, otherwise
-	 * the caller is left guessing.
-	 */
-	if (jstat) {
-		retval = (-EIO);
-		goto free_desc;
-	}
-
-free_desc:
-	kfree(decapdesc);
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);

-unmap_inbuf:
-	dma_unmap_single(dev_for_dma_op, inbuf_dma, keylen + BLOB_OVERHEAD,
-			DMA_TO_DEVICE);
+	spin_lock(&smpriv->kslock);

-unmap_keymod:
-	dma_unmap_single(dev_for_dma_op, keymod_dma, SECMEM_KEYMOD_LEN,
-			DMA_TO_DEVICE);
+	if (!smpriv->slot_get_slot_size)
+		goto out;

-free_keymod:
-	kfree(lkeymod);
+	retval = smpriv->slot_get_slot_size(dev, unit, slot);

-exit:
+out:
+	spin_unlock(&smpriv->kslock);
 	return retval;
 }
-EXPORT_SYMBOL(sm_keystore_slot_import);
+EXPORT_SYMBOL(sm_keystore_get_slot_size);

 /*
  * Initialization/shutdown subsystem
@@ -1165,7 +615,7 @@ int caam_sm_startup(struct platform_device *pdev)
 	 * an SM instance to any ring instance).
 	 */
 	smpriv->smringdev = caam_jr_alloc();
-	if (!smpriv->smringdev) {
+	if (IS_ERR(smpriv->smringdev)) {
 		dev_err(smdev, "Device for job ring not created\n");
 		ret = -ENODEV;
 		goto unregister_smpdev;
@@ -1308,8 +758,6 @@ static void  __exit caam_sm_exit(void)
 	of_node_put(dev_node);

 	caam_sm_shutdown(pdev);
-
-	return;
 }

 static int __init caam_sm_init(void)
diff --git a/drivers/crypto/caam/sm_test.c b/drivers/crypto/caam/sm_test.c
index 99b1421..57c0d3d 100644
--- a/drivers/crypto/caam/sm_test.c
+++ b/drivers/crypto/caam/sm_test.c
@@ -27,6 +27,13 @@
 #include "error.h"
 #include "jr.h"
 #include "sm.h"
+#include "caam_desc.h"
+#include "caam_util.h"
+
+#define SECMEM_KEYMOD_LEN 8
+#define GENMEM_KEYMOD_LEN 16
+
+#define INITIAL_DESCSZ 16	/* size of tmp buffer for descriptor const. */

 /* Fixed known pattern for a key modifier */
 static u8 skeymod[] = {
@@ -70,9 +77,142 @@ static u8 clrkey[] = {
 	0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
 };

+/*
+ * Blacken a clear key in a slot. Operates "in place".
+ * Limited to class 1 keys at the present time
+ */
+static int sm_keystore_cover_key(struct device *dev, u32 unit, u32 slot,
+				 u16 key_length, u8 keyauth)
+{
+	int retval = 0;
+	struct device *jrdev;
+	void *slotphys;
+	size_t black_key_length;
+
+	if (!dev)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(dev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	black_key_length = sm_keystore_get_slot_size(dev, unit, slot);
+	if (!black_key_length) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_black_key(jrdev,
+				slotphys, key_length, DATA_SECMEM,
+				slotphys, &black_key_length, DATA_SECMEM,
+				keyauth, UNTRUSTED_KEY);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
+/* Export a black/red key to a blob in external memory */
+static int sm_keystore_slot_export(struct device *ksdev, u32 unit, u32 slot,
+				   u8 keycolor, u8 keyauth,
+				   u8 *outbuf, u16 keylen, u8 *keymod)
+{
+	struct device *jrdev;
+	int retval = 0;
+	u8 __iomem *slotphys;
+	size_t blob_len;
+	size_t keymod_len = KEYMOD_SIZE_SM;
+	u8 blob_color = (keycolor == BLACK_KEY) ? BLACK_BLOB : RED_BLOB;
+
+	if (!ksdev || !outbuf || !keymod)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(ksdev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	blob_len = sm_keystore_get_slot_size(ksdev, unit, slot);
+	if (!blob_len) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_blob_encap(jrdev,
+				 slotphys, keylen, DATA_SECMEM,
+				 keycolor, keylen,
+				 keyauth, UNTRUSTED_KEY,
+				 keymod, &keymod_len, DATA_GENMEM,
+				 outbuf, &blob_len,
+				 DATA_GENMEM, blob_color);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
+/* Import a black/red key from a blob residing in external memory */
+static int sm_keystore_slot_import(struct device *ksdev, u32 unit, u32 slot,
+				   u8 keycolor, u8 keyauth,
+				   u8 *inbuf, u16 keylen, u8 *keymod)
+{
+	struct device *jrdev;
+	int retval = 0;
+	u8 __iomem *slotphys;
+	size_t keymod_len = KEYMOD_SIZE_SM;
+	size_t key_len;
+	size_t secret_size = 0;
+	u8 blob_color = (keycolor == BLACK_KEY) ? BLACK_BLOB : RED_BLOB;
+
+	if (!ksdev || !inbuf || !keymod)
+		return -EINVAL;
+
+	jrdev = caam_jr_alloc();
+	if (IS_ERR(jrdev))
+		return -ENOMEM;
+
+	slotphys = sm_keystore_get_slot_phys_addr(ksdev, unit, slot);
+	if (!slotphys) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	key_len = sm_keystore_get_slot_size(ksdev, unit, slot);
+	if (!key_len) {
+		retval = -ENOMEM;
+		goto free_jr;
+	}
+
+	retval = caam_blob_decap(jrdev,
+				 inbuf, keylen + BLOB_OVERHEAD,
+				 DATA_GENMEM, blob_color,
+				 keymod, &keymod_len, DATA_GENMEM,
+				 slotphys, &key_len, DATA_SECMEM,
+				 keycolor, &secret_size,
+				 keyauth, UNTRUSTED_KEY);
+
+free_jr:
+	caam_jr_free(jrdev);
+
+	return retval;
+}
+
 static void key_display(struct device *dev, u8 *label, u16 size, u8 *key)
 {
-	unsigned i;
+	int i;

 	dev_info(dev, label);
 	for (i = 0; i < size; i += 8)
@@ -88,7 +228,7 @@ int caam_sm_example_init(struct platform_device *pdev)
 	struct caam_drv_private *ctrlpriv;
 	struct caam_drv_private_sm *kspriv;
 	u32 unit, units;
-	int rtnval = 0;
+	int rtnval = -EIO;
 	u8 clrkey8[8], clrkey16[16], clrkey24[24], clrkey32[32];
 	u8 blkkey8[AES_BLOCK_PAD(8)], blkkey16[AES_BLOCK_PAD(16)];
 	u8 blkkey24[AES_BLOCK_PAD(24)], blkkey32[AES_BLOCK_PAD(32)];
@@ -176,16 +316,16 @@ int caam_sm_example_init(struct platform_device *pdev)
 	 * so pad them out.
 	 */
 	if (sm_keystore_slot_alloc(ksdev, unit, AES_BLOCK_PAD(8), &keyslot8))
-		goto dealloc;
+		goto freemem;

 	if (sm_keystore_slot_alloc(ksdev, unit, AES_BLOCK_PAD(16), &keyslot16))
-		goto dealloc;
+		goto dealloc_slot8;

 	if (sm_keystore_slot_alloc(ksdev, unit, AES_BLOCK_PAD(24), &keyslot24))
-		goto dealloc;
+		goto dealloc_slot16;

 	if (sm_keystore_slot_alloc(ksdev, unit, AES_BLOCK_PAD(32), &keyslot32))
-		goto dealloc;
+		goto dealloc_slot24;


 	/* Now load clear key data into the newly allocated slots */
@@ -208,22 +348,22 @@ int caam_sm_example_init(struct platform_device *pdev)
 	 * Cover keys in-place
 	 */
 	if (sm_keystore_cover_key(ksdev, unit, keyslot8, 8, KEY_COVER_ECB)) {
-		dev_info(ksdev, "blkkey_ex: can't cover 64-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't cover 64-bit key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_cover_key(ksdev, unit, keyslot16, 16, KEY_COVER_ECB)) {
-		dev_info(ksdev, "blkkey_ex: can't cover 128-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't cover 128-bit key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_cover_key(ksdev, unit, keyslot24, 24, KEY_COVER_ECB)) {
-		dev_info(ksdev, "blkkey_ex: can't cover 192-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't cover 192-bit key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_cover_key(ksdev, unit, keyslot32, 32, KEY_COVER_ECB)) {
-		dev_info(ksdev, "blkkey_ex: can't cover 256-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't cover 256-bit key\n");
 		goto dealloc;
 	}

@@ -239,46 +379,46 @@ int caam_sm_example_init(struct platform_device *pdev)

 	if (sm_keystore_slot_read(ksdev, unit, keyslot8, AES_BLOCK_PAD(8),
 				  blkkey8)) {
-		dev_info(ksdev, "blkkey_ex: can't read 64-bit black key\n");
+		dev_err(ksdev, "blkkey_ex: can't read 64-bit black key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_read(ksdev, unit, keyslot16, AES_BLOCK_PAD(16),
 				  blkkey16)) {
-		dev_info(ksdev, "blkkey_ex: can't read 128-bit black key\n");
+		dev_err(ksdev, "blkkey_ex: can't read 128-bit black key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_read(ksdev, unit, keyslot24, AES_BLOCK_PAD(24),
 				  blkkey24)) {
-		dev_info(ksdev, "blkkey_ex: can't read 192-bit black key\n");
+		dev_err(ksdev, "blkkey_ex: can't read 192-bit black key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_read(ksdev, unit, keyslot32, AES_BLOCK_PAD(32),
 				  blkkey32)) {
-		dev_info(ksdev, "blkkey_ex: can't read 256-bit black key\n");
+		dev_err(ksdev, "blkkey_ex: can't read 256-bit black key\n");
 		goto dealloc;
 	}


 	if (!memcmp(blkkey8, clrkey8, 8)) {
-		dev_info(ksdev, "blkkey_ex: 64-bit key cover failed\n");
+		dev_err(ksdev, "blkkey_ex: 64-bit key cover failed\n");
 		goto dealloc;
 	}

 	if (!memcmp(blkkey16, clrkey16, 16)) {
-		dev_info(ksdev, "blkkey_ex: 128-bit key cover failed\n");
+		dev_err(ksdev, "blkkey_ex: 128-bit key cover failed\n");
 		goto dealloc;
 	}

 	if (!memcmp(blkkey24, clrkey24, 24)) {
-		dev_info(ksdev, "blkkey_ex: 192-bit key cover failed\n");
+		dev_err(ksdev, "blkkey_ex: 192-bit key cover failed\n");
 		goto dealloc;
 	}

 	if (!memcmp(blkkey32, clrkey32, 32)) {
-		dev_info(ksdev, "blkkey_ex: 256-bit key cover failed\n");
+		dev_err(ksdev, "blkkey_ex: 256-bit key cover failed\n");
 		goto dealloc;
 	}

@@ -308,25 +448,25 @@ int caam_sm_example_init(struct platform_device *pdev)

 	if (sm_keystore_slot_export(ksdev, unit, keyslot8, BLACK_KEY,
 				    KEY_COVER_ECB, blob8, 8, skeymod)) {
-		dev_info(ksdev, "blkkey_ex: can't encapsulate 64-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't encapsulate 64-bit key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_export(ksdev, unit, keyslot16, BLACK_KEY,
 				    KEY_COVER_ECB, blob16, 16, skeymod)) {
-		dev_info(ksdev, "blkkey_ex: can't encapsulate 128-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't encapsulate 128-bit key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_export(ksdev, unit, keyslot24, BLACK_KEY,
 				    KEY_COVER_ECB, blob24, 24, skeymod)) {
-		dev_info(ksdev, "blkkey_ex: can't encapsulate 192-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't encapsulate 192-bit key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_export(ksdev, unit, keyslot32, BLACK_KEY,
 				    KEY_COVER_ECB, blob32, 32, skeymod)) {
-		dev_info(ksdev, "blkkey_ex: can't encapsulate 256-bit key\n");
+		dev_err(ksdev, "blkkey_ex: can't encapsulate 256-bit key\n");
 		goto dealloc;
 	}

@@ -345,25 +485,25 @@ int caam_sm_example_init(struct platform_device *pdev)
 	 */
 	if (sm_keystore_slot_import(ksdev, unit, keyslot8, BLACK_KEY,
 				    KEY_COVER_ECB, blob8, 8, skeymod)) {
-		dev_info(ksdev, "blkkey_ex: can't decapsulate 64-bit blob\n");
+		dev_err(ksdev, "blkkey_ex: can't decapsulate 64-bit blob\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_import(ksdev, unit, keyslot16, BLACK_KEY,
 				    KEY_COVER_ECB, blob16, 16, skeymod)) {
-		dev_info(ksdev, "blkkey_ex: can't decapsulate 128-bit blob\n");
+		dev_err(ksdev, "blkkey_ex: can't decapsulate 128-bit blob\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_import(ksdev, unit, keyslot24, BLACK_KEY,
 				    KEY_COVER_ECB, blob24, 24, skeymod)) {
-		dev_info(ksdev, "blkkey_ex: can't decapsulate 196-bit blob\n");
+		dev_err(ksdev, "blkkey_ex: can't decapsulate 196-bit blob\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_import(ksdev, unit, keyslot32, BLACK_KEY,
 				    KEY_COVER_ECB, blob32, 32, skeymod)) {
-		dev_info(ksdev, "blkkey_ex: can't decapsulate 256-bit blob\n");
+		dev_err(ksdev, "blkkey_ex: can't decapsulate 256-bit blob\n");
 		goto dealloc;
 	}

@@ -374,29 +514,29 @@ int caam_sm_example_init(struct platform_device *pdev)
 	 */
 	if (sm_keystore_slot_read(ksdev, unit, keyslot8, AES_BLOCK_PAD(8),
 				  rstkey8)) {
-		dev_info(ksdev,
+		dev_err(ksdev,
 			"blkkey_ex: can't read restored 64-bit black key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_read(ksdev, unit, keyslot16, AES_BLOCK_PAD(16),
 				  rstkey16)) {
-		dev_info(ksdev,
-			 "blkkey_ex: can't read restored 128-bit black key\n");
+		dev_err(ksdev,
+			"blkkey_ex: can't read restored 128-bit black key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_read(ksdev, unit, keyslot24, AES_BLOCK_PAD(24),
 				  rstkey24)) {
-		dev_info(ksdev,
-			 "blkkey_ex: can't read restored 196-bit black key\n");
+		dev_err(ksdev,
+			"blkkey_ex: can't read restored 196-bit black key\n");
 		goto dealloc;
 	}

 	if (sm_keystore_slot_read(ksdev, unit, keyslot32, AES_BLOCK_PAD(32),
 				  rstkey32)) {
-		dev_info(ksdev,
-			 "blkkey_ex: can't read restored 256-bit black key\n");
+		dev_err(ksdev,
+			"blkkey_ex: can't read restored 256-bit black key\n");
 		goto dealloc;
 	}

@@ -423,29 +563,32 @@ int caam_sm_example_init(struct platform_device *pdev)
 	 */

 	if (memcmp(rstkey16, blkkey16, AES_BLOCK_PAD(16))) {
-		dev_info(ksdev, "blkkey_ex: 128-bit restored key mismatch\n");
-		rtnval--;
+		dev_err(ksdev, "blkkey_ex: 128-bit restored key mismatch\n");
+		goto dealloc;
 	}

 	/* Only first AES block will match, remainder subject to padding */
 	if (memcmp(rstkey24, blkkey24, 16)) {
-		dev_info(ksdev, "blkkey_ex: 192-bit restored key mismatch\n");
-		rtnval--;
+		dev_err(ksdev, "blkkey_ex: 192-bit restored key mismatch\n");
+		goto dealloc;
 	}

 	if (memcmp(rstkey32, blkkey32, AES_BLOCK_PAD(32))) {
-		dev_info(ksdev, "blkkey_ex: 256-bit restored key mismatch\n");
-		rtnval--;
+		dev_err(ksdev, "blkkey_ex: 256-bit restored key mismatch\n");
+		goto dealloc;
 	}

+	rtnval = 0;

 	/* Remove keys from keystore */
 dealloc:
-	sm_keystore_slot_dealloc(ksdev, unit, keyslot8);
-	sm_keystore_slot_dealloc(ksdev, unit, keyslot16);
-	sm_keystore_slot_dealloc(ksdev, unit, keyslot24);
 	sm_keystore_slot_dealloc(ksdev, unit, keyslot32);
-
+dealloc_slot24:
+	sm_keystore_slot_dealloc(ksdev, unit, keyslot24);
+dealloc_slot16:
+	sm_keystore_slot_dealloc(ksdev, unit, keyslot16);
+dealloc_slot8:
+	sm_keystore_slot_dealloc(ksdev, unit, keyslot8);

 	/* Free resources */
 freemem:
@@ -457,6 +600,9 @@ int caam_sm_example_init(struct platform_device *pdev)
 	/* Disconnect from keystore and leave */
 	sm_release_keystore(ksdev, unit);

+	if (rtnval)
+		dev_err(ksdev, "Test failed\n");
+
 	return rtnval;
 }
 EXPORT_SYMBOL(caam_sm_example_init);
@@ -483,7 +629,6 @@ void caam_sm_example_shutdown(void)
 		return;

 	of_node_get(dev_node);
-
 }

 static int __init caam_sm_test_init(void)
@@ -508,9 +653,7 @@ static int __init caam_sm_test_init(void)

 	of_node_put(dev_node);

-	caam_sm_example_init(pdev);
-
-	return 0;
+	return caam_sm_example_init(pdev);
 }


--
2.7.4

