diff --git a/crypto/ec/ec_key.c b/crypto/ec/ec_key.c
index 456080e..29a2585 100644
--- a/crypto/ec/ec_key.c
+++ b/crypto/ec/ec_key.c
@@ -234,6 +234,13 @@ int EC_KEY_generate_key(EC_KEY *eckey)
     BIGNUM *priv_key = NULL, *order = NULL;
     EC_POINT *pub_key = NULL;
 
+#ifndef OPENSSL_NO_ENGINE
+    extern int cryptodev_ec_keygen(EC_KEY *eckey);
+    extern int cryptodev_eckey_mode(void);
+    if (cryptodev_eckey_mode())
+        return cryptodev_ec_keygen(eckey);
+#endif	
+
 #ifdef OPENSSL_FIPS
     if (FIPS_mode())
         return FIPS_ec_key_generate_key(eckey);
diff --git a/crypto/engine/eng_cryptodev.c b/crypto/engine/eng_cryptodev.c
index d8cac4b..e40b316 100644
--- a/crypto/engine/eng_cryptodev.c
+++ b/crypto/engine/eng_cryptodev.c
@@ -1441,6 +1441,429 @@ static DH_METHOD cryptodev_dh = {
     NULL                        /* app_data */
 };
 
+
+int cryptodev_eckey_mode(void)
+{
+    if (cryptodev_asymfeat & CRF_ECC_GENKEY)
+        return 1;
+    else
+        return 0;
+}
+
+int cryptodev_ec_keygen(EC_KEY *eckey)
+{
+
+	struct session_op sess;
+	struct crypt_kop kop;
+	
+	int ret = 0;
+	int alloc_priv = 0, alloc_pub = 0;
+	BN_CTX *ctx = NULL;
+	BIGNUM *priv_key = NULL, *order = NULL;
+	EC_POINT *pub_key = NULL;
+	unsigned char *pub_key_buf = NULL;
+	const EC_GROUP *group;
+	size_t pub_key_buf_sz = 0;
+	int plen;
+	int fd;
+	if (eckey == NULL || ((group = EC_KEY_get0_group(eckey)) == NULL)) {
+		perror("NULL()");
+		return 0;
+	}
+
+	if ((fd = get_asym_dev_crypto()) < 0)
+	{
+        perror("get_asym_dev_crypto()");
+		return ret;
+	}	
+	if ((ctx = BN_CTX_new()) == NULL) {
+		perror("BN_CTX_new()");
+		goto err;
+	}
+	BN_CTX_start(ctx);
+	if ((order = BN_CTX_get(ctx)) == NULL) {
+		perror("BN_CTX_get()");
+		goto err;
+	}
+	
+	memset(&sess, 0, sizeof(sess));
+	memset(&kop, 0, sizeof(kop));
+	sess.pk_cipher = CRYPTO_ASYM_ECC_GENKEY;
+	
+	if (ioctl(fd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		goto err;
+	} 
+	
+	plen = (EC_GROUP_get_degree(group)+7)/8;
+	
+	kop.crk_op = CRK_ECC_GENKEY;
+	kop.ses = sess.ses;
+	kop.crk_flags |= CAAM_KEY_COLOR_BLACK;
+	
+	kop.crk_iparams = 0;
+	kop.crk_param[kop.crk_iparams].crp_p = calloc(plen, sizeof(char));
+	kop.crk_param[kop.crk_iparams].crp_nbits = plen*8;
+	kop.crk_param[kop.crk_iparams + 1].crp_p = calloc(plen*2, sizeof(char));
+	kop.crk_param[kop.crk_iparams + 1].crp_nbits = plen*16;
+	kop.crk_oparams = 2;
+	
+	if (ioctl(fd, CIOCKEY, &kop) == 0) {
+	
+		if ((priv_key = (BIGNUM *)EC_KEY_get0_private_key(eckey)) == NULL) {
+			priv_key = BN_new();
+			if (priv_key == NULL) {
+				perror("EC_KEY_get0_private_key()");
+				goto err;
+			}
+			alloc_priv = 1;
+		}
+		
+		if (alloc_priv) {
+			crparam2bn(kop.crk_param[kop.crk_iparams], priv_key);
+			if (!EC_KEY_set_private_key(eckey, priv_key)) {
+				perror("EC_KEY_set_private_key()");
+				goto err;
+			}
+			BN_print_fp(stdout, priv_key);
+			putc('\n', stdout);
+
+		}	
+		
+		if ((pub_key = (EC_POINT *)EC_KEY_get0_public_key(eckey)) == NULL) {
+			pub_key = EC_POINT_new(group);
+			if (pub_key == NULL) {
+				perror("EC_POINT_new()");
+				goto err;
+			}
+			alloc_pub = 1;
+		}
+		
+		if (alloc_pub) {
+			
+			pub_key_buf_sz = ((kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8);
+			pub_key_buf = (unsigned char *) OPENSSL_malloc(pub_key_buf_sz + 1);
+			if (pub_key_buf == NULL) {
+				perror("malloc()");
+				goto err;
+			}
+			pub_key_buf[0] = 0x04;
+			memcpy(&pub_key_buf[1],kop.crk_param[kop.crk_iparams+1].crp_p, pub_key_buf_sz );
+			EC_POINT_oct2point(group, pub_key, pub_key_buf, pub_key_buf_sz + 1,ctx);
+			
+			if (!EC_KEY_set_public_key(eckey, pub_key)) {
+				perror("Error setting pub_key\n");
+				goto err;
+			}
+		}
+		ret = 1;
+	}	
+	/* Finish session */
+	if (ioctl(fd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+	}	
+	zapparams(&kop);
+err:  
+	if (alloc_pub)
+	EC_POINT_free(pub_key);
+	if (alloc_priv)
+	BN_clear_free(priv_key);
+	if(pub_key_buf)
+	OPENSSL_free(pub_key_buf);
+	if (ctx != NULL) {
+		BN_CTX_end(ctx);
+		BN_CTX_free(ctx);
+	}
+	return (ret);
+}
+
+
+
+static int
+EC_GROUP_order_bits(const EC_GROUP *group)
+{
+    BIGNUM* order = BN_new();
+    EC_GROUP_get_order(group, order, NULL);
+    int bits = BN_num_bits(order);
+    BN_free(order);
+    return bits;
+}
+
+static void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr,
+    const BIGNUM **ps) {
+    if (pr != NULL)
+        *pr = sig->r;
+    if (ps != NULL)
+        *ps = sig->s;
+}
+
+static int ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s)
+{
+    if (r == NULL || s == NULL)
+        return 0;
+    BN_clear_free(sig->r);
+    BN_clear_free(sig->s);
+    sig->r = r;
+    sig->s = s;
+    return 1;
+}
+static ECDSA_SIG *cryptodev_ecdsa_do_sign(const unsigned char *dgst, int dgst_len,
+		const BIGNUM * kinv, const BIGNUM * rp, EC_KEY * eckey)
+{
+	ECDSA_SIG *ecdsaret = NULL;
+	BIGNUM *r = NULL, *s = NULL;
+	int nlen;
+	int tmp_buf_len;
+	struct session_op sess;
+	struct crypt_kop kop;
+	const BIGNUM * priv_key = NULL;  
+	unsigned char *tmp_buf = NULL;
+	const EC_GROUP* group = NULL;
+	int fd;
+
+	/* input sanitization */
+	if ((group = EC_KEY_get0_group(eckey)) == NULL || 
+	(priv_key = EC_KEY_get0_private_key(eckey)) == NULL) {
+        perror("NULL()\n");
+        goto err;
+    }
+
+	if ((fd = get_asym_dev_crypto()) < 0)
+	{
+		perror("get_asym_dev_crypto()\n");
+        return ecdsaret;
+	}	
+	memset(&sess, 0, sizeof(sess));
+	memset(&kop, 0, sizeof(kop));
+	
+	sess.pk_cipher = CRYPTO_ASYM_ECDSA_SIGN;	
+	if (ioctl(fd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)\n");
+		goto err;
+	} 
+	
+	nlen =(EC_GROUP_order_bits(group)+7)/8;
+	
+	kop.crk_flags |= CAAM_KEY_COLOR_BLACK;
+	kop.crk_op = CRK_ECDSA_SIGN;
+	kop.ses = sess.ses;
+
+	tmp_buf_len = BN_num_bytes(priv_key);
+	
+	tmp_buf = OPENSSL_malloc(tmp_buf_len);
+	if (NULL == tmp_buf) {
+		perror("malloc()\n");
+		goto out;
+	}	
+	BN_bn2bin(priv_key, tmp_buf);
+	
+	/* Set parameter private key */
+	kop.crk_param[0].crp_p = OPENSSL_malloc(tmp_buf_len);
+	if(NULL == kop.crk_param[0].crp_p)
+	{
+		perror("malloc()\n");
+		goto out;
+	}
+	memset(kop.crk_param[0].crp_p, 0, tmp_buf_len);
+	kop.crk_param[0].crp_nbits = tmp_buf_len * 8;
+	memcpy(kop.crk_param[0].crp_p, tmp_buf, tmp_buf_len);
+
+	/* Set parameter f (or m) */
+	kop.crk_param[1].crp_p = OPENSSL_malloc(dgst_len);
+	if(NULL == kop.crk_param[1].crp_p)
+		{
+		perror("malloc()\n");
+		goto out;
+	}
+	memset(kop.crk_param[1].crp_p, 0, dgst_len);
+	kop.crk_param[1].crp_nbits = dgst_len * 8;
+	memcpy(kop.crk_param[1].crp_p, dgst, dgst_len);  		
+	kop.crk_iparams = 2;
+	
+	kop.crk_param[kop.crk_iparams].crp_p = calloc(nlen, sizeof(char));
+	kop.crk_param[kop.crk_iparams].crp_nbits = nlen * 8;
+	kop.crk_param[kop.crk_iparams + 1].crp_p = calloc(nlen, sizeof(char));
+	kop.crk_param[kop.crk_iparams + 1].crp_nbits = nlen * 8;
+	kop.crk_oparams = 2;
+	
+	if (ioctl(fd, CIOCKEY, &kop) == 0) {
+		ecdsaret = ECDSA_SIG_new();
+		if (ecdsaret == NULL) {
+			perror("ECDSA_SIG_new()");
+			goto out;
+		}
+				
+		r = BN_new ();
+		s = BN_new ();
+		
+		if (r) {
+			crparam2bn(kop.crk_param[kop.crk_iparams], r);
+		}
+		if (s) {			
+			crparam2bn(kop.crk_param[kop.crk_iparams + 1], s);
+		}
+		
+		if (!ECDSA_SIG_set0 (ecdsaret, r, s))
+		{
+			ecdsaret = NULL;
+			perror("ECDSA_SIG_set0()");
+			goto out;
+		}
+	}	
+out:
+	/* Finish session */
+	if (ioctl(fd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+	}	
+	zapparams(&kop);
+	
+err:  
+	if(tmp_buf)	
+	OPENSSL_free(tmp_buf);  
+	return (ecdsaret);
+}
+
+static int cryptodev_ecdsa_do_verify(const unsigned char *dgst, int dgst_len,
+const ECDSA_SIG *sig, EC_KEY *eckey)
+{
+	struct session_op sess;
+	struct crypt_kop kop;
+	const EC_GROUP* group = NULL;
+	int ret = -1;
+
+	const BIGNUM *r = NULL;
+	const BIGNUM *s = NULL;
+	int tmp_buf_len;
+	unsigned char* tmp_buf = NULL;
+	u_int8_t *pubKey2 = NULL;
+	int fd;
+	/* input sanitization */
+    if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL ||
+        EC_KEY_get0_public_key(eckey) == NULL || sig == NULL) {
+        perror("NULL()");
+        goto err;
+    }
+	
+	if ((fd = get_asym_dev_crypto()) < 0)
+        return ret;
+		
+	memset(&sess, 0, sizeof(sess));
+	memset(&kop, 0, sizeof(kop));
+
+	sess.pk_cipher = CRYPTO_ASYM_ECDSA_VERIFY;
+	
+	if (ioctl(fd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)\n");
+		goto err;
+	}
+
+	
+	kop.crk_flags |= CAAM_KEY_COLOR_BLACK;
+	kop.crk_op = CRK_ECDSA_VERIFY;
+	kop.ses = sess.ses;
+
+	/* Set parameter public key */
+	tmp_buf_len = i2o_ECPublicKey(eckey, NULL);
+
+	if (tmp_buf_len == 0) {
+		perror("error: EC_POINT_point2oct() failed.\n");
+		goto out;
+	}	
+	
+	tmp_buf = OPENSSL_malloc(tmp_buf_len);
+	if (!tmp_buf) {
+		perror("malloc()");
+		goto err;
+	}	
+	pubKey2 = tmp_buf;
+	tmp_buf_len = i2o_ECPublicKey(eckey, &pubKey2);
+	
+	tmp_buf_len-=1;
+
+
+	/* Set parameter public key */
+	kop.crk_param[0].crp_p = OPENSSL_malloc(tmp_buf_len);
+	if(NULL == kop.crk_param[0].crp_p)
+	goto out;
+	memset(kop.crk_param[0].crp_p, 0, tmp_buf_len);
+	kop.crk_param[0].crp_nbits = tmp_buf_len * 8;
+	memcpy(kop.crk_param[0].crp_p, tmp_buf+1, tmp_buf_len);	
+	
+	/* Set parameter f (or m) */
+	kop.crk_param[1].crp_p = OPENSSL_malloc(dgst_len);
+	if(NULL == kop.crk_param[1].crp_p)
+	goto out;
+	memset(kop.crk_param[1].crp_p, 0, dgst_len);
+	kop.crk_param[1].crp_nbits = dgst_len * 8;
+	memcpy(kop.crk_param[1].crp_p, dgst, dgst_len);  
+	
+	ECDSA_SIG_get0(sig, &r, &s);
+	/* Set parameter c (or r) */
+	tmp_buf_len = BN_num_bytes(r);
+	tmp_buf = OPENSSL_malloc(tmp_buf_len);
+	if (NULL == tmp_buf) {
+		perror("malloc()");
+		goto err;
+	}	
+	BN_bn2bin(r, tmp_buf);
+	kop.crk_param[2].crp_p = OPENSSL_malloc(tmp_buf_len);
+	if(NULL == kop.crk_param[2].crp_p)
+	goto out;
+	memset(kop.crk_param[2].crp_p, 0, tmp_buf_len);
+	kop.crk_param[2].crp_nbits = tmp_buf_len * 8;
+	memcpy(kop.crk_param[2].crp_p, tmp_buf, tmp_buf_len);  
+	
+	/* Set parameter d (or s) */
+	tmp_buf_len = BN_num_bytes(s);
+	tmp_buf = OPENSSL_malloc(tmp_buf_len);
+	if (NULL == tmp_buf) {
+		perror("malloc()");
+		goto err;
+	}	
+	BN_bn2bin(s, tmp_buf);
+	kop.crk_param[3].crp_p = OPENSSL_malloc(tmp_buf_len);
+	if(NULL == kop.crk_param[3].crp_p)
+	goto out;
+	memset(kop.crk_param[3].crp_p, 0, tmp_buf_len);
+	kop.crk_param[3].crp_nbits = tmp_buf_len * 8;
+	memcpy(kop.crk_param[3].crp_p, tmp_buf, tmp_buf_len);  
+	
+	kop.crk_iparams = 4;
+
+	if (ioctl(fd, CIOCKEY, &kop) == 0) {
+		if (kop.crk_status == 1){
+			ret = 1;
+		}
+		else if (kop.crk_status == 0) {
+			ret = 0	;
+		}	
+	}	
+	
+out:
+	/* Finish session */
+	if (ioctl(fd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+	}	
+	zapparams(&kop);
+
+err:  
+	if(tmp_buf)	
+	OPENSSL_free(tmp_buf);
+	return ret;		
+}
+
+static ECDSA_METHOD *cryptodev_ecdsa = {
+    "cryptodev ECDSA method",
+    NULL,
+    NULL,                       /* ecdsa_sign_setup */
+    NULL,
+    NULL,
+    0,                          /* flags */
+    NULL                        /* app_data */
+};
+
+
+
 /*
  * ctrl right now is just a wrapper that doesn't do much
  * but I expect we'll want some options soon.
@@ -1541,6 +1964,15 @@ void ENGINE_load_cryptodev(void)
         }
     }
 
+	if (ENGINE_set_ECDSA (engine, cryptodev_ecdsa)) {
+		const ECDSA_METHOD *ecdsa_meth = ECDSA_OpenSSL();
+		ECDSA_METHOD_set_name(ecdsa_meth, "cryptodev ECDSA method");
+        if(cryptodev_asymfeat & CRF_ECDSA_SIGN)
+		ECDSA_METHOD_set_sign (ecdsa_meth, cryptodev_ecdsa_do_sign);
+		if(cryptodev_asymfeat & CRF_ECDSA_VERIFY)
+		ECDSA_METHOD_set_verify(ecdsa_meth, cryptodev_ecdsa_do_verify);
+    }	
+	
     ENGINE_add(engine);
     ENGINE_free(engine);
     ERR_clear_error();
